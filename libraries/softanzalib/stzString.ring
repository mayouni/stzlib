#-------------------------------------------------------------------------#
# 		   SOFTANZA LIBRARY (V1.0) - STZSTRING			  #
#	An accelerative library for Ring applications, and more!	  #
#-------------------------------------------------------------------------#
#									  #
# 	Description	: The core class for managing Unicode strings     #
#	Version		: V1.0 (2020-2023)				  #
#	Author		: Mansour Ayouni (kalidianow@gmail.com)		  #
#								          #
#-------------------------------------------------------------------------#

/*
	TODO Add:
	QStringRef methods

	TODO: use QStringView for read-only operations, and QByteArray for
	UT8-only string
	#--> Better performance.

	Todo:
	Get inspiration from the pyhthon ftfy library to add Unicode text
	cleansing in Softanza
	link: https://ftfy.readthedocs.io/en/latest/fixes.html
*/

  /////////////////////
 ///   FUNCTIONS   ///
/////////////////////

func StzStringQ(str)
	return new stzString(str)

func StzStringMethods()
	return Stz(:String, :Methods)

func StzStringAttributes()
	return Stz(:String, :Attributes)

func StzStringClassName()
	return Stz(:String, :ClassName)

	func StzStringClass()
		return StzStringClassName()

func S(p)
	if isString(p)
		return p

	but isNumber(p)
		return ""+ p

	but isList(p)
		return Q(p).ToCode()

	but isObject(p)
		return LQ(p).ToCode()
	ok

	func SQ(p)
		return Q( S(p) )

		func QS(p)
			return SQ(p)

func IsNotString(pcStr)
	return NOT isString(pcStr)
	
func IsNullString(cStr)
	if isString(cStr) and cStr != NULL
		return TRUE
	else
		return FALSE
	ok

	func IsEmptyString(cStr)
		return IsNullString(cStr)

func IsNonNullString(cStr)
	return NOT IsNullString(cStr)

	func IsNonEmptyString(cStr)
		return This.IsNonNullString(cStr)

	func IsFullString(cStr)
		return This.IsNonNullString(cStr)

func StringToQString(cStr)
	oStr = new stzString(cStr)
	return oStr.QStringObject()
	
func IsQString(p)

	if isObject(p) and ( classname(p) = "qstring" or classname(p) = "qstring2" )
		return TRUE
	else
		return FALSE
	ok

	#--

	def IsQStringObject(p)
		return IsQString(p)
	
func QStringContent(oQStr)

	try
		return oQStr.left(oQStr.count())
	catch
		stzRaise(stzStringError(:CanNotTransformQStringToString))
	done

	#--

	func QStringObjectContent(oQStr)
		return QStringContent(oQStr)

	func QStringToString(oQStr)
		return QStringContent(oQStr)

	func QStringObjectToString(oQStr)
		return QStringContent(oQStr)
	
func QStringToStzString(oQString)
	return new stzString(QStringToString(oQString))

	func QStringObjectToStzString(oQString)
		return QStringToStzString(oQString)
	
func StringIsEmpty(pcStr)
	return pcStr = ""

func StringIsNull(pcStr)
	return pcStr = ""

func StzStringToQString(oStr)
	return oStr.QStringObject()
	
func StringIsLocaleAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLocaleAbbreviation()
	
func StringIsLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageAbbreviation()
	
func StringIsShortLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortLanguageAbbreviation()
	
func StringIsLongLanguageAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongLanguageAbbreviation()
	
func StringIsLanguageName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageName()
	
func StringIsLanguageNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLanguageNumber()
	
func StringIsCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryAbbreviation()
	
func StringIsCountryName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryName()
	
func StringIsCountryNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsCountryNumber()
	
func StringIsShortCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsShortCountryAbbreviation()
	
func StringIsLongCountryAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsLongCountryAbbreviation()
	
func StringIsScriptAbbreviation(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptAbbreviation()
	
func StringIsScriptName(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptName()
	
func StringIsScriptNumber(cStr)
	oStr = new stzString(cStr)
	return oStr.IsScriptNumber()
	
func StringIsLowercase(cStr)
	return StzStringQ(cStr).IsLowercase()

func StringIsUppercase(cStr)
	return StzStringQ(cStr).IsUppercase()

func StringLowercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Lowercased()
	
	func StringLowercase(cStr)
		return StringLowercased(cStr)

func StringUppercased(cStr)
	oStr = new stzString(cStr)
	return oStr.Uppercased()
	
	func StringUppercase(cStr)
		return StringUppercased(cStr)
	
func StringTitlecased(cStr)
	oStr = new stzString(cStr)
	return oStr.Titlecased()
	
	func StringTitlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecase(cStr)
		return StringTitlecased(cStr)

	func Titlecased(cStr)
		return StringTitlecased(cStr)

	
func StringAlign(cString, nWidth, cChar, cDirection)
	oString = new stzString(cString)
	return oString.AlignXTQ(nWidth, cChar, cDirection).Content()
	
func StringLeftAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Left)
	
func StringRightAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Right)
	
func StringCenterAlign(cString, nWidth, cChar)
	return StringAlign(cString, nWidth, cChar, :Center)
	
func StringRepeat(cString, n)
	oString = new stzString(cString)
	return oString.RepeatedNTimes(n)
	
func StringNumberOfChars(cStr)
	oString = new stzString(cStr)
	return oString.NumberOfChars()
	
func StringReverseChars(cStr)
	oString = new stzString(cStr)
	return oString.CharsReversed()
	
func StringIsWord(cStr)
	oString = new stzString(cStr)
	return oString.IsWord()
	
func StringContains(pcStr, pcSubStr)
	return StzStringQ(pcStr).Contains(pcSubStr)
	
func StringNumberOfOccurrence(pcStr, pcSubStr)
	return StzStringQ(pcStr).NumberOfOccurrence(pcSubStr)
	
func StringToUnicodes(pcStr)
	return StzStringQ(pcStr).Unicodes()
	
	func StringUnicodes(pcStr)
		return StringToUnicodes(pcStr)
	
func StringInvert(cStr)
	return StzStringQ(cStr).Inverted()
	
func StringScript(cStr)
	return StzStringQ(cStr).Script()

# Some functions used mainly in natural-code

func UppercaseOf(cStr)
	return StzStringQ(cStr).Uppercased()

	func UppercaseIn(cStr)
		return UppercaseOf(cStr)

func LowercaseOf(cStr)
	return StzStringQ(cStr).Lowercased()

	func LowercaseIn(cStr)
		return LowercaseOf(cStr)

func FoldcaseOf(cStr)
	return StzStringQ(cStr).Foldcase()

	func FoldcaseIn(cStr)
		return FoldcaseOf(cStr)

func NthCharOf(n, cStr)
	return StzStringQ(cStr)[n]

	func NthCharIn(n, cStr)
		return NthCharOf(n, cStr)

func NthLetterOf(n, cStr)
		aOnlyLetters = StzStringQ(cStr).OnlyLetters()
		return aOnlyLetters[n]

	func NthLetterIn(n, cStr)
		return NthLetterOf(n, cStr)

func StringIsArabicWord(pcStr)
	return StzStringQ(pcStr).IsArabicWord()

func StringIsCharName(pcStr)
	return StzStringQ(pcStr).IsCharName()

# Used for natural-coding

func String(pcStr)
	if isString(pcStr)
		return pcStr
	ok

func Text(pcStr)
	# NOTE: In the future, there will be a difference
	# between String and Text
	if isString(pcStr)
		return pcStr
	ok

func String@(pcStr)
	if isString(pcStr)
		return ComputableForm(pcStr)
	ok

func NumberOfCharsOf(pcStr)
	return StzStringQ(pcStr).NumberOfChars()

	func NumberOfCharsIn(pcStr)
		return NumberOfCharsOf(pcStr)

func BothStringsAreEqualCS(pcStr1, pcStr2, pCaseSensitive)
	return StringsAreEqualCS( [ pcStr1, pcStr2 ], pCaseSensitive )

func BothStringsAreEqual(pcStr1, pcStr2)
	return BothStringsAreEqualCS(pcStr1, pcStr2, :CaseSensitive = TRUE)

func StringsAreEqualCS(pacStr, pCaseSensitive)
	if NOT ListIsListOfStrings(paStr)
		stzRaise("Incorrect param type! pacStr must b a list of strings!")
	ok

	if NOT len(paStr) > 1
		stzRaise("You must provide at least two strings pacStr!")
	ok

	# Resolving pCaseSensitive

	if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
		pCaseSensitive = pCaseSensitive[2]
	ok

	if isString(pCaseSensitive)
		if Q(pCaseSensitive).IsOneOfThese([
			:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

			pCaseSensitive = TRUE
			
		but Q(pCaseSensitive).IsOneOfThese([
			:CaseInSensitive, :NotCaseSensitive, :NotCS,
			:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

			pCaseSensitive = FALSE
		ok

	ok

	if NOT IsBoolean(pCaseSensitive)
		stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
	ok

	# Doing the job

	bResult = TRUE
	nLen = len(pacStr)

	if pCaseSensitive = TRUE
		
		cFirstStr = StzStringQ(pacStr[1]).Lowercased()
		
		for i = 2 to nLen
			if StzStringQ(paStrings[i]).Lowercased() != cFirstStr
				bResult = FALSE
				exit
			ok 
		next

		return bResult
	else

		cFirstStr = paStrings[1]
		
		for i = 1 to nLen
			if paStrings[i] != cFirstStr
				bResult = FALSE
				exit
			ok
		next

	ok

	return bResult

func StringsAreEqual(paStrings)
	return StringsAreEqualCS(paStrings, :CaseSensitive = TRUE)

func RemoveDiacritics(pcStr)
	return StzStringQ(pcStr).DiacriticsRemoved()

func StringCases()
	return [ :Lowercase, :Uppercase, :Capitalcase, :Titlecase, :Foldercase ]

func StringCase(pcStr)

	return StzStringQ(pcStr).StringCase()

func Interpolate(pcStr)
	return Q(pcStr).Interpolated()

	#< @FunctionMisspelledForm

	func Interpoltate(pcStr)
		return Intrepolate(pcStr)

	func Intrepolate(pcStr)
		return Interpolate(pcStr)

	#>

  /////////////////
 ///   CLASS   ///
/////////////////

class stzString from stzObject

	@oQString
	@aConstraints = []

	@cLanguage = :English	# Set explicitly using SetLanguage()
				# TODO (future): Infere the language from the string

	// Initializes the content of the softanza string object
	def init(pcStr)

		if isString(pcStr)
			@oQString = new QString2()
			@oQString.append(pcStr)

		but IsQString(pcStr)
			@oQString = pcStr

		else
			stzRaise("Can't create the stzString object! You must provide a string, a QString.")
		ok

	  #==========================#
	 #   CHECKING CONSTRAINTS   #
	#==========================#
	# TODO: Generalize this feature to other classes

	def EnforcedConstraints()
		return @@aConstraints

		def Constraints()
			return This.EnforcedConstraints()

	def VerifyConstraint(pcConstraintName)

		@str = This.Content()

		cCondition = Constraints()[ :OnStzString ][ pcConstraintName ]

		if cCondition = NULL
			stzRaise("Inexsitant contraint!")
		ok

		CompileConstraint(cCondition)

		StzStringQ(cCondition) {

			ReplaceCS("@string", @str, :CS = FALSE)
			Simplify()
			RemoveTheseBounds("{", "}")

			cCondition = Content()
		}

		cCode  = 'bResult = ""+ (' + cCondition + ')'
		eval(cCode)

		if bResult = FALSE
			stzRaise([
				:Where = "stzString.ring > VerifyCondition()",
				:What  = "Execution is cancelled by Softanza",
				:Why   = "A constraint on the string object is not verified!",
				:Todo  = "Check that constraint (" + pcName + ") and adjust your logic accordingly ;)"

			])
		ok

	def VerifyConstraints()
		bResult = TRUE

		for aPair in This.Constraints()
			cConstraintName = aPair[1]
			This.VerifyConstraint(cConstraintName) = FALSE
			
		next

	  #=======================================#
	 #     GETTING CONTENT OF THE STRING     #
	#=======================================#

	// Returns the string's content
	def Content()

		return QStringToString( @oQString )

		#< @FunctionFluentForm

		def ContentQ()
			return This

		#>
	
	def QStringObject()
		return @oQString

		def ToQStringObject()
			return This.QStringObject()

		def ToQString()
			return This.QStringObject()

	def String()
		return This.Content()

		#< @FunctionFluentForm

		def StringQ() # Same as Copy()
			return new stzString( This.String() )
	
		#>

	  #=======================================#
	 #  GETTING A COPY OF THE STRING OBJECT  #
	#=======================================#

	def Copy()
		return new stzString( This.String() )

	def ReversedCopy()
		return This.ReverseQ()

	  #==================================#
	 #  GETTING THE CASE OF THE STRING  #
	#==================================#

	def StringCase()

		if This.IsLowercase()

			return :Lowercase

		but This.IsUppercase()

			return :Uppercase

		but This.IsCapitalcase()

			return :Capitalcase

		but This.IsTitlecase()

			return :Titlecase

		but This.IsCaseFold()

			return :Casefold

		else

			return :Hybridcase
		ok

	  #---------------------------------------------#
	 #  IF THE STRING IS A CHAR, GETTING ITS CASE  #
	#---------------------------------------------#

	def CharCase()
		if This.NumberOfChars() = 1
			return This.StringCase()
		ok

	  #---------------------------------------------------------------------#
	 #  CHECKING IF THE STRING HAS THE SAME CASE AS AN OTHER GIVEN STRING  #
	#---------------------------------------------------------------------#

	def HasSameCaseAs(pcOtherStr)
		return This.CharCase() = StzStringQ(pcOtherStr).CharCase()

		def HasSameCharCaseAs(pcOtherStr)
			return This.HasSameCaseAs(pcOtherStr)

		#< @FunctionNegativeForm

		def HasDifferentCaseAs(pcOtherStr)
			return NOT This.HasSameCaseAs(pcOtherStr)

		def HasDifferentCharCase(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

		def HasNoSameCaseAs(pcOtherStr)
			return This.HasDifferentCaseAs(pcOtherStr)

			def HasNoSameCharCaseAs(pcOtherStr)
				return This.HasNoSameCaseAs(pcOtherStr)

		#>

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING IS IN HYBRID CASE  #
	#--------------------------------------------#

	def IsHybridcase()
		return Q( This.StringCase() ).IsNotOneOfThese([ StringCases() ])

		def IsHybridCased()
			return This.IsHybridcase()

	  #===========================================#
	 #   APPENDING THE STRING WITH A SUBSTRING   #
	#===========================================#

	def AppendWith(pcStr)

		if NOT isString(pcStr)
			StzRaise("Incorrect param type! pcStr must be a string.")
		ok

		cResult = This.String() + pcStr
		This.UpdateWith( cResult )

		#< @FunctionFluentForm

		def AppendWithQ(pcStr)
			This.AppendWith(pcStr)
			return This
	
		#>

		#< @FunctionAlternative

		def Append(pcStr)
			if isList(pcStr) and Q(pcStr).IsWithOrByNamedParam()
				pcStr = pcStr[2]
			ok

			This.AppendWith(pcStr)

			def AppendQ(pcStr)
				This.Append(pcStr)
				return This
	
		#>

	def AppendedWith(pcStr)
		cResult = This.Copy().AppendWithQ(pcStr).Content()
		return cResult

		def Appended(pcStr)
			cResult = This.Copy().AppendQ(pcStr).Content()
			return cResult

	  #-------------------------------------#
	 #   APPENDING THE STRING FROM START   #
	#-------------------------------------#

	def Prepend(pcOtherStr)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithOrByNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		cResult = pcOtherStr + This.String()
		This.Update( cResult )

		#< @FunctionFluentForm

		def PrpendQ(pcOtherStr)
			This.Prepend(pcOtherStr)
			return This
	
		#>

	def Prepended(pcOtherStr)
		return This.Copy().PrependQ(pcOtherStr).Content()

	  #=================================#
	 #  ADDING A SUBSTRING --EXTENDED  #
	#=================================#

	def AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("Ring programin language")
		o1.Add("g", :To = "programmin")

		? o1.Content()
		#--> Ring programming language
		*/

		if isList(pcSubStr)
			oSubStr = new stzList(pcSubStr)

			# Adding after

			if oSubStr.IsOneOfTheseNamedParams([ :After, :AfterEach, :To, :ToEach  ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after nth

			but oSubStr.IsOneOfTheseNamedParams([ :AfterNth, :ToNth ])
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]
				This.ReplaceNthCS(n, pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding after first

			but oSubStr.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				pcSubStr = pcSubStr[2]
				This.ReplaceFirstCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			# Adding atfer last

			but oSubStr.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				pcSubStr = pcSubStr[2]
				This.ReplaceLastCS(pcSubStr, (pcSubStr + pcNewSubStr), pCaseSensitive)

			#==

			# Adding before

			but oSubStr.IsOneOfTheseNamedParams([ :Before, :BeforeEach ])
				pcSubStr = pcSubStr[2]
				This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before nth

			but oSubStr.IsBeforeNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)
		
			# Adding before first

			but oSubStr.IsBeforeFirstNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			# Adding before last

			but oSubStr.IsBeforeLastNamedParam()
				pcSubStr = pcSubStr[2]

				This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr), pCaseSensitive)

			#==

			# Adding around

			but oSubStr.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)

				else	
					This.ReplaceCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around nth

			but oSubStr.IsAroundNthNamedParam()
				n = pcSubStr[2][1]
				pcSubStr = pcSubStr[2][2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceNthCS(n, pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok
		
			# Adding around first

			but oSubStr.IsAroundFirstNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceFirstCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			# Adding around last

			but oSubStr.IsAroundLastNamedParam()
				pcSubStr = pcSubStr[2]

				if isList(pcNewSubStr) and Q(pcNewSubStr).IsPairOfStrings()
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr[1] + pcSubStr + pcNewSubStr[2]), pCaseSensitive)
				else
					This.ReplaceLastCS(pcSubStr, (pcNewSubStr + pcSubStr + pcNewSubStr), pCaseSensitive)
				ok

			ok

		ok

		def AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.AddCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def AddedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().AddCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def AddXT(pcNewSubStr, pcSubStr)
		This.AddCSXTQ(pcNewSubStr, pcSubStr, :CaseSensitive = TRUE)

		def AddXTQ(pcNewSubStr, pcSubStr)
			This.AddXT(pcNewSubStr, pcSubStr)
			return This

	def AddedXT(pcNewSubStr, pcSubStr)
		return This.Copy().AddXTQ(pcNewSubStr, pcSubStr).Content()

	  #=================================================#
	 #  EXTENDING THE STRING WITH THE GIVEN SUBSTRING  #
	#=================================================#

	def ExtendWith(pSubStr)
		if isList(pSubStr)
			This.ExtendWithMany(pSubStr)
			return
		ok

		if NOT isString(pSubStr)
			StzRaise("Incorrect param type! pSubStr must be a string.")
		ok

		This.AppendWith(pSubStr)

		#< @FunctionFluentForm

		def ExtendWithQ(pSubStr)
			This.ExtendWith(pSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendWithSubString(pSubStr)
			This.ExtendWith(pSubStr)

			def ExtendWithSubStringQ(pSubStr)
				This.ExtendWithSubString(pSubStr)
				return This

		#>

	def ExtendedWith(pSubStr)
		aResult = This.Copy().ExtendWithQ(pSubStr).Content()
		return aResult

		def ExtendedWithSubString(pSubStr)
			return This.ExtendedWith(pSubStr)

	  #---------------------------------------------#
	 #  EXTENDING THE STRING WITH MANY SUBSTRINGS  #
	#---------------------------------------------#

	def ExtendWithMany(pacSubStr)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		This.AppendWith( QR(pacSubStr, :stzListOfStrings).Concatenated() )

		#< @FunctionFluentForm

		def ExtendWithManyQ(pacSubStr)
			This.ExtendWithMany(pacSubStr)

		#>

		#< @FunctionAlternativeForms

		def ExtendWithTheseSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithSubStrings(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		def ExtendWithThese(pacSubStr)
			This.ExtendWithTheseSubStrings(pacSubStr)

		#>

	def ExtendedWithMany(pacSubStr)
		cResult = This.Copy().ExtendWithManyQ(pacSubStr).Content()
		return cResult

		def ExtendedWithTheseSubStrings(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

		def ExtendedWithThese(pacSubStr)
			return This.ExtendedWithMany(pacSubStr)

	  #-----------------------------------#
	 #  EXTENDING THE STRING TO N CHARS  #
	#-----------------------------------#

	def ExtendToPosition(n)

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()

		This.AppendWith( Q(" ").RepeatedNTimes( n - nLen ) )
		
		#< @FunctionFluentForm

		def ExtendToPositionQ(n)
			This.ExtendToPosition(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendTo(n)
			if isList(n) and
			   ( Q(n).IsPositionNamedParam() or Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendToQ(n)
				This.ExtendTo(n)
				return This

		def ExtendToNChars(n)
			This.ExtendToPosition(n)
			
			def ExtendToNCharsQ(n)
				This.ExtendToNChars(n)
				return This

		def Extend(n)
			if isList(n) and Q(n).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToNChars ])
				n = n[2]
			ok
	
			This.ExtendToPosition(n)
			
			def ExtendQ(n)
				This.Extend(n)
				return This

		#>

	def ExtendedToPosition(n)
		cResult = This.Copy().ExtendToPositionQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ExtendedTo(n)
			cResult = This.Copy().ExtendToQ(n).Content()
			return cResult

		def Extended(n)
			cResult = This.Copy().ExtendQ(n).Content()
			return cResult

		def ExtendedToNChars(n)
			return This.ExtendedToPosition(n)

		#>

	  #--------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION WITH A GIVEN CHAR  #
	#--------------------------------------------------------------#

	def ExtendToPositionWith(n, pcChar)

		if isString(pcChar) and pcChar = :CharsRepeated
			This.ExtendToPositionWithCharsRepeadted(n)
			return
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( isString(pcChar) and Q(pcChar).IsChar() )
			StzRaise("Incorrect param type! pcChar must be a char.")
		ok

		nLen = This.NumberOfChars()

		if n > nLen
			This.AppendWith( Q(pcChar).RepeatedNTimes(n - nLen) )
		ok

		#< @FunctionFluentForm

		def ExtendToPositionWithQ(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWith(n, pcChar)
			This.ExtendToPositionWith(n, pcChar)

			def ExtendToWithQ(n, pcChar)
				This.ExtendToWith(n, pcChar)
				return This

		#>


	def ExtendedToPositionWith(n, pcChar)
		cResult = This.Copy().ExtendToPositionWithQ(n, pcChar)
		return This

		def ExtendedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#< @FunctionMisspelledForm

		def ExtendtedToWith(n, pcChar)
			return This.ExtendedToPositionWith(n, pcChar)

		#>

	  #--------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE STRING CHARS  #
	#--------------------------------------------------------------------------#

	def ExtendToPositionWithCharsRepeadted(n)
		This.ExtendToPositionWithCharsIn(n, This.Chars())

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsRepeadtedQ(n)
			This.ExtendToPositionWithCharsRepeadted(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToWithCharsRepeatedQ(n)
				This.ExtendToWithCharsRepeated(n)
				return This

		def ExtendToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToPositionByRepeadingCharsQ(n)
				This.ExtendToPositionByRepeadingChars(n)
				return This

		def ExtendToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToByRepeatingCharsQ(n)
				This.ExtendToByRepeatingChars(n)
				return This

		#>

		#< @FunctionMisspelledForm

		def ExtendToWithCharsRepeadted(n)
			This.ExtendToPositionWithCharsRepeadted(n)

			def ExtendToWithCharsRepeadtedQ(n)
				This.ExtendToWithCharsRepeadted(n)
				return This
		#>

	def ExtendedToPositionWithCharsRepeated(n)
		cResult = This.Copy().ExtendToPositionWithCharsRepeatedQ(n).Content()
		return cResult

		#< @FunctionAlternativeForm

		def ExtendedToWithCharsRepeated(n)
			This.ExtendToPositionWithCharsRepeated(n)

		def ExtendedToPositionByRepeadingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

		def ExtendedToByRepeatingChars(n)
			This.ExtendToPositionWithCharsRepeated(n)

		#>

		#< @FunctionMisspelledForm

		def ExtendedToWithCharsRepeadted(n)
			This.ExtendToPositionWithCharsRepeated(n)

		#>

	  #-------------------------------------------------------------------------#
	 #  EXTENDING THE STRING TO A GIVEN POSITION BY REPEATING THE GIVEN CHARS  #
	#-------------------------------------------------------------------------#

	def ExtendToPositionWithCharsIn(n, pacChars)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT ( isList(pacChars) and Q(pacChars).IsListOfChars() )
			StzRaise("Incorrect param type! pacChars must be a list or chars.")
		ok

		nLen = len(pacChars)
		nTemp = n - nLen

		cTemp = ""

		if nTemp > 0
			j = 0
			for i = 1 to nTemp
				j++
				if j > nLen
					j = 1
				ok

				cTemp += pacChars[j]
			next
		ok

		This.ExtendWith(cTemp)

		#< @FunctionFluentForm

		def ExtendToPositionWithCharsInQ(n, pacChars)
			This.ExtendToPositionWithCharsIn(n, pacChars)
			return This

		#>

		#< @FunctionAlternativeForm

		def ExtendToWithCharsIn(n, pacChars)
			return This.ExtendToPositionWithCharsIn(n, pacChars)

			def ExtendToWithCharsInQ(n, pacChars)
				This.ExtendToWithCharsIn(n, pacChars)
				return This

		#>

	def ExtendedToPositionWithCharsIn(n, pacChars)
		cResult = This.Copy().ExtendToPositionWithCharsInQ(n, pacChars).Content()
		return cResult

		def ExtendedToWithCharsIn(n, pacChars)
			return This.ExtendedToPositionWithCharsIn(n, pacChars)

	  #-----------------------------------------#
	 #  EXTENDING THE STRING - A GENERAL FORM  #
	#-----------------------------------------#

	def ExtendXT(n, pWith)
		/*
		EXAMPLE 1

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :With = "DE")
		o1.Show()
		#--> "ABCDE"

		EXAMPLE 2

		o1 = new stzString("ABC")
		o1.ExtendXT( :String, :ToPosition = 5 )
		o1.Show()
		#--> "ABCDE  "

		EXAMPLE 3

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeadted )
		o1.Show()
		#--> "ABCDEAB"

		EXAMPLE 4

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPosition = 5, :With = "*" )
		o1.Show()
		#--> "ABCDE**"

		EXAMPLE 5

		o1 = new stzString("ABC")
		o1.ExtendXT( :ToPostion = 5, :WithCharsIn = [ "D", "E" ])
		o1.Show()
		#--> "ABCDEDE"

		*/

		if isString(n) and n = :String

			# Case 1: o1.ExtendXT( :String, :With = "DE")
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if isList(pWith) and Q(pWith).IsWithOrUsingOrByNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeated )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeadted(n[2])
					# Note this is a misspelled form --> ...Repea(d)ted()
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    Q(pWith).IsOneOfThese([
				:ByRepeatingChars, :WithCharsItemsRepeated, :ByCharsRepeated ] )

				if isList(n) and Q(n).IsToOrToPositionNamedParam()
					n = n[2]
				ok

				This.ExtendToPositionWithCharsRepeadted(n)
				return

			# Case 5: o1.ExtendXT( :ToPostion = 5, :WithCharsIn = "DE")
			but Q(pWith).IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

/*
		if isString(n) and n = :String

			# Case 1: o1.ExtendXT( :String, :With = "DE")
			if isList(pWith) and Q(pWith).IsWithOrByOrUsingNamedParam()
				This.ExtendWith(pWith[2])
				return

			# Case 2: o1.ExtendXT( :String, :ToPosition = 5 )
			but isList(pWith) and Q(pWith).IsToOrToPositionNamedParam()
				This.ExtendToPosition(pWith[2])
				return

			ok

		but isList(n) and Q(n).IsToOrToPositionNamedParam()

			if Q(pWith).IsWithOrUsingNamedParam() 

				# Case 3: o1.ExtendXT( :ToPosition = 5, :With = :CharsRepeadted )
				if isString(pWith[2]) and
				   ( pWith[2] = :CharsRepeated or pWith[2] = :RepeatingChars )

					This.ExtendToPositionWithCharsRepeadted(n[2])
					return
	
				# Case 4: o1.ExtendXT( :ToPosition = 5, :With = "*" )
				else
					This.ExtendToPositionWith(n[2], pWith[2])
					return
				ok

			but isString(pWith) and
			    ( pWith = :ByRepeatingChars or pWith = :WithCharsRepeated )

				This.ExtendToPositionWithCharsRepeadted(n)
				return

			# Case 5: o1.ExtendXT( :ToPostion = 5, :WithCharsIn = [ "D", "E" ])
			but Q(pWith).IsWithCharsInNamedParam()
				This.ExtendToPositionWithCharsIn(n[2], pWith[2])
				return

			ok
		ok

		StzRaise("Unsupported syntax!")
*/
		#< @FunctionFluentForm
	
		def ExtendXTQ(n, pWith)
			This.ExtendXT(n, pWith)
			return This

		#>

	def ExtendedXT(n, pWith)
		cResult = This.Copy().ExtendXTQ(n, pWith).Content()
		return cResult

	  #--------------------------------------------#
	 #  SHRINKING THE STRING TO A GIVEN POSITION  #
	#============================================#

	def ShrinkTo(n)
		if isList(n) and
		   ( Q(n).IsPositionNamedParam() or Q(n).IsNCharsNamedParam() )

			n = n[2]
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nLen = This.NumberOfItems()
		if n < nLen
			This.RemoveSection( n+1, nLen )
		ok

		#< @FunctionFluentForm

		def ShrinkToQ(n)
			This.ShrinkTo(n)
			return This

		#>

		#< @FunctionAlternativeForm

		def ShrinkToPosition(n)
			This.ShrinkTo(n)

			def ShrinkToPositionQ(n)
				This.ShrinkToPosition(n)
				return This

		def ShrinkToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			This.ShrinkToPosition(n)

			def ShrinkToNCharsQ(n)
				This.ShrinkToNChars(n)
				return This

		def Shrink(n)
			if isList(n) and
			   ( Q(n).IsToOrToPositionNamedParam() or
			     Q(n).IsToNCharsNamedParam() )

				n = n[2]
			ok

			This.ShrinkTo(n)

			def ShrinkQ(n)
				This.Shrink(n)
				return This
		#>

	def ShrinkedTo(n)
		aResult = This.Copy().ShrinkToQ(n).Content()
		return aResult

		#< @FunctionAlternativeForms

		def ShrinkedToPosition(n)
			return This.ShrinkedTo(n)

		def ShrinkedToNChars(n)
			if NOT isNumber(n)
				StzRaise("Incorrect param type! n must be a number.")
			ok

			return Thus.ShrinkedToPosition(n)

		def Shrinked(n)
			return This.ShrinkedTo(n)

		#>

	  #===============================#
	 #     LOWERCASING THE STRING    #
	#===============================#

	def ApplyLowercase() # Understand it as a verb, an action on main string!
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toLower(This.String()) )

		#< @FunctionFluentForm

	 	// Transforms the string to lowercase AND Returns the lowercased
		// stzString object to take other actions on it!
		def ApplyLowercaseQ() # Q for Queue -> a chain of actions
			This.ApplyLowercase()
			return This

		#>

		#< @FunctionAlternativeForm

		def Lowercase() # Understand it as a verb that "lowercases" the string
			This.ApplyLowercase()

			def LowercaseQ()
				This.Lowercase()
				return This
	
		#>

		#< @FunctionMisspelledForm

		def Lowcase()
			This.ApplyLowercase()

		def ApplyLowcase()
			This.ApplyLowercase()

		#>

	def Lowercased()
		cResult = This.Copy().LowercaseQ().Content()
		return cResult

		def Lowcased()
			return This.Lowercased()

		def ToLowercase()
			return This.Lowercased()

	  #-------------------------------------------------#
	 #     LOWERCASING THE STRING IN A GIVEN LOCALE    #
	#-------------------------------------------------#

	// Tranforms the string to LOCALE-SENSITIVE lowercase
	def ApplyLowercaseInLocale(pcLocale)
		/*
		Apply the special cases documented in unicode here:
		--> http://unicode.org/Public/UNIDATA/SpecialCasing.txt

		*/

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToLowercase(This.String()) )

		#< @FunctionFluentForm

		def ApplyLowercaseInLocaleQ(pcLocale)
			This.ApplyLowercaseInLocale(pcLocale)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def LowercaseInLocale(pLocale) # Understand it as a verb that "lowercases" the string in the givan locale
			This.ApplyLowercaseInLocale(pLocale)

			def LowercaseInLocaleQ(pLocale)
				This.LowercaseInLocale(pLocale)
				return This
	
		#>

		#< @FunctionMisspelledForm

		def ApplyLowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)

		def LowcaseInLocale(pLocale)
			This.ApplyLowercaseInLocale(pLocale)
			
		#>

	def LowercasedInLocale(pcLocale)
		cResult = This.Copy().LowercaseInLocaleQ(pcLocale).Content()
		return cResult

		#< @FunctionFluentForm

		def LowercasedInLocaleQ(pLocale)
			return new stzString( This.LowercasedInLocale(pLocale) )

		#>

		#< @FunctionMisspelledForm

		def LowcasedInLocale(pcLocale)
			return This.LowercasedInLocale(pcLocale)

		#>

	  #----------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE  #
	#----------------------------------------#

	def IsLowercase()
	
		if This.Lowercased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsLowercased()
			return This.IsLowercase()

		def IsLower()
			return This.IsLowercase()

		def IsInLowercase()
			return This.IsLowercase()

		def IsInALowercase()
			return This.IsLowercase()

		#>

		#< @FunctionNegativeForm

		def IsNotLowercase()
			return NOT This.IsLowercase()

		def IsNotLowercased()
			return This.IsNotLowercase()

		def IsNotLower()
			return This.IsNotLowercase()

		def IsNotInLowercase()
			return This.IsNotLowercase()

		def IsNotInALowercase()
			return This.IsNotLowercase()

		#>

		#< @FunctionMisspelledForm

		def IsLowcased()
			return This.IsLowercase()

		def IsLowcase()
			return This.IsLowercase()

		#>

	  #----------------------------------------------------------#
	 #   CHECHINK IF THE STRING IS LOWERCASE IN A GIVEN LOCALE  #
	#----------------------------------------------------------#

	def IsLowercaseInLocale(pLocale)
		bResult = StzLocaleQ(pLocale).StringLowercased(This.String()) = This.String() # TODO: replace with DefaultLocale
		return bResult

		#< @FunctionAlternativeForms

		def IsLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsLowercasedIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInLowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		def IsInAlowercaseIn(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

		#< @FunctionMisspelledForm

		def IsLowcaseInLocale(pLocale)
			return This.IsLowercaseInLocale(pLocale)

		#>

	  #-------------------------------------------------------------#
	 #  CHECHINK IF THE STRING IS THE LOWERCASE OF A GIVEN STRING  #
	#-------------------------------------------------------------#

	def IsLowercaseOf(pcStr)
		return StzStringQ(pcStr).Lowercased() = This.String()

	def IsLowercaseOfXT(pcStr, paLocale)
		/* Example
		Q("many").IsLowercaseOfXT("MANY", :InThisLocale = "fr_FR")
		*/
	
		if NOT ( isList(paLocale) and len(paLocale) = 2 )
			stzRaise("Incorrect format!")
		ok
	
		if NOT isString(paLocale[1])
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( Q(paLocale[1]).IsOneOfThese([ :InThisLocale, :InLocale ]) )
			stzRaise("Incorrect format!")
		ok
	
		if NOT ( isString(paLocale[2]) or (isList([paLocale[2]]) and len(paLocale[2]) = 2) )
			stzRaise("Incorrect format!")
		ok
	
		if isString(paLocale[2]) and NOT StzStringQ(paLocale[2]).IsLocaleAbbreviation()
			stzRaise("Incorrect format!")
		ok
	
		if isList(paLocale[2]) and NOT StzListQ(paLocale[2]).IsLocaleList()
			stzRaise("Incorrect format!")
		ok
	
		return Q(pcStr).LowercasedInLocale(paLocale[2]) = This.String()

	  #===============================#
	 #     UPPERCASING THE STRING    #
	#===============================#

	def ApplyUppercase()
		oQLocale = new QLocale("C")
		This.Update( oQLocale.toUpper(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseQ()
			This.ApplyUppercase()
			return This
	
		#>

		#< @FunctionAlternativeForm	// TODO: replace with @FunctionAlternativeFormForm

		def Uppercase() # Understand it as a verb that "uppercases" the string
			This.ApplyUppercase()

			def UppercaseQ()
				This.Uppercase()
				return This
	
		#>

	def Uppercased()
		return This.Copy().UppercaseQ().Content()

		def ToUppercase()
			return This.Uppercased()

	// Tranforms the string to LOCALE-SENSITIVE UPPERCase
	def ApplyUppercaseInLocale(pcLocale)

		oLocale = new stzLocale(pcLocale)
		This.Update( oLocale.ToUpperCase(This.String()) )

		#< @FunctionFluentForm

		def ApplyUppercaseInLocaleQ(pcLocale)
			This.ApplyUppercaseInLocale(pcLocale)
			return This

		#>

		#< @FunctionAlternativeForms

		def UppercaseInLocale(pLocale) # Understand it as a verb that "uppercases" the string in the givan locale
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInLocaleQ(pLocale)
				This.ApplyUppercaseInLocale(pLocale)
				return This
	
		def LocaleUppercase(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def LocaleUppercaseQ(pLocale)
				This.LocaleUppercase(pLocale)
				return This

		def UppercaseIn(pLocale)
			This.ApplyUppercaseInLocale(pLocale)

			def UppercaseInQ(pLocale)
				This.UppercaseIn(pLocale)
				return This

		#>

	def UppercasedInLocale(pLocale)
		return This.Copy().UppercaseInLocaleQ(pLocale).Content()

		#< @FunctionAlternativeForms

		def LocaleUppercased(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercasedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		def toLocaleUppercase(pLocale)
			return This.UppercasedInLocale(pLocale)

		def UppercadedIn(pLocale)
			return This.UppercasedInLocale(pLocale)

		#>

	def IsUppercase()

		if This.Uppercased() = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsUppercased()
			return This.IsUppercase()

		def IsAnUppercase()
			return This.IsUppercase()

		def IsUpper()
			return This.IsUppercase()

		def IsInUppercase()
			return This.IsUppercased()

		def IsInAnUppercase()
			return This.IsUppercased()

		#>

	def IsUppercaseInLocale(pLocale)

		if This.UppercasedInLocale(pLocale) = This.String()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsUppercasedInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseInLocale(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#--

		def IsUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUppercasedIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsUpperIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		def IsInAnUppercaseIn(pLocale)
			return This.IsUppercaseInLocale(pLocale)

		#>

	def IsUppercaseOf(pcStr)
		return Q(pcStr).UppercaseQ().IsEqualTo(This.Content())

	def IsUppercaseOfInLocale(pcStr, pLocale)
		return This.UppercasedInLocale(pLocale) = pcStr

	  #---------------------------------------#
	 #  UPPERCASING A SECTION IN THE STRING  #
	#=======================================#

	def UppercaseSection(n1, n2)
		cUpper = This.SectionQ(n1, n2).Uppercased()
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionQ(n1, n2)
			This.UppercaseSection(n1, n2)
			return This

	def SectionUppercased(n1, n2)
		cResult = This.Copy().UppercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInUppercase(n1, n2)
			return This.SectionUppercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def UppercaseSectionInLocale(n1, n2, pLocale)
		cUpper = This.SectionQ(n1, n2).UppercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cUpper)

		def UppercaseSectionInLocaleQ(n1, n2, pLocale)
			This.UppercaseSection(n1, n2)
			return This

		def UppercaseSectionIn(n1, n2, pLocale)
			return This.UppercaseSectionInQ(n1, n2, pLocale)

			def UppercaseSectionInQ(n1, n2, pLocale)
				This.UppercaseSectionIn(n1, n2)
				return This

	def SectionUppercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().UppercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInUppercaseInLocale(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionUppercasedIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

		def SectionInUppercaseIn(n1, n2, pLocale)
			return This.SectionUppercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  UPPERCASING MANY SECTIONS IN THE STRING  # TODO: Check for performance!
	#-------------------------------------------#

	def UppercaseSections(anSections)
		if NOT (isList(anSections) and Q(anSections).IsListOfPairsOfNumbers())
			StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
		ok

		nLen = len(anSections)

		for i = 1 to nLen
			cUpper = This.SectionQ(anSections[i][1], anSections[i][2]).Uppercased()
			This.ReplaceSection(anSections[i][1], anSections[i][2], cUpper)
		next

		def UppercaseSectionsQ(anSections)
			This.UppercaseSections(anSections)
			return This

	def SectionsUppercased(anSections)
		cResult = This.Copy().UppercaseSectionsQ(anSections).Content()
		return cResult

		def SectionsInUppercase(anSections)
			return This.SectionsUppercased()

	#-- WITH LOCALE SENSITIVITY

	def UppercaseSectionsInLocale(anSections, pLocale)
		if NOT (isList(anSections) and Q(anSections).IsListOfPairsOfNumbers())
			StzRaise("Incorrect param type: anSections must be a list of pairs of numbers.")
		ok

		nLen = len(anSections)

		for i = 1 to nLen
			cUpper = This.SectionQ(anSections[i][1], anSections[i][2]).UppercasedInLocale(pLocale)
			This.UppercaseSection(anSections[i][1], anSections[i][2], cUpper)
		next

		def UppercaseSectionsInLocaleQ(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)
			return This

		def UppercaseSectionsIn(anSections, pLocale)
			This.UppercaseSectionsInLocale(anSections, pLocale)

			def UppercaseSectionsInQ(anSections, pLocale)
				This.UppercaseSectionsIn(anSections, pLocale)
				return This

	def SectionsUppercasedInLocale(anSections, pLocale)
		cResult = This.Copy().UppercaseSectionsInLocaleQ(anSections, pLocale).Content()
		return cResult

		def SectionsInUppercaseInLocale(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsUppercasedIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

		def SectionsInUppercaseIn(anSections, pLocale)
			return This.SectionsUppercasedInLocale(anSections, pLocale)

	  #---------------------------------------#
	 #  LOWERCASING A SECTION IN THE STRING  #
	#=======================================#

	def LowercaseSection(n1, n2)
		cLower = This.SectionQ(n1, n2).Lowercased()
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionQ(n1, n2)
			This.LowercaseSection(n1, n2)
			return This

	def SectionLowercased(n1, n2)
		cResult = This.Copy().LowercaseSectionQ(n1, n2).Content()
		return cResult

		def SectionInLowercase(n1, n2)
			return This.SectionLowercased(n1, n2)

	#-- WITH LOCALE SENSISITIVITY

	def LowercaseSectionInLocale(n1, n2, pLocale)
		cLower = This.SectionQ(n1, n2).LowercasedInLocale(pLocale)
		This.ReplaceSection(n1, n2, cLower)

		def LowercaseSectionInLocaleQ(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)
			return This

		def LowercaseSectionIn(n1, n2, pLocale)
			This.LowercaseSectionInLocale(n1, n2, pLocale)

			def LowercaseSectionInQ(n1, n2, pLocale)
				This.LowercaseSectionIn(n1, n2, pLocale)
				return This

	def SectionLowercasedInLocale(n1, n2, pLocale)
		cResult = This.Copy().LowercaseSectionInLocaleQ(n1, n2, pLocale).Content()
		return cResult

		def SectionInLowercaseInLocale(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionLowercasedIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

		def SectionInLowercaseIn(n1, n2, pLocale)
			return This.SectionLowercasedInLocale(n1, n2, pLocale)

	  #-------------------------------------------#
	 #  LOWERCASING MANY SECTIONS IN THE STRING  # TODO: Check for performance!
	#-------------------------------------------#

	def LowercaseSections(paSections)
		if NOT (isList(paSections) and Q(paSections).IsListOfPairsOfNumbers())
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)

		for i = 1 to nLen
			cLower = This.SectionQ(paSections[i][1], paSections[i][2]).Lowercased()
			This.ReplaceSection(paSections[i][1], paSections[i][2], cLower)
		next

		def LowercaseSectionsQ(paSections)
			This.LowercaseSections(paSections)
			return This

	def SectionsLowercased(paSections)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercase(paSections)
			return SectionsLowercased(paSections)

	#-- WITH LOCALE SENSITIVITY

	def LowercaseSectionsInLocale(paSections, pLocale)
		if NOT (isList(paSections) and Q(paSections).IsListOfPairsOfNumbers())
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)

		for i = 1 to nLen
			cLower = This.SectionQ(paSections[i][1], paSections[i][2]).LowercasedInLocale(pLocale)
			This.LowercaseSection(paSections[i][1], paSections[i][2], cLower)
		next

		def LowercaseSectionsInLocaleQ(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)
			return This

		def LowercaseSectionsIn(paSections, pLocale)
			This.LowercaseSectionsInLocale(paSections, pLocale)

			def LowercaseSectionsInQ(paSections, pLocale)
				This.LowercaseSectionsIn(paSections, pLocale)
				return This

	def SectionsLowercasedInLocale(paSections, pLocale)
		cResult = This.Copy().LowercaseSectionsQ(paSections).Content()
		return cResult

		def SectionsInLowercaseInLocale(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsLowercasedIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

		def SectionsInLowercaseIn(paSections, pLocale)
			return This.SectionsLowercasedInLocale(paSections, pLocale)

	  #-----------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def UppercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSections(aSections)

		def UppercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.UppercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

	def SubStringUppercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringToUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInUppercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringUppercasedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubString(pcSubStr)
		This.UppercaseSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def UppercaseSubStringQ(pcSubStr)
			This.UppercaseSubStringCSQ(pcSubStr, :CaseSensitive = TRUE)

	def SubStringUppercased(pcSubStr)
		cResult = This.Copy().UppercaseSubStringQ(pcStr).Content()
		return cResult

		def SubStringToUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

		def SubStringInUppercase(pcSubStr)
			return This.SubStringUppercased(pcSubStr)

	  #-----------------------------------------------------------#
	 #  UPPERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.UppercaseSectionsInLocale(aSections, pLocale)

		def UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		def UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def UppercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.UppercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

	def SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().UppercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		def SubStringToUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringUppercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInUppercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringUppercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UppercaseSubStringInLocale(pcSubStr, pLocale)
		This.UppercaseSubStringInLocaleCS(pcSubStr, pLocale, :CaseSensitive = TRUE)

		def UppercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.UppercaseSubStringInLocaleCSQ(pcSubStr, pLocale, :CaseSensitive = TRUE)

		def UppercaseSubStringIn(pcSubStr, pLocale)
			This.UppercaseSubStringInLocale(pcSubStr, pLocale)

			def UppercaseSubStringInQ(pcSubStr, pLocale)
				This.UppercaseSubStringIn(pcSubStr, pLocale)
				return This

	def SubStringUppercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().UppercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		def SubStringToUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseInLocale(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringToUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

		def SubStringInUppercaseIn(pcSubStr, pLocale)
			return This.SubStringUppercasedInLocale(pcSubStr, pLocale)

	  #-----------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING  #
	#=========================================#

	def LowercaseSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSections(aSections)

		def LowercaseSubStringCSQ(pcSubStr, pCaseSensitive)
			This.LowercaseSubStringCS(pcSubStr, pCaseSensitive)
			return This

	def SubStringLowercasedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStringCS(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringToLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

		def SubStringInLowercaseCS(pcSubStr, pCaseSensitive)
			return This.SubStringLowercasedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubString(pcSubStr)
		This.LowercaseSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def LowercaseSubStringQ(pcSubStr)
			This.LowercaseSubStringCSQ(pcSubStr, :CaseSensitive = TRUE)

	def SubStringLowercased(pcSubStr)
		cResult = This.Copy().LowercaseSubStringQ(pcStr).Content()
		return cResult

		def SubStringToLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

		def SubStringInLowercase(pcSubStr)
			return This.SubStringLowercased(pcSubStr)

	  #-----------------------------------------------------------#
	 #  LOWERCASING A SUBSTRING IN THE STRING IN A GIVEN LOCALE  #
	#-----------------------------------------------------------#

	def LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.LowercaseSectionsInLocale(aSections, pLocale)

		def LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocale(pcStr, pLocale, pCaseSensitive)
			return This

		def LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
			This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

			def LowercaseSubStringInCSQ(pcSubStr, pLocale, pCaseSensitive)
				This.LowercaseSubStringInCS(pcSubStr, pLocale, pCaseSensitive)
				return This

	def SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
		cResult = This.Copy().LowercaseSubStrinInLocalegCS(pcSubStr, pLocale, pCaseSensitive).Content()
		return cResult

		def SubStringToLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringLowercasedInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInLocaleCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

		def SubStringInLowercaseInCS(pcSubStr, pLocale, pCaseSensitive)
			return This.SubStringLowercasedInLocaleCS(pcSubStr, pLocale, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LowercaseSubStringInLocale(pcSubStr, pLocale)
		This.LowercaseSubStringInLocaleCS(pcSubStr, pLocale, :CaseSensitive = TRUE)

		def LowercaseSubStringInLocaleQ(pcSubStr, pLocale)
			This.LowercaseSubStringInLocaleCSQ(pcSubStr, pLocale, :CaseSensitive = TRUE)

		def LowercaseSubStringIn(pcSubStr, pLocale)
			This.LowercaseSubStringInLocale(pcSubStr, pLocale)

			def LowercaseSubStringInQ(pcSubStr, pLocale)
				This.LowercaseSubStringIn(pcSubStr, pLocale)
				return This

	def SubStringLowercasedInLocale(pcSubStr, pLocale)
		cResult = This.Copy().LowercaseSubStringInLocaleQ(pcStr, pLocale).Content()
		return cResult

		def SubStringToLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringLowercasedIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseInLocale(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

		def SubStringInLowercaseIn(pcSubStr, pLocale)
			return This.SubStringLowercasedInLocale(pcSubStr, pLocale)

	  #================================#
	 #     CAPITALIZING THE STRING    #
	#================================#

	def ApplyCapitalcase()
		if This.IsEmpty()
			return
		ok

		# Getting the positions of the words in the string
		# TODO: delegate the work to stzText when ready

		anPos = This.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]
		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 0, 1)

		ok

		nLen = len(anPos)

		for i = 1 to nLen
			cCapChar = This.CharARQ(anPos[i]).Uppercased()
			This.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		#< @FunctionFluentForm

		def ApplyCapitalcaseQ()
			This.ApplyCapitalcase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Capitalcase() # Understand it as a verb that "capitalcases" the string
			This.ApplyCapitalcase()

			def CapitalcaseQ()
				This.Capitalcase()
				return This

		def Capitalise()
			This.ApplyCapitalcase()

			def CapitaliseQ()
				This.Capitalise()
				return This

		def Capitalize()
			This.ApplyCapitalcase()

			def CapitalizeQ()
				This.Capitalize()
				return This

		#>	
	
	def CapitalCased()
		return This.Copy().ApplyCapitalCaseQ().Content()

		def CapitalCaseApplied()
			return This.CapitalCased()

		def Capitalised()
			return This.CapitalCased()

		def Capitalized()
			return This.CapitalCased()

		def ToCapitalCase()
			return This.CapitalCased()

		def InCapitalCase()
			return This.CapitalCased()

	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyCapitalCaseInLocale(pLocale)
		# Lowercasing all the string first

		oStr = This.Copy().LowercaseQ()

		# Getting the positions of the words in the string
		# TODO: delegate the work to stzText when ready

		anPos = oStr.FindAll(" ")
		if len(anPos) = 0
			anPos = [1]

		else
			anPos = StzListOfNumbersQ(anPos).AddedToEach(1)
			ring_insert(anPos, 1, 1)
			anPos = ring_sort(anPos)
		ok

		nLen = len(anPos)

		for i = 1 to nLen
			
			cCapChar = oStr.CharAtPositionQR(anPos[i], :stzString).
						UppercasedInLocale(pLocale)

			oStr.ReplaceCharAtPosition(anPos[i], cCapChar)
		next

		This.Update( oStr.Content() )

		#< @FunctionFluentForm

		def ApplyCapitalcaseInLocaleQ(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def CapitalcaseInLocale(pLocale) # Understand it as a verb that "capitalcases" the string in the givan locale
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInLocaleQ(pLocale)
				This.CapitalcaseInLocale(pLocale)
				return This

		def CapitaliseInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInLocaleQ(pLocale)
				This.CapitaliseInLocale(pLocale)
				return This

		def CapitalizeInLocale(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInLocaleQ(pLocale)
				This.CapitalizeInLocale(pLocale)
				return This
		#--

		def ApplyCapitalCaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def ApplyCapitalCaseInQ(pLocale)
				This.ApplyCapitalCaseIn(pLocale)
				return This

		def CapitalcaseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalcaseInQ(pLocale)
				This.CapitalcaseIn(pLocale)
				return This

		def CapitaliseIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitaliseInQ(pLocale)
				This.CapitaliseIn(pLocale)
				return This

		def CapitalizeIn(pLocale)
			This.ApplyCapitalCaseInLocale(pLocale)

			def CapitalizeInQ(pLocale)
				This.CapitalizeIn(pLocale)
				return This

		#>
		
	def CapitalCasedInLocale(pLocale)
		return This.Copy().CapitalCaseInLocaleQ(pLocale).Content()

		#< @FunctionFluentForm

		def CapitalcasedInLocaleQ()
			return new stzString( This.CapitalCasedInLocale() )

		#>

		#< @FunctionAlternativeForms

		def CapitalisedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def CapitalizedInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseInLocale(pLocale)
			return CapitalcasedInLocale(pLocale)

		def IsInCapitalcaseIn(pLocale)
			return CapitalcasedInLocale(pLocale)

		#>

	def IsCapitalcase()
		return This.CapitalCased() = This.String()
		
		#< @FunctionAlternativeForms

		def IsCapitalCased()
			return This.IsCapitalcase()

		def IsCapitalised()
			return This.IsCapitalcase()

		def IsCapitalized()
			return This.IsCapitalcase()

		def IsInCapitalcase()
			return This.IsCapitalcase()

		#>

	def IsCapitalcaseOf(pcStr)
		return This.Capitalcased() = pcStr

	def IsCapitalcaseOfInLocale(pcStr, pLocale)
		return This.CapitalcasedInLocale(pLocale) = pcStr

		def IsCapitalcaseOfIn(pcStr, pLocale)
			return This.IsCapitalcaseOfInLocale(pcStr, pLocale)

	  #=============================#
	 #   TITLECASING THE STRING    #
	#=============================#

	def ApplyTitlecase()
		oLocale = new stzLocale( "C" )
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseQ()
			This.ApplyTitlecase()
			return This		

		#>

		#< @FunctionAlternativeForms

		def Titlecase() # Understand it as a verb that "titlecases" the string
			This.ApplyTitleCase()

			def TitlecaseQ()
				This.Titlecase()
				return This

		def Titelise()
			This.ApplyTitleCase()

			def TiteliseQ()
				This.Titelise()
				return This

		def Titelize()
			This.ApplyTitleCase()

			def TitelizeQ()
				This.Titelize()
				return This
		#>	

	def TitleCased()
		return This.Copy().ApplyTitleCaseQ().Content()

		def Titelised()
			return This.TitleCased()
	
		def Titelized()
			return This.TitleCased()

		def InTitlecase()
			return This.TitleCased()
	
	// Tranforms the string to LOCALE-SENSITIVE titlecase
	def ApplyTitlecaseInLocale(pLocale)
		oLocale = new stzLocale(pLocale)
		This.Update( oLocale.ToTitlecase(This.String()) )

		#< @FunctionFluentForm

		def ApplyTitlecaseInLocaleQ(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def TitlecaseInLocale(pLocale) # Understand it as a verb that "titlecases" the string in the givan locale
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInLocaleQ(pLocale)
				This.TitlecaseInLocale(pLocale)
				return This
		
		def TiteliseInLocale(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInLocaleQ(pLocale)
				This.TiteliseInLocale(pLocale)
				return This

		def TitelizeInLocale(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInLocaleQ(pLocale)
				This.TitelizeInLocale(pLocale)
				return This

		#--

		def ApplyTitlecaseInLocaleIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def ApplyTitlecaseInLocaleInQ(pLocale)
				This.ApplyTitlecaseInLocaleIn(pLocale)
				return This

		def TitlecaseIn(pLocale)
			This.ApplyTitlecaseInLocale(pLocale)

			def TitlecaseInQ(pLocale)
				This.TitlecaseIn(pLocale)
				return This
		
		def TiteliseIn(pLocale)
			This.ApplyTitleCase(pLocale)

			def TiteliseInQ(pLocale)
				This.TiteliseIn(pLocale)
				return This

		def TitelizeIn(pLocale)
			This.ApplyTitleCaseInLocale(pLocale)

			def TitelizeInQ(pLocale)
				This.TitelizeIn(pLocale)
				return This

		#>
			
	def TitlecasedInLocale(pLocale)
		return This.Copy().TitleCaseInLocaleQ(pLocale).Content()

		def TitlecasedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedInLocale(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelisedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)

		def TitelizedIn(pLocale)
			return This.TitlecasedInLocale(pLocale)


	def IsTitlecase()
		
		return This.TitleCased() = This.String()

		#< @FunctionAlternativeForms

		def IsTitlecased()
			return This.IsTitlecase()

		def IsTitelised()
			return This.IsTitlecase()

		def IsTitelized()
			return This.IsTitlecase()

		def IsInTitlecase()
			return This.IsTitlecase()

		#>

	def IsTitlecaseOf(pcStr)
		return This.Titlecased() = pcStr

	  #================================#
	 #    CASEFOLDING THE STRING      #
	#================================#

	/*
	INFO
	----

	The casefold() method is an aggressive lower() method which
	converts strings to case folded strings for caseless matching.
	
	WARNING:
	--------

	Review the Qt behaviour regarding QString.toCaseFolded() method.

	In fact, when writing:

	? StzStringQ("der Flu").CaseFolded()

	We should have as result:

	"der fluss"

	since "" is casefolded to "ss" in german.

	But, Qt don't do that!
	
	*/

	// Transforms the string to casefolded style
	def CaseFold() # Understand it as a verb that "casefolds" the string
		This.Update( This.CaseFolded() )

		#< @FunctionFluentForm

		def CaseFoldQ()
			This.CaseFold()
			return This
	
		#>

	def CaseFolded()
		return @oQString.toCasefolded()

	def IsCaseFolded()
		If This.IsEmpty()
			return FALSE
		ok

		if This.Copy().CaseFolded() = This.Content()
			return TRUE
		else
			return FALSE
		ok

		return bResult

		#< @FunctionAlternativeForm

		def IsCaseFold()
			return This.IsCaseFolded()

		#>

	def IsCaseFoldedOf(pcStr)
		return This.CaseFolded() = pcStr

	  #================================#
	 #   CHECKING IF STRING IS WORD   #
	#================================#
	# TODO: should move to stzText

	def IsWord()

		if This.IsEmpty() or This.IsNumberInString()
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsNotLetter() and
			   oChar.IsNotNumber() and
			   c != HyphenShort() and
			   c != HyphenLong() and
			   c != Underscore() and
			   oChar.IsNotArabic7arakah() and
			   c != ArabicTamdeed()

				bResult = FALSE
				exit
			ok

		next

		return bResult

	def IsArabicWord()
		bResult = This.ToStzText().IsArabicWord()
		return bResult

	def IsLatinWord()
		bResult = This.ToStzText().IsLatinWord()
		return bResult

	  #-------------------------------------#
	 #   CHECKING IF STRING IS STOPWORD    #
	#-------------------------------------#
	# TODO: Should move to stzText

	def IsStopWord()
		return StopWordsQ().Contains(This.Lowercased())

	def IsStopWordIn(pcLang)
		bResult = This.ToStzText().IsStopWordIn(pcLang)
		return bResult

	def LanguageIfStopWord()
		cResult = This.ToStzText().LanguageIfStopWord()
		return cResult

	  #===================================================#
	 #  NUMBER OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#===================================================#

	def NumberOfSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return 0
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = 0

		if pCaseSensitive = TRUE
			n = This.NumberOfChars()
			nResult = n * (n + 1) / 2
	
		else
			# TODO (Future): Think of a numeric solution
			acSubStringsCS = This.SubStringsCS(FALSE)
			nResult = len(acSubStringsCS)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def HowManySubstringsCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		def HowManySubstringCS(pCaseSensitive)
			return This.NumberOfSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStrings()
		return This.NumberOfSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HowManySubstrings()
			return This.NumberOfSubStrings()

		def HowManySubstring()
			return This.NumberOfSubStrings()

		#>
	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL POSSIBLE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------------------------#

	def SubStringsCS(pCaseSensitive)
		# NOTE: Got help from Google Bard for the basic algorithm used here

		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []
		nLen = This.NumberOfChars()
		# TODO: Chexk wether ..CS() extension is needed here!

		for i = 1 to nLen
			for j = i to nLen
				cSubStr = This.Section(i, j)
				if pCaseSensitive = TRUE
					acResult + cSubStr

				else
					# TODO: Optimise it for better performance
					if NOT Q(acResult).ContainsCS(cSubStr, FALSE)
						acResult + cSubStr
					ok
				ok
			next
		next
		
		 return acResult


		#< @FunctionFluentForm

		def SubStringsCSQ(pCaseSensitive)
			return This.SubStringsCSQR(pCaseSensitive, :stzList)

		def SubStringsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @AlternativeFuntionForm

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStrings()
		return This.SubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubStringsQ()
			return This.SubStringsQR(:stzList)

		def SubStringsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStrings() )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStrings() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------#
	 #  LIST OF UNIQUE SUBSTRINGS IN THE STRING  #
	#-------------------------------------------#

	def UniqueSubStringsCS(pCaseSensitive)
		acResult = This.SubStringsCSQR(pCaseSensitive, :stzListOfStrings).
				DuplicatesRemoved()

		return acResult

		def SubStringsUCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

		def SubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStrings()
		return This.UniqueSubStringsCS(:CaseSensitive = TRUE)

		def SubStringsU()
			return This.UniqueSubStrings()

		def SubStringsWithoutDuplication()
			return This.UniqueSubStrings()

	  #---------------------------------------------#
	 #  NUMBER OF UNIQUE SUBSTRINGS IN THE STRING  #
	#---------------------------------------------#

	def NumberOfUniqueSubStringsCS(pCaseSensitive)
		return len( This.UniqueSubStringsCS(pCaseSensitive) )

		#< @FunctionAlternativeForms

		def NumberOfSubStringsUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringsCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManyUniqueSubstringCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringUCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#--

		def NumberOfSubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		def HowManySubStringsWithoutDuplicationCS(pCaseSensitive)
			return This.NumberOfUniqueSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStrings()
		return This.NumberOfUniqueSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfSubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstrings()
			return This.NumberOfUniqueSubStrings()

		def HowManyUniqueSubstring()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsU()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringU()
			return This.NumberOfUniqueSubStrings()

		#--

		def NumberOfSubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		def HowManySubStringsWithoutDuplication()
			return This.NumberOfUniqueSubStrings()

		#>

	  #----------------------------------------------------------#
	 #  POSITIONS OF ALL THE POSSIBLE SUBSTRINGS IN THE STRING  #
	#----------------------------------------------------------#

	def FindSubStringsCS(pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		nLen = len(acSubStrings)
		anResult = []

		for i = 1 to nLen
			anResult + This.FindSubStringCS( acSubStrings[i], pCaseSensitive )
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def FindAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfAllSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		def SubStringsPositionsCS(pCaseSensitive)
			return This.FindSubStringsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStrings(pCaseSensitive)
		return This.FindSubStringsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStrings()
			return This.FindSubStrings()

		def FindAllPossibleSubStrings()
			return This.FindSubStrings()

		def PositionsOfSubStrings()
			return This.FindSubStrings()

		def PositionsOfAllSubStrings()
			return This.FindSubStrings()

		def PositionsOfAllPossibleSubStrings()
			return This.FindSubStrings()

		def SubStringsPositions()
			return This.FindSubStrings()

		#>

	   #----------------------------------------------------------#
	  #   FINDING ALL THE POSSIBLE SUBSTRINGS IN THE STRING AND  #
	 #   RETURNING THEIR POSITIONS AS SECTTIONS                 #
	#----------------------------------------------------------#

	def FindSubStringsAsSectionsCS(pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		nLen = len(acSubStrings)
		aResult = []

		for i = 1 to nLen
			aResult + This.FindSubStringAsSectionCS( acSubStrings[i], pCaseSensitive )
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindAllSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def FindAllPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def PositionsOfSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def PositionsOfAllSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def PositionsOfAllPossibleSubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#--

		def SubStringsAsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		def SubStringsSectionsCS(pCaseSensitive)
			return This.FindSubStringsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsAsSections(pCaseSensitive)
		return This.FindSubStringsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindAllSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def FindAllPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def PositionsOfSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def PositionsOfAllSubStringsAsSections()
			return This.FindSubStringsAsSections()

		def PositionsOfAllPossibleSubStringsAsSections()
			return This.FindSubStringsAsSections()

		#--

		def SubStringsAsSections()
			return This.FindSubStringsAsSections()

		def SubStringsSections()
			return This.FindSubStringsAsSections()

		#>

	  #-----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR POSITIONS  #
	#-----------------------------------------------#

	def SubStringsCSZ(pCaseSensitive)
	
		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		aResult = []

		for i = 1 to len(acSubStrings)
			cSubStr = acSubStrings[i]
			anPos = This.FindAllCS(cSubStr, pCaseSensitive)
			aResult + [ cSubStr, anPos ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.SubStringsCSZ(pCaseSensitive)

		def AllSubStringsAndTheirPositionsCS(pCaseSensitive)
			return This.SubStringsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsZ()
		return This.SubStringsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsAndTheirPositions()
			return This.SubStringsZ()

		def AllSubStringsAndTheirPositions()
			return This.SubStringsZ()

		#>

	  #----------------------------------------------#
	 #  ALL POSSIBLE SUBSTRINGS AND THEIR SECTIONS  #
	#----------------------------------------------#

	def SubStringsCSZZ(pCaseSensitive)
		acSubStrings = This.UniqueSubStringsCS(pCaseSensitive)
		aResult = []

		for i = 1 to len(acSubStrings)
			cSubStr = acSubStrings[i]
			aSection = This.FindAsSectionsCS(cSubStr, pCaseSensitive)
			aResult + [ cSubStr, aSection ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def SubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.SubStringsCSZZ(pCaseSensitive)

		def AllSubStringsAndTheirSectionsCS(pCaseSensitive)
			return This.SubStringsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsZZ()
		return This.SubStringsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsAndTheirSections()
			return This.SubStringsZZ()

		def AllSubStringsAndTheirSections()
			return This.SubStringsZZ()

		#>

	  #------------------------------------------#
	 #  SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------#

	def NumberOfSubStringsW(pcCondition)
		return len( This.SubStringsW(pcCondition) )

	def SubStringsW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		acSubStr = This.SubStringsU() # Or UniqueSubStrings()

		nLen = len(acSubStr)

		cCode = 'if (' + StzCCodeQ(pcCondition).Transpiled() + ') { bOk = TRUE }'

		aResult = []
		
		for i = 1 to nLen
			@substring = acSubStr[i]
			bOk = FALSE
			eval(cCode)

			if bOk
				aResult + @substring
			ok
		next

		return aResult

	  #------------------------------------------------------#
	 #  GETTING THE LIST OF ALL SUBSTRINGS MADE OF N CHARS  #
	#------------------------------------------------------#

	def SubStringsOfNCharsCS(n, pCaseSensitive)
		acResult = This.SubStringsW(' Q(@SubStr).NumberOfCharsCS(pCaseSensitive) = n ')
		return acResult

		def SubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.SubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsOfNChars(n)
		return This.SubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def SubStringsMadeOfNChars(n)
			return This.SubStringsOfNChars(n)

	  #-------------------------------------------------------------#
	 #  GETTING THE LIST OF ALL UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-------------------------------------------------------------#

	def UniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		acSubStrings = This.SubStringsOfNCharsCS(n, pCaseSensitive)
		acResult = Q(acSubStrings).DuplicatesRemovedCS(pCaseSensitive)
		return acResult

		def UniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

		def SubStringsWithoutDuplicationMadeOfNCharsCS(n, pCaseSensitive)
			return This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESITIVITY

	def UniqueSubStringsOfNChars(n)
		return This.UniqueSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def UniqueSubStringsMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

		def SubStringsWithoutDuplicationMadeOfNChars(n)
			return This.UniqueSubStringsOfNChars(n)

	  #----------------------------------------------------#
	 #  GETTING THE NUMBER OF SUBSTRINGS MADE OF N CHARS  #
	#----------------------------------------------------#

	def NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.SubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfSubStringsOfNCharsCS(n, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsOfNChars(n)
		return This.NumberOfSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def NumberOfSubStringsMadeOfNChars(n)
			return This.NumberOfSubStringsOfNChars(n)

	  #-----------------------------------------------------------#
	 #  GETTING THE NUMBER OF UNIQUE SUBSTRINGS MADE OF N CHARS  #
	#-----------------------------------------------------------#

	def NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
		return len( This.UniqueSubStringsOfNCharsCS(n, pCaseSensitive) )

		def NumberOfUniqueSubStringsMadeOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
	
		def HowManyUniqueSubStringsOfNCharsCS(n, pCaseSensitive)
			return This.NumberOfUniqueSubStringsOfNCharsCS(n, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfUniqueSubStringsOfNChars(n)
		return This.NumberOfUniqueSubStringsOfNCharsCS(n, :CaseSensitive = TRUE)

		def NumberOfUniqueSubStringsMadeOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

		def HowManyUniqueSubStringsOfNChars(n)
			return This.NumberOfUniqueSubStringsOfNChars(n)

	  #=================#
	 #      LINES      #
	#=================#

	def Lines()
		return This.Split(NL)

		#< @FunctionFluentForm

		def LinesQ()
			return new stzListOfStrings( This.Lines() )

		def LinesQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.Lines())

			on :stzListOfStrings
				return new stzListOfStrings(This.Lines())

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
	def NumberOfLines()
		return len(This.Lines())

	  #----------------#
	 #  UNIQUE LINES  #
	#----------------#

	def UniqueLines()
		acResult = This.LinesQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForm

		def UniqueLinesQ()
			return new stzListOfStrings( This.UniqueLines() )

		def UniqueLinesQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueLines())

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueLines())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LinesU()
			return This.UniqueLines()

			def LinesUQ()
				return This.LinesQR(:stzList)

			def LinesUQR(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		def LinesWithoutDuplication()
			return This.UniqueLines()

			def LinesWithoutDuplicationQ()
				return This.LinesWithoutDuplicationQR(:stzList)

			def LinesWithoutDuplicationQR(pcReturnType)
				return This.UniqueLinesQR(pcReturnType)

		#>

	  #------------------------------------------#
	 #  REMOVING LINES UNDER A GIVEN CONDITION  #
	#------------------------------------------#

	def RemoveLinesW(pcCondition)
		/* EXAMPLE

		o1 = new stzString("

		ABCDEF
		GHIJKL
		123346
		MNOPQU
		RSTUVW
		984332

		")

		o1.RemoveLinesW(' Q(@line).IsMadeOfNumbers() ')
		? o1.Content()

		#--> "

		ABCDEF
		GHIJKL
		MNOPQU
		RSTUVW

		"
		*/

		oListOfStr = This.LinesQR(:stzListOfStrings)

		pcCondition = Q(pcCondition).
			      ReplaceCSQ("@line", "This[@i]", :CS = FALSE).
			      Content()

		cResult = oListOfStr.RemoveWQ(pcCondition).ConcatenatedUsing(NL)

		This.Update(cResult)

		def RemoveLinesWQ(pcCondition)
			This.RemoveLinesW(pcCondition)
			return This

	  #------------------------#
	 #  REMOVING EMPTY LINES  #
	#------------------------#

	def RemoveEmptyLines()
		cResult = This.LinesQR(:stzListOfStrings).
				RemoveEmptyStringsQ().
				ConcatenatedUsing(NL)

		This.Update(cResult)

		def RemoveEmptyLinesQ()
			This.RemoveEmptyLines()
			return This

	  #========================#
	 #  NORMALIZING MARQUERS  #
	#========================#
	// Removing zeros at the begining of marquer numbers

	def NormalizeMarquers()
		/* Example

		StzStringQ("The first candidate is #003, the second is #01, while the third is #2!") {	
			NormalizeMarquers()
			? Content()
		}

		#--> "The first candidate is #3, the second is #1, while the third is #2!"
		*/
		if This.Contains("#0")

			bContinue = TRUE
	
			While bContinue
	
				n = This.ReplaceLast("#0", "#")
	
				if This.ContainsNo("#0")
					bContinue = FALSE
				ok
			end
		ok

		def NormaliseMarquers()
			This.NormaliseMarquers()

	  #--------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MARQUERS  #
	#============================================#

	def ContainsMarquers()
		if This.NumberOfMarquers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #----------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING  #
	#==============================================#

	def Marquers()
		anPos = This.FindAll("#")

		if len(anPos) = 0
			return []
		ok

		aResult = []

		for n in anPos
			n1 = n + 1
			n2 = This.WalkForewardW( :StartingAt = n+1, :Until = '{ NOT StzStringQ(@char).RepresentsNumberInDecimalForm() }' )

			if n1 != n2

				cMarquer = This.SectionQ(n1, n2).OnlyNumbersQ().RemoveThisRepeatedLeadingCharQ("0").Content()

				if cMarquer != ""
					if cMarquer[1] = "0"
						cMarquer = StzStringQ(cMarquer).Section(2, :LastChar)
					ok
				
					aResult + ("#" + cMarquer)
				ok
			ok
			
		next

		return aResult

		def MarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.Marquers())

			on :stzList
				return new stzList(This.Marquers())

			other
				stzRaise("Unsupported return type!")
			off

	  #---------------------------------------------------------------------#
	 #  GETTING THE LIST OF MARQUERS IN THE STRING -- WITHOUT DUPLICATION  #
	#=====================================================================#

	def UniqueMarquers()
		return StzListQ(This.Marquers()).UniqueItems()

		#< @FunctionFluentForms

		def UniqueMarquersQ()
			return This.UniqueMarquersQR(:stzList)

		def UniqueMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueMarquers())

			on :stzList
				return new stzList(This.UniqueMarquers())

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SetOfMarquers()
			return This.UniqueMarquers()

			def SetOfMarquersQ()
				return This.UniqueMarquersQ()

			def SetOfMarquersQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersU()
			return This.UniqueMarquers()

			def MarquersUQ()
				return This.UniqueMarquersQ()

			def MarquersUQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		def MarquersWithoutDuplication()
			return This.UniqueMarquers()

			def MarquersWithoutDuplicationQ()
				return This.UniqueMarquersQ()

			def MarquersWithoutDuplicationQR(pcReturnType)
				return This.UniqueMarquersQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #  GETTING THE NUMBER OF MARQUERS IN THE STRING  #
	#================================================#

	def NumberOfMarquers()
		return len(This.Marquers())

		def CountMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquers()
			return This.NumberOfMarquers()

		def HowManyMarquer()
			return This.NumberOfMarquers()

	  #-------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS IN EACH MARQUER IN THE STRING  #
	#=============================================================#

	def NumberOfCharsInEachMarquer()
		aResult = []
		for cMarquer in This.Marquers()
			aResult + len(cMarquer)
		next

		return aResult

		#< @FunctionAlternativeForms

		def SizeOfEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def MarquersNumbersOfChars()
			return This.NumberOfCharsInEachMarquer()

		def CountCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharsInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		def HowManyCharInEachMarquer()
			return This.NumberOfCharsInEachMarquer()

		#>

	  #-------------------------------#
	 #   MFINDING ARQUERS POSITIONS  #
	#===============================#

	def MarquersPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersPositions()
			#--> [ 12, 25, 44, 66 ]
		
		}
		*/

		acMarquers = This.Marquers()
		aResult = []

		n = 1

		for cMarquer in acMarquers
			n = This.FindNextOccurrence( cMarquer, n )
			/* WARNING: Don't use:
			n = This.FindNextMarquer(cMarquer)
			--> Circular call --> Stackoverflow
			*/
			aResult + n
		next

		return aResult

		#< @FunctionFluentForm

		def MarquersPositionsQ()
			return This.MarquersPositionsQR(:stzListOfNumbers)

		def MarquersPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzListOfNumbers
				return new stzListOfNumbers(This.MarquersPositions())

			on :stzList
				return new stzList(This.MarquersPositions())

			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def MarquersOccurrences()
			return This.MarquersPositions()

			def MarquersOccurrencesQ()
				return This.MarquersOccurrencesQR(:stzListOfNumbers)
	
			def MarquersOccurrencesQR(pcReturnType)
				return This.MarquersPositionsQR(pcReturnType)

		def FindMarquers()
			return This.MarquersPositions()

			def FindMarquersQ()
				return This.FindMarquersQR(:stzListOfNumbers)
	
			def FindMarquersQR(pcReturnType)
				return This.MarquersPositionsQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#================================================#

	def MarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersAndPositions() " Use MarquersZ() instead
			#--> [ "#1" = 12, "#2" = 25 , "#3" = 44, "#1" = 66 ]
		
		}
		*/

		aResult = StzPairOfListsQ( This.Marquers(), This.MarquersPositions() ).AssociateQ().Content()
		return aResult

		#< @FunctionFluentForm

		def MarquersAndPositionsQ()
			return This.MarquersAndPositionsQR(:stzList)

		def MarquersAndPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndPositions() )

			on :stzHashList
				return new stzHashList( This.MarquersAndPositions() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def MarquersAndTheirPositions()
			return This.MarquersAndPositions()

			def MarquersAndTheirPositionsQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndTheirPositionsQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersAndOccurrences()
			return This.MarquersAndPositions()

			def MarquersAndOccurrencesQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndOccurrencesQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersAndTheirOccurrences()
			return This.MarquersAndPositions()

			def MarquersAndTheirOccurrencesQ()
				return This.MarquersAndPositionsQ()

			def MarquersAndTheirOccurrencesQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturnType)

		def MarquersZ()
			return This.MarquersAndPositions()

			def MarquersZQ()
				return This.MarquersAndPositionsQR(:stzList)

			def MarquersZQR(pcReturnType)
				return This.MarquersAndPositionsQR(pcReturntype)

		#>

	  #-------------------------------------------------------#
	 #   UNIQUE MARQUERS AND THEIR POSITIONS -- Z/Extension  #
	#=======================================================#

	def UniqueMarquersAndPositions()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? UniqueMarquersAndPositions() # Use MarquersUZ() instead
			#--> [ "#1" = [12, 66], "#2" = [26], "#3" = [44] ]
		
		}
		*/
		acMarquers = This.UniqueMarquers()
		nLen = len(acMarquers)

		aResult = []

		for i = 1 to nLen
			anPos = This.FindAll(acMarquers[i])
			aResult + [ cMarquer, anPos ]
		next

		return aResult
		
		#< @FunctionFluentForm

		def UniqueMarquersAndPositionsQ()
			return This.UniqueMarquersAndPositionsQR(:stzList)

		def UniqueMarquersAndPositionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueMarquersAndPositions() )

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndPositions() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def UniqueMarquersAndTheirPositions()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndTheirPositionsQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndTheirPositionsQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersAndOccurrences()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndOccurrencesQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndOccurrencesQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersAndTheirOccurrences()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersAndTheirOccurrencesQ()
				return This.UniqueMarquersAndPositionsQ()

			def UniqueMarquersAndTheirOccurrencesQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturnType)

		def UniqueMarquersZ()
			return This.UniqueMarquersAndPositions()

			def UniqueMarquersZQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def UniqueMarquersZQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersZU()
			return This.UniqueMarquersAndPositions()

			def MarquersZUQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def MarquersZUQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersUZ()
			return This.UniqueMarquersAndPositions()

			def MarquersUZQ()
				return This.UniqueMarquersAndPositionsQR(:stzList)

			def MarquersUZQR(pcReturnType)
				return This.UniqueMarquersAndPositionsQR(pcReturntype)

		def MarquersWithoutDuplicationZ()
			return This.UniqueMarquersAndPositions()

			def MarquersWithoutDuplicationZQ()
				return This.MarquersWithoutDuplicationQR(:stzList)

			def MarquersWithoutDuplicationZQR(pcReturnType)
				return This.MarquersUZQR(pcReturnType)

		#>

	  #----------------------------#
	 #      FINDING A MARQUER     #
	#============================#

	def OccurrencesOfMarquer(pcMarquer)
		
		aResult = This.MarquersAndTheirPositions()[pcMarquer]
		if isString(aResult) and aResult = NULL
			return []
		else
			return aResult
		ok

		#< @FunctionFluentForm

		def OccurrencesOfMarquerQ(pcMarquer)
			return This.OccurrencesOfMarquerQR(pcMarquer, :stzList)

		def OccurrencesOfMarquerQR(pcMarquer, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.OccurrencesOfMarquer(pcMArquer) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.OccurrencesOfMarquer(pcMArquer) )

			other
				stzRaise("Unsupported return type!")

			off
		#>

		#< @FunctionAlternativeForms

		def PositionsOfMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def PositionsOfMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def PositionsOfMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def MarquerPositions(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def MarquerPositionsQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def MarquerPositionsQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)

		def FindMarquer(pcMarquer)
			return This.OccurrencesOfMarquer(pcMarquer)

			def FindMarquerQ(pcMarquer)
				return This.OccurrencesOfMarquerQ(pcMarquer)
	
			def FindMarquerQR(pcMarquer, pcReturnType)
				return This.OccurrencesOfMarquerQR(pcMarquer, pcReturnType)


			#>

	  #-------------------------------------#
	 #    GETTING A MARQUER BY POSITION    #
	#=====================================#

	def MarquerByPosition(pnPosition)
		aMarquers = This.MarquersAndTheirPositions()
		nLen = len(aMarquers)

		cResult = ""

		for i = 1 to nLen
			n = ring_find(aMarquers[2], pnPosition)
			if n > 0
				cResult = aMarquers[1]
				exit
			ok
		next

		return cResult

		def MarquerByPositionQ(pnPosition)
			return new stzString( This.MarquerByPosition() )

		def MarquerByOccurrence(pnPosition)
			return This.MarquerByPosition(pnPosition)

			def MarquerByOccurrenceQ(pnPosition)
				return new stzString( This.MarquerByOccurrence(pnPosition) )

	  #----------------------------------#
	 #   FINDING MARQUERS AS SECTIONS   #
	#==================================#

	def MarquersSections()
		/* Example:

		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
		
			? MarquersPositions()
			#--> [  [12, 13], [ 25, 26],  [44, 45], [66, 67]  ]
		
		}
		*/

		anStartPos  = This.MarquersPositions()
		anNbOfChars = This.MarquersNumbersOfChars()

		aResult = []

		for i = 1 to len(anStartPos)
			aResult + [ anStartPos[i], anStartPos[i] + anNbOfChars[i] - 1 ]
		next

		return aResult


		#< @FunctionFluentForm

		def MarquersSectionsQ()
			return new stzList( This.MarquersSections() )

		def MarquersSectionsQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersSections() )

			on :stzListOfLists
				return new stzListOfLists( This.MarquersSections() )

			on :stzListOfPairs
				return new stzListOfPairs( This.MarquersSections() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm >

		def FindMarquersAsSections()
			return This.MarquersSections()

			def FindMarquersAsSectionsQ()
				return This.MarquersSectionsQ()

			def FindMarquersAsSectionsQR(pcReturnType)
				return This.MarquersSectionsQR(pcReturnType)

		#>

	  #------------------------------------------------#
	 #   MARQUERS AND THEIR SECTIONS -- ZZ/Extended   #
	#================================================#

	def MarquersAndSections()

		aResult = Association([ This.Marquers(), This.MarquersSections() ])
		return aResult

		#< @FunctionFluentForm

		def MarquersAndSectionsQ()
			return This.MarquersAndSectionsQR(:stzList)

		def MarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.MarquersAndSections() )

			on :stzHashList
				return new stzHashList( This.MarquersAndSections() )

			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZ()
			return This.MarquersAndSections()

			def MarquersZZQ()
				return This.MarquersAndSectionsQ()

			def MarquersZZQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		def MarquersAndTheirSections()
			return This.MarquersAndSections()

			def MarquersAndTheirSectionsQ()
				return This.MarquersAndSectionsQ()

			def MarquersAndTheirSectionsQR(pcReturnType)
				return This.MarquersAndSectionsQR(pcReturnType)

		#>

	  #-------------------------------------------------------#
	 #  UNIQUE MARQUERS AND THEIR SECTIONS -- ZZU/Extended   #
	#=======================================================#

	def UniqueMarquersAndSections()

		aMarquers = This.MarquersAndTheirPositions()
		nLen = len(aMarquers)

		aResult = []

		for i = 1 to nLen
			cMarquer = aMarquers[i][1]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			anMarquerPositions = aMarquers[i][2]
			nNumberOfPos = len(anMarquerPositions)

			aMarquerSections = []

			for j = 1 to nNumberOfPos
				nPos = anMarquerPositions[j]
				aMarquerSections + [ nPos, nPos + nLenMarquer - 1 ]
			next

			aResult + [ cMarquer, aMarquerSections ]
		next
		
		return aResult

		#< @FunctionFluentForm

		def UniqueMarquersAndSectionsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType

			on :stzHashList
				return new stzHashList( This.UniqueMarquersAndSections() )

			on :stzList
				return new stzList( This.UniqueMarquersAndSections() )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def MarquersZZU()
			return This.UniqueMarquersAndSections()

			def MarquersZZUQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersZZUQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUZZ()
			return This.UniqueMarquersAndSections()

			def MarquersUZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def UniqueMarquersAndTheirSections()
			return This.UniqueMarquersAndSections()

			def UniqueMarquersAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def UniqueMarquersandTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersUAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersUAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersUAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationAndTheirSections()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationAndTheirSectionsQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationAndTheirSectionsQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		def MarquersWithoutDuplicationZZ()
			return This.UniqueMarquersAndSections()

			def MarquersWithoutDuplicationZZQ()
				return This.UniqueMarquersAndSectionsQ()

			def MarquersWithoutDuplicationZZQR(pcReturnType)
				return This.UniqueMarquersAndSectionsQR(pcReturnType)

		#>
	
	  #-----------------------------------------#
	 #    SORTING MARQUERS INSIDE THE STRING   #
	#=========================================#

	def MarquersAreSorted()
		bResult = StzListQ(This.Marquers()).ItemsAreSorted()
		return bResult

	def MarquersSortingOrder()
		bResult = StzListQ(This.Marquers()).SortingOrder()
		return bResult

	def MarquersAreUnsorted()
		bResult = StzListQ(This.Marquers()).ItemsAreUnsorted()
		return bResult

		def MarquersAreNotSorted()
			return This.MarquersAreUnsorted()

	def MarquersAreSortedInAscending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInAscending()
		return bResult

	def MarquersAreSortedInDescending()
		bResult = StzListQ(This.Marquers()).ItemsAreSortedInDescending()
		return bResult

	def MarquersSortedInAscending()
		aResult = StzListQ(This.Marquers()).SortedInAscending()
		return aResult

	def MarquersSortedInDescending()
		aResult = StzListQ(This.Marquers()).SortedInDescending()
		return aResult

	def MarquersPositionsSortedInAscending()
		aResult = StzListQ(This.MarquersPositions()).SortedInAscending()
		return aResult

	def MarquersPositionsSortedInDescending()
		aResult = StzListQ(This.MarquersPositions()).SortedInDescending()
		return aResult

	def MarquersAndPositionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = StzPairOfListsQ( acMarquers, anPositions).Associate()

		return aResult

		def MarquersSortedInAscendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInAscending()

		def MarquersAndTheirPositionsSortedOInDescending()
			return This.MarquersAndPositionsSortedInAscending()

	def MarquersAndPositionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		anPositions = This.MarquersPositionsSortedInDescending()

		aResult = StzPairOfListsQ( acMarquers, anPositions ).Associate()

		return aResult

		def MarquersSortedInDescendingAndTheirPositions()
			return This.MarquersAndPositionsSortedInDescending()

		def MarquersAndTheirPositionsSortedInDescending()
			return This.MarquersAndPositionsSortedInDescending()

	def MarquersAndSectionsSortedInAscending()
		acMarquers  = This.MarquersSortedInAscending()
		nLen = len(acMarquers)

		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLen
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPositions[i]
			n2 = n1 + nLenMarquer - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		def MarquersSortedInAscendingAndTheirSections()
			return This.MarquersAndSectionsSortedInAscending()

	def MarquersAndSectionsSortedInDescending()
		acMarquers  = This.MarquersSortedInDescending()
		nLenMarquers = len(acMarquers)

		anPositions = This.MarquersPositionsSortedInAscending()

		aResult = []
		i = 0

		for i = 1 to nLenMarquers
			cMarquer = acMarquers[i]
			nLenMarquer = Q(cMarquer).NumberOfChars()

			n1 = anPositions[i]
			n2 = n1 + nLenMarquers - 1
		
			aResult + [ cMarquer, [ n1, n2 ] ]
		next

		return aResult

		def MarquersSortedInDescendingAndTheirSections()
			return This.MarquersAndSectionsSortedInDescending()

	def SortMarquersInAscending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInAscending()
			? Content()
		}

		# !--> My name is #1, may age is #2, and my job is #3.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		/* Reminder
		#--> [ "#1" = [12, 13], "#1" = [26, 27], "#2" = [44, 45], "#3" = [66, 67] ]
		*/

		for i = len(aMarquersSections) to 1 step -1
			cMarquer = aMarquersSections[i][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInAscendingQ()
			This.SortMarquersInAscending()
			return This

	def StringWithMaquersSortedInAscending()
		cResult = This.Copy().SortMarquersInAscendingQ().Content()
		return cResult

	def SortMarquersInDescending()
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example

		Q("My name is #2, may age is #1, and my job is #3.") {
			SortMarquersInDescending()
			? Content()
		}

		# !--> My name is #3, may age is #2, and my job is #1.
		*/

		aMarquersSections = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersSections)

		/* Reminder
		Q("My name is #2, may age is #1, and my job is #3.") {
			? MarquersAndSections()
		}

		#--> [ "#1" = [12, 13], "#2" = [27, 28], "#3" = [45, 46]  ]
		*/

		for i = nLen to 1 step - 1
			cMarquer = aMarquersSections[nLen - i + 1][1]
			n1 = aMarquersSections[i][2][1]
			n2 = aMarquersSections[i][2][2]

			This.ReplaceSection(n1, n2, cMarquer)
		next

		def SortMarquersInDescendingQ()
			This.SortMarquersInDescending()
			return This

	def StringWithMaquersSortedInDescending()
		cResult = This.Copy().SortMarquersInDescendingQ().Content()
		return cResult

	  #--------------------------------------------#
	 #  REPLACING MARQUERS WITH GIVEN SUBSTRINGS  #
	#============================================#

	def ReplaceMarquers(pacSubStrings)
		if isList(pacSubStrings) and Q(pacSubStrings).IsWithOrByNamedParam()
			pacSubStrings = pacSubStrings[2]
		ok

		aMarquersXT = This.MarquersAndSectionsSortedInAscending()
		nLen = len(aMarquersXT)

		nMin = Min([ len(pacSubStrings), nLen ])

		for i = nLen to 1 step -1
			
			cMarquer = aMarquersXT[i][1]

			This.ReplaceAll(cMarquer, pacSubStrings[i])
		next

		def ReplaceMarquersQ(pacSubStrings)
			This.ReplaceMarquers(pacSubStrings)
			return This

	def MarquersReplaced(pacSubStrings)
		return This.Copy().ReplaceMarquersQ(pacSubStrings).Content()

		#< @FunctionMisspelledForm

		def MarquersRepalced(pacSubStrings)
			return This.MarquersReplaced(pacSubStrings)

		#>

	  #------------------------------------------#
	 #    REPLACING SUBSTRINGS WITH MARQUERS    # TODO: Test it!
	#==========================================#

	def ReplaceSubstringsWithMarquersCS(pacSubstrings, pCaseSensitive)

		acSubStrings = StzListOfStringsQ(pacSubstrings).DuplicatesRemovedCS(pCaseSensitive)

		acMarquers = []

		for i = 1 to len(acSubStrings)
			acMarquers + ( "#" + i )
		next

		This.ReplaceManyByManyCS( acSubStrings, acMarquers, pCaseSensitive )

		def ReplaceSubstringsWithMarquersCSQ(pacSubstrings, pCaseSensitive)
			This.ReplaceSubstringsWithMarquersCS(pacSubstrings, pCaseSensitive)
			return This

	def SubstringsReplacedWithMarquersCS(pacSubstrings, pCaseSensitive)
		cResult = This.Copy().ReplaceSubstringsWithMarquersCSQ(pacSubstrings, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubstringsWithMarquers(pacSubstrings)
		This.ReplaceSubstringsWithMarquersCS(pacSubstrings, :CaseSensitive = TRUE)

	def SubstringsReplacedWithMarquers(pacSubstrings)
		return This.SubstringsReplacedWithMarquersCS(pacSubstrings, :CaseSensitive = TRUE)

	  #------------------------#
	 #    PARSING MARQUERS    #
	#========================#

	def NthMarquer(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		try
			return This.Marquers()[n]
		catch
			return NULL
		done

		def NthMarquerQ(n)
			return new stzString( This.NthMarquer(n) )

	def FirstMarquer()
		return This.NthMarquer(1)

		def FirstMarquerQ()
			return new stzString( This.LastMarquer() )

	def LastMarquer()
		n = This.NumberOfMarquers()
		acResult = This.Marquers()[ n ]
		return acResult

		def LastMarquerQ()
			return new stzString( This.LastMarquer() )

	  #------------------------------#
	 #    FINDING THE NTH MARQUER   #
	#==============================#

	def FindNthMarquer(n)
		if isString(n)
			if n = :First or n = :FirstMarquer
				n = 1
			but n = :Last or n = :LastMarquer
				n = This.NumberOfMarquers()
			ok
		ok

		return This.FindNthOccurrence( n, "#" )

		def NthMarquerOccurrence(n)
			return This.FindNthMarquer(n)

		def NthMarquerPosition(n)
			return This.FindNthMarquer(n)

		def PositionOfNthMarquer(n)
			return This.FindNthMarquer(n)

	def FindFirstMarquer()
		return This.FindNthMarquer(1)

		def FirstMarquerOccurrence()
			return This.FindFirstMarquer()

		def FirstMarquerPosition()
			return This.FindFirstMarquer()

		def PositionOfFirstMarquer()
			return This.FindFirstMarquer()

	def FindLastMarquer()
			return This.FindNthMarquer(This.NumberOfMarquers())

		def LastMarquerOccurrence()
			return This.FindLastMarquer()

		def LastMarquerPosition()
			return This.FindLastMarquer()

		def PositionOfLastMarquer()
			return This.FindLastMarquer()


	  #--------------------------------------------------#
	 #    NEXT MARQUERS STARTING AT A GIVEN POSITION    #
	#==================================================#

	def NextMarquers(pnStartingAt)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		return This.SectionQ(pnStartingAt, :LastChar).Marquers()

		def NextMarquersQ(pnStartingAt)
			return This.NextMarquersQR(pnstartingAt, :stzList)

		def NextMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NextMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.NextMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

	  #--------------------------------------#
	 #    RETURNING THE NTH NEXT MARQUER    #
	#======================================#

	def NthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> #3
		*/

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(pnStartingAt, :LastChar)
		return oStr.Marquers()[ n ]


		def NthNextMarquerQ(n, pnStartingAt)
			return new stzString( This.NthNextMarquer(n, pnStartingAt) )

		def NextNthMarquer(n, pnStartingAt)
			return This.NthNextMarquer(n, pnStartingAt)

			def NextNthMarquerQ(n, pnStartingAt)
				return new stzString( This.NextNthMarquer(n, pnStartingAt) )

	  #------------------------------------#
	 #    FINDING THE NTH NEXT MARQUER    #
	#====================================#

	def FindNthNextMarquer(n, pnStartingAt)
		/*
		StzStringQ("My name is #1, my age is #2, and my job is #3. Again: my name is #1!") {
			? NthNextMarquer(2, :StartingAt = 14)
		}

		#--> 44
		*/

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(pnStartingAt, :LastChar)

		nPos = oStr.MarquersPositions()[ n ] + pnStartingAt - 1
		
		return nPos

		def FindNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NthNextMarquerOccurrence(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)		

		def NthNextMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNthNextMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def NextNthMarquerPosition(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

		def PositionOfNextNthMarquer(n, pnStartingAt)
			return This.FindNthNextMarquer(n, pnStartingAt)

	  #-------------------------------------------------#
	 #    NTH NEXT MARQUER, ALONG WITH ITS POSITION    #
	#=================================================#

	def NthNextMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthNextMarquer(n, pnStartingAt)
		nPosition = This.FindNthNextMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthNextMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthNextMarquerAndItsPositionQR(n, pnStartingAt, pnStartingAt, :stzList)

		def NthNextMarquerAndItsPositionQR(n, pnStartingAt, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthNextMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NextNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthNextMarquerAndItsPosition(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQ(n, pnStartingAt)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

			def NextNthMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
				return This.NextNthMarquerAndItsPositionQ(n, pnStartingAt)

		def NextNthMarquerDZ(n, pnStartingAt)
			return This.NextNthMarquerAndItsPosition(n, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #    FINDING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def FindNextMarquer(pnStartingAt)
		return This.FindNthNextMarquer(1, pnStartingAt)

		def NextMarquerPosition(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def PositionOfNextMarquer(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def NextMarquerOccurrence(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

		def FindNextMarquerD(pnStartingAt)
			return This.FindNextMarquer(pnStartingAt)

	  #---------------------------------------------------------#
	 #    GETTING NEXT MARQUER STARTING AT A GIVEN POSITION    #
	#=========================================================#

	def NextMarquer(pnStartingAt)
		return This.NthNextMarquer(1, pnStartingAt)

		def NextMarquerQ(pnStartingAt)
			return new stzString( This.NextMarquer(pnStartingAt) )

		def NextMarquerD(pnStartingAt)
			return This.NextMarquer(pnStartingAt)

	  #--------------------------------------------------------------------------#
	 #    GETTING NEXT MARQUER AND ITS POSITION STARTING AT A GIVEN POSITION    #
	#==========================================================================#

	def NextMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.NextMarquer(pnStartingAt)
		nPosition = This.NextMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		def NextMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.NextMarquerAndItsPosition(pnStartingAt) )

		def NextMarquerAndItsOccurrence(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

			def NextMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.NextMarquerAndItsOccurrence(pnStartingAt) )

		def NextMarquerDZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

		def NextMarquerZ(pnStartingAt)
			return This.NextMarquerAndItsPosition(pnStartingAt)

	  #---------------------------------#
	 #    GETTING PREVIOUS MARQUERS    #
	#=================================#

	def PreviousMarquers(pnStartingAt)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0 )
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		return This.SectionQ(1, pnStartingAt).Marquers()

		#< @FunctionFluentForms

		def PreviousMarquersQ(pnStartingAt)
			return This.PreviousMarquersQR(pnstartingAt, :stzList)

		def PreviousMarquersQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousMarquers(pnStartingAt) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousMarquers(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquersD(pnStartingAt)
			return This.PreviousMarquers(pnStartingAt)

			def PreviousMarquersDQ()
				return This.PreviousMarquersQ()

			def PreviousMarquersDQR(pnStartingAt, pcReturnType)
				return This.PreviousMarquersQR(pnstartingAt, pcReturnType)

		#>

	  #------------------------------------#
	 #    GETTING NTH PREVIOUS MARQUER    #
	#====================================#

	def NthPreviousMarquer(n, pnStartingAt)
		nPos = This.FindNthPreviousMarquer(n, pnStartingAt)

		return This.MarquerByPosition(nPos)
		
		def NthPreviousMarquerQ(n, pnStartingAt)
			return new stzString( This.NthPreviousMarquer(n, pnStartingAt) )

		def PreviousNthMarquer(n, pnStartingAt)
			return This.NthPreviousMarquer(n, pnStartingAt)

			def PreviousNthMarquerQ(n, pnStartingAt)
				return new stzString( This.PreviousNthMarquer(n, pnStartingAt) )

	  #------------------------------------#
	 #    FINDING NTH PREVIOUS MARQUER    #
	#====================================#

	def FindNthPreviousMarquer(n, pnStartingAt)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		oStr = This.SectionQ(1,  pnStartingAt)

		aPositions = oStr.MarquersPositions()
		
		try
			return aPositions[ len(aPositions) - n + 1 ]
		catch
			return 0
		done
		
		#< @FunctionAlternativeForm

		def FindPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def NthPreviousMarquerOccurrence(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)		

		def NthPreviousMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfNthPreviousMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PreviousNthMarquerPosition(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		def PositionOfPreviousNthMarquer(n, pnStartingAt)
			return This.FindNthPreviousMarquer(n, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING NTH PREVIOUS MARQUER  ALONG WITH ITS POSITION -- Z/Extended   #
	#=========================================================================#

	def NthPreviousMarquerAndItsPosition(n, pnStartingAt)
		cMarquer  = This.NthPreviousMarquer(n, pnStartingAt)
		nPosition = This.FindNthPreviousMarquer(n, pnStartingAt)

		return [ cMarquer, nPosition ]

		#< @FunctionFluentForm

		def NthPreviousMarquerAndItsPositionQ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)

		def NthPreviousMarquerAndItsPositionQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			on :stzHashList
				return new stzHashList( This.NthPreviousMarquerAndItsPosition(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def PreviousNthMarquerAndItsPosition(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerAndItsPositionD(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def NthPreviousMarquerZ(n, pnStartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)


		def PreviousNthMarquerZ(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)

		def PreviousNthMarquerZD(n, pnstartingAt)
			return This.NthPreviousMarquerAndItsPosition(n, pnStartingAt)
 
		#>

	  #------------------------------#
	 #   FINDING PREVIOUS MARQUER   #
	#==============================#

	def FindPreviousMarquer(pnStartingAt)
		return This.FindNthPreviousMarquer(1, pnStartingAt)

		def PreviousMarquerPosition(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PositionOfPreviousMarquer(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

		def PreviousMarquerOccurrence(pnStartingAt)
			return This.FindPreviousMarquer(pnStartingAt)

	  #------------------------------#
	 #   GETTING PREVIOUS MARQUER   #
	#==============================#

	def PreviousMarquer(pnStartingAt)
		return This.NthPreviousMarquer(1, pnStartingAt)

		def PreviousMarquerQ(pnStartingAt)
			return new stzString( This.PreviousMarquer(pnStartingAt) )

	  #--------------------------------------------------------------------#
	 #   FINDING PREVIOUS MARQUER ALONG WITH ITS POSITION -- Z/Extension  #
	#====================================================================#

	def PreviousMarquerAndItsPosition(pnStartingAt)
		cMarquer  = This.PreviousMarquer(pnStartingAt)
		nPosition = This.PreviousMarquerPosition(pnStartingAt)

		aResult = [ cMarquer, nPosition ]
		return aResult

		#< @FunctionFluentForm

		def PreviousMarquerAndItsPositionQ(pnStartingAt)
			return new stzString( This.PreviousMarquerAndItsPosition(pnStartingAt) )

		#>

		#< @FunctionAlternativeForms

		def PreviousMarquerAndItsOccurrence(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceQ(pnStartingAt)
				return new stzString( This.PreviousMarquerAndItsOccurrence(pnStartingAt) )

		def PreviousMarquerAndItsPositionD(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsPositionDQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerAndItsOccurrenceD(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerAndItsOccurrenceDQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		def PreviousMarquerDZ(pnStartingAt)
			return This.PreviousMarquerAndItsPosition(pnStartingAt)

			def PreviousMarquerDZQ(pnStartingAt)
				return This.PreviousMarquerAndItsPositionQ(pnStartingAt)

		#>

	  #===========================================================#
	 #   CHECKING IF THE STRING CONTAINS DUPLICATED SUBSTRINGS   #
	#===========================================================#

	def ContainsDuplicatedSubStringsCS(pCaseSensitive)

		if This.NumberOfDuplicatesCS(pCaseSensitive) > 0
			return TRUE
		else
			return FALSE
		ok

		def ContainsDuplicatesCS(pCaseSensitive)
			return This.ContainsDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedSubStrings()
		return This.ContainsDuplicatedSubStringsCS(:CaseSensitive = TRUE)
	
		def ContainsDuplicates()
			return This.ContainsDuplicatedSubStrings()

	  #----------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED IN THE STRING   #
	#----------------------------------------------------------------#

	def ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		bResult = This.SubStringsCSQ(pCaseSensitive).ContainsDuplicatedCS(pcSubStr, pCaseSensitive)
		return bResult

		def ContainsDuplicatedSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicated(pcSubStr)
		return This.ContainsDuplicatedCS(pcSubStr, :CaseSensitive = TRUE)

		def ContainsDuplicatedSubString(pcSubStr)
			return This.ContainsDuplicated(pcSubStr)

	  #-----------------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN SUBSTRING IS DUPLICATED N-TIMES IN THE STRING  #
	#-----------------------------------------------------------------------#

	def ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def SubStringIsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsDuplicatedNTimesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsDuplicatedNTimes(n, pcSubStr)
		return This.ContainsDuplicatedNTimesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def SubStringIsDuplicatedNTimes(n, pcSubStr)
			return This.ContainsDuplicatedNTimes(n, pcSubStr, pItem)

	  #-----------------------------------------------------------------------#
	 #   HOW MANY TIMES A GIVEN SUBSTRING IS DUPLICATED INSIDE THE STRING?   #
	#-----------------------------------------------------------------------#

	def NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		nResult =  This.SubStringsCSQ(pCaseSensitive).
				NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#--

		def NumberOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		def NumberOfDuplicationsOfCS(pcSubStr, pCaseSensitive)
			return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfTimesSubStringIsDuplicated(pcSubStr)
		return This.NumberOfTimesSubStringIsDuplicatedCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfTimesThisSubStringIsDuplicated(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#--

		def NumberOfDuplicatesOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOfSubString(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		def NumberOfDuplicationsOf(pcSubStr)
			return This.NumberOfTimesSubStringIsDuplicated(pcSubStr)

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING THE EXISTENCE OF NON DUPLICATED SUBSTRINGS IN THE STRING  #
	#=====================================================================#

	def ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

		bResult = This.SubStringsCSQ(pCaseSensitive).
			       ContainsNonDuplicatedItemsCS(pCaseSensitive)

		return bResult

		def ContainsNoDuplicationsCS(pCaseSensitive)
			return This.ContainsNonDuplicatedSubStringsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNonDuplicatedsubStrings()
		return This.ContainsNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

		def ContainsNoDuplications()
			return This.ContainsNonDuplicatedSubStrings()

	  #-------------------------------------------------#
	 #  GETTING THE LIST OF NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsCS(pCaseSensitive)
		acResult = This.Copy().RemoveDuplicatedSubStringsCSQ(pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedISubStrings()
		return This.NonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #---------------------------------------#
	 #  NUMBER OF NON DUPLICATED SUBSTRINGS  #
	#---------------------------------------#

	def NumberOfNonDuplicatedSubStringsCS(pCaseSensitive)
		nResult = This.SubStringsCSQ(pCaseSensitive).NumberOfNonDuplicatedItemsCS(pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfNonDuplicatedSubStrings()
		return This.NumberOfNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #-------------------------------------#
	 #  FINDING NON DUPLICATED SUBSTRINGS  #
	#-------------------------------------#

	def FindNonDuplicatedSubStringsCS(pCaseSensitive)
		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)
		anResult = []

		for i = 1 to nLen
			# By defintion, a non duplicated substring apprears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			anResult + nPos
		next

		anResult = Q(anResult).Sorted()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNonDuplicatedSubStrings()
		return This.FindNonDuplicatedSubStringsCS(:CaseSensitive = TRUE)

	  #-------------------------------------------------#
	 #  NON DUPLICATED SUBSTRINGS AND THEIR POSITIONS  #
	#-------------------------------------------------#

	def NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

		acNonDuplicated = This.NonDuplicatedSubStringsCS(pCaseSensitive)
		nLen = len(acNonDuplicated)

		aResult = []
		for i = 1 to nLen
			# By definition, a non duplicated substrings appears once
			nPos = This.FindFirstCS(acNonDuplicated[i], pCaseSensitive)
			aResult + [ acNonDuplicated[i], nPos ]
		next

		return aResult

		def NonDuplicatedSubstringsCSZ(pCaseSensitive)
			return This.NonDuplicatedSubStringsAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NonDuplicatedSubStringsAndTheirPositions()
		return This.NonDuplicatedSubStringsAndTheirPositionsCS(:CaseSensitive = TRUE)

		def NonDuplicatedSubStringsZ()
			return This.NonDuplicatedSubStringsAndTheirPositions()

	  #--------------------------#
	 #   NUMBER OF DUPLICATES   #
	#==========================#

	def NumberOfDuplicatesCS(pCaseSensitive)

		nResult = len( This.DuplicatesCS(pCaseSensitive) )
		return nResult

		#< @FunctionAlternativeForms

		def HowManyDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		def HowManyDuplicateCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicatesCS(pCaseSensitive)
			return This.NumberOfDuplicatesCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfDuplicates()
		return This.NumberOfDuplicatesCS(:CaseSensitive = TRUE)

		#< @functionAlternativeForms

		def HowManyDuplicates()
			return This.NumberOfDuplicates()

		def HowManyDuplicate()
			return This.NumberOfDuplicates()

		#>

		#< @FunctionMisspelledForm

		def HowManuDuplicates()
			return This.NumberOfDuplicates()

		#>

	  #----------------------#
	 #  FINDING DUPLICATES  #
	#----------------------#

	def FindDuplicatesCS(pCaseSensitive)
		anPos = This.FindDuplicatesCSXT(pCaseSensitive)
		anResult = Q(anPos).ToSet()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicates()
		return This.FindDuplicatesCS(:CaseSensitive = TRUE)

	  #----------------------------------#
	 #  FINDING DUPLICATES -- EXTENDED  #
	#----------------------------------#

	# This extended form keeps the positions even if they are duplicated
	# For example :
	# 	
	def FindDuplicatesCSXT(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesXT()
		return This.FindDuplicatesCSXT(:CaseSensitive = TRUE)

	  #----------------------------------#
	 #  FINDING DUPLICATES AS SECTIONS  #
	#----------------------------------#

	def FindDuplicatesAsSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		nLen = len(acDuplicates)

		aResult = []

		for i = 1 to nLen
			aSections = This.FindAsSectionsCSQ(acDuplicates[i], pCaseSensitive).
					 FirstItemRemoved()

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = QR(aResult, :stzListOfPairs).Sorted()
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesAsSections()
		return This.FindDuplicatesAsSectionsCS(:CaseSensitive = TRUE)

	  #--------------#
	 #  DUPLICATES  #
	#--------------#

	def DuplicatesCS(pCaseSensitive)
		
		if This.IsEmpty()
			return []
		ok

		# Doing the job

		acResult = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen
			for j = i to nLen

				cSubStr = This.Section(i, j)

				if Q(acResult).ContainsNoCS(cSubStr, pCaseSensitive) and
				   This.NumberOfOccurrenceCS(cSubStr, TRUE) > 1

					acResult + cSubStr
				ok

			next
		next
		
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def Duplicates()
		return This.DuplicatesCS(:CaseSensitive = TRUE)

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR POSITIONS -- Z/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirPositionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesCSXT(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZ(pCaseSensitive)
			return This.DuplicatesAndTheirPositionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirPositions()
		return This.DuplicatesAndTheirPositionsCS(:CaseSensitive = TRUE)

		def DuplicatesZ()
			return This.DuplicatesAndTheirPositions()

	  #------------------------------------------------#
	 #  DUPLICATES AND THEIR SECTIONS -- ZZ/Extended  #
	#------------------------------------------------#

	def DuplicatesAndTheirSectionsCS(pCaseSensitive)
		acDuplicates = This.DuplicatesCS(pCaseSensitive)
		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		aResult = Association([ acDuplicates, aSections ])
		
		return aResult

		def DuplicatesCSZZ(pCaseSensitive)
			return This.DuplicatesAndTheirSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def DuplicatesAndTheirSections()
		return This.DuplicatesAndTheirSectionsCS(:CaseSensitive = TRUE)

		def DuplicatesZZ()
			return This.DuplicatesAndTheirSections()

	  #---------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

		anResult = []
		anPos = This.FindOccurrenceCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			anResult = Q(anPos).FirstItemRemoved()
		ok

		return anResult
		

		def PositionsOfDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubString(pcSubStr)
		return This.FindDuplicatesOfSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def PositionsOfDuplicatesOfSubString(pcSubStr)
			return This.FindDuplicatesOfSubString(pcSubStr)

	  #---------------------------------------------------------#
	 #   FINDING DUPLICATES OF A GIVEN SUBSTRING AS SECTIONS   #
	#---------------------------------------------------------#

	def FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = []
		anPos = This.FindOccurrencesAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if len(anPos) > 1
			aResult = Q(anPos).FirstItemRemoved()
		ok

		return aResult
		

		def PositionsOfDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindDuplicatesOfSubStringAsSections(pcSubStr)
		return This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def PositionsOfDuplicatesOfSubStringAsSections(pcSubStr)
			return This.FindDuplicatesOfSubStringAsSections(pcSubStr)

	  #-------------------------------------------#
	 #   REMOVING ALL DUPLICATES IN THE STRING   #
	#===========================================#

	def RemoveDuplicatesCS(pCaseSensitive)

		aSections = This.FindDuplicatesAsSectionsCS(pCaseSensitive)
		This.RemoveSections(aSections)

		def RemoveDuplicatesCSQ(pCaseSensitive)
			This.RemoveDuplicatesCS(pCaseSensitive)
			return This

	def DuplicatesRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveDuplicatesCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicates()
		This.RemoveDuplicatesCS(:CaseSensitive = TRUE)

		def RemoveDuplicatesQ()
			This.RemoveDuplicates()
			return This

	def DuplicatesRemoved()
		aResult = This.Copy().RemoveDuplicatesQ().Content()
		return aResult

  	  #----------------------------------------------#
	 #   REMOVING DUPLICATES OF A GIVEN SUBSTRING   #
	#----------------------------------------------#

	def RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
		aSections = This.FindDuplicatesOfSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringCS(pcSubStr, pCaseSensitive)

			def RemoveDuplicatesOfThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		aResult = This.Copy().
				RemoveDuplicatesOfSubStringCSQ(pcSubStr, pCaseSensitive).
				Content()

		return aResult

		#< @FunctionAlternativeForm

		def DuplicatesOfThisSubstringRemovedCS(pcSubStr, pCaseSensitive)
			return This.DuplicatesOfSubStringRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubString(pcSubStr)
		This.RemoveDuplicatesOfSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveDuplicatesOfSubStringQ(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcsubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveDuplicatesOfThisSubString(pcSubStr)
			This.RemoveDuplicatesOfSubString(pcSubStr)

			def RemoveDuplicatesOfThisSubStringQ(pcSubStr)
				This.RemoveDuplicatesOfThisSubString(pcSubStr)
				return This

		#>

	def DuplicatesOfSubStringRemoved(pcSubStr)
		return This.DuplicatesOfSubStringRemovedCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def DuplicatesOfThisSubStringRemoved(pcSubStr)
			return This.DuplicatesOfSubStringRemoved(pcSubStr)

		#>

	  #--------------------------------------------------#
	 #   REMOVING DUPLICATES OF MANY GIVEN SUBSTRINGS   #
	#--------------------------------------------------#

	def RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param! paItems must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.RemoveDuplicatesOfItemCS(pacSubStr[i], pCaseSensitive)
		next

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsCSQ(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def  RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.RemoveDuplicatesOfSubStringsCS(pacSubStr, pCaseSensitive)

			def RemoveDuplicatesOfTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.RemoveDuplicatesOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def RemoveDuplicatesOfSubStrings(pacSubStr)
		This.RemoveDuplicatesOfSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def RemoveDuplicatesOfSubStringsQ(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveDuplicatesOfTheseSubStrings(pacSubStr)
			This.RemoveDuplicatesOfSubStrings(pacSubStr)

			def RemoveDuplicatesOfTheseSubStringsQ(pacSubStr)
				This.RemoveDuplicatesOfTheseSubStrings(pacSubStr)
				return This

		#>

	  #===============================================#
	 #   TRANSFORMING THE STRING TO A STZTEXTOBJECT  #
	#===============================================#

	def ToStzText()
		return new stzText( This.String() )

	  #===============================================#
	 #      NUMBER OF OCCURRENCE OF A SUBSTRING      #
	#===============================================#

	def NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

		nResult = -1 + This.SplitCSQ(pcSubStr, pCaseSensitive).NumberOfItems()
		return nResult

		#< @FunctionFluentForm

		def NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
			return new stzNumber( This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrenceOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def NumberOfOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceOfSubstringCS(pcSubStr, pCaseSensitive)

			def NumberOfOccurrencesOfSubstringCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def CountCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def CountCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		def HowManyCS(pcSubStr, pCaseSensitive)
			return This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

			def HowManyCSQ(pcSubStr, pCaseSensitive)
				return This.NumberOfOccurrenceCSQ(pcSubStr, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrence(pcSubStr)
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		return NumberOfOccurrenceCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumberOfOccurrenceQ(pcSubStr)
			return new stzNumber( This.NumberOfOccurrence(pcSubStr) )

		#>

		#< @FunctionAlternativeForm
	
		def NumberOfOccurrences(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrencesQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrenceOfSubstring(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def NumberOfOccurrenceOfSubstringCQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def NumberOfOccurrencesOfSubstring(pcSubStr)
			return This.NumberOfOccurrenceOfSubstring(pcSubStr)

			def NumberOfOccurrencesOfSubstringQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def Count(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def CountQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		def HowMany(pcSubStr)
			return This.NumberOfOccurrence(pcSubStr)

			def HowManyQ(pcSubStr)
				return This.NumberOfOccurrenceQ(pcSubStr)
	
		#>

	  #=======================================================#
	 #    CHECKING IF THE STRING IS ONE OF THE RING TYPES    #
	#=======================================================#

	def IsRingType()
		return This.UppercaseQ().IsOneOfThese([ "NUMBER", "STRING", "LIST", "OBJECT", "COBJECT" ])

	  #==============================#
	 #  GETTING THE SIZE IN BYTES   #
	#==============================#

	def NumberOfBytes()
		return This.ToStzListOfBytes().NumberOfBytes()

		#< @FunctionAlternativeForm

		def SizeInBytes()
			return This.NumberOfBytes()

		def CountBytes()
			return This.NumberOfBytes()

		def HowManyBytes()
			return This.NumberOfBytes()

		def HowManyByte()
			return This.NumberOfBytes()

		def LengthInBytes()
			return This.NumberOfBytes()

		def LengthInByte()
			return This.NumberOfBytes()

		#>
	
	def NumberOfBytesPerChar()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.CharQ(i).NumberOfBytes() ]
		next

		return aResult

		#< @FunctionAlternativeFormss

		def CountBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytesPerChar()
			return This.NumberOfBytesPerChar()

		def HowManyBytePerChar()
			return This.NumberOfBytesPerChar()

	  #------------------------------#
	 #   BYTES AND BYTES PER CHAR   #
	#==============================#

	def Bytes()
		return This.ToStzListOfBytes().Content()

		#< @FunctionFluentForms

		def BytesQ()
			return This.ToStzListOfBytes()

		#>
	
		#< @FunctionAlternativeForm

		def ToListOfBytes()
			return This.Bytes()
	
			def ToListOfBytesQ()
				return This.BytesQ()
	
		#>

	def BytesPerChar()
		return This.ToStzListOfBytes().BytesPerChar()

	  #--------------------------------------#
	 #   BYTECODES AND BYTECODES PER CHAR   #
	#--------------------------------------#

	def Bytecodes()
		return This.ToStzListOfBytes().Bytecodes()

	def BytecodesPerChar()
		return This.ToStzListOfBytes().BytecodesPerChar()

	  #--------------------------------------------------------#
	 #   TRANSFORMING THE STRING TO A stzListOfBytes OBJECT   #
	#--------------------------------------------------------#

	def ToStzListOfBytes()
		return new stzListOfBytes( This.String() )

	  #===========================================#
	 #   N RIGHT CHARS RETURNED AS A SUBSTRING   #
	#===========================================#

	def NRightCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok


		if n = 0
			return NULL
		else
			if This.IsRightToleft()
				cResult = This.Section( 1, n )
			else
				cResult = This.Section( This.NumberOfChars() - n + 1, NumberOfChars() )
			end
					
			return cResult
		ok

		#< @FunctionFluentForm

		def NRightCharsAsSubStringQ(n)
			return new stzString( This.NRightCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForms

		def NRightCharsAsString(n)
			return This.NRightCharsAsSubString(n)

			def NRightCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

		def RightNCharsAsSubString(n)
			return This.NRightCharsAsSubString(n)
	
			def RightNCharsAsString(n)
				return This.RightNCharsAsSubString(n)

			def RightNCharsAsSubStringQ(n)
				return This.NRightCharsAsSubStringQ(n)

			def RightNCharsAsStringQ(n)
				return This.NRightCharsAsSubStringQ(n)
	
		def Right(n)
			return This.NRightCharsAsSubString(n)

			def RightQ(n)
				return This.NRightCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Right2CharsAsSubString()
			return This.NRightCharsAsSubString(2)

			def Right2CharsAsString()
				return This.Right2CharsAsSubString()

			def 2RightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def 2RightCharsAsString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def RightTwoCharsAsString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsSubString()
				return This.NRightCharsAsSubString(2)

			def TwoRightCharsAsString()
				return This.NRightCharsAsSubString(2)

		def Right3CharsAsSubString()
			return This.NRightCharsAsSubString(3)

			def Right3CharsAsString()
				return This.Right3CharsAsSubString()

			def 3RightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def 3RightCharsAsString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def RightThreeCharsAsString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsSubString()
				return This.NRightCharsAsSubString(3)

			def ThreeRightCharsAsString()
				return This.NRightCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLeftCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return NULL
		else
			if IsRightToleft()
				cResult = Section( This.NumberOfChars()-n+1, NumberOfChars() )
			else
				cResult = Section( 1, n)
			end
	
			return cResult
		ok

		#< @FunctionFluentForm

		def NLeftCharsAsSubStringQ(n)
			return new stzString( This.NLeftCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLeftCharsAsString(n)
			return This.NLeftCharsAsSubString(n)

			def NLeftCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def LeftNCharsAsSubString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsSubStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)
	
		def LeftNCharsAsString(n)
			return This.NLeftCharsAsSubString(n)
	
			def LeftNCharsAsStringQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		def Left(n)
			return This.NLeftCharsAsSubString(n)

			def LeftQ(n)
				return This.NLeftCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Left2CharsAsSubString()
			return This.NLeftCharsAsSubString(2)

			def Left2CharsAsString()
				return This.Left2CharsAsSubString()

			def 2LefthtCharsAsSubString()
				return This.NLefttCharsAsSubString(2)

			def 2LefthtCharsAsString()
				return This.NLefttCharsAsSubString(2)

			def LeftTwoCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def LeftTwoCharsAsString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(2)

			def TwoLeftCharsAsString()
				return This.NLeftCharsAsSubString(2)

		def Left3CharsAsSubString()
			return This.NLeftCharsAsSubString(3)

			def Left3CharsAsString()
				return This.Left3CharsAsSubString()

			def 3LeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def 3LeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def LeftThreeCharsAsString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsSubString()
				return This.NLeftCharsAsSubString(3)

			def ThreeLeftCharsAsString()
				return This.NLeftCharsAsSubString(3)

		#>

	  #-------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A SUBSTRING   #
	#-------------------------------------------#

	def NFirstCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NRightCharsAsSubString(n)
		else
			return This.NLeftCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsAsSubStringQ(n)
			return new stzString( This.NFirstCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NFirstCharsAsString(n)
			return This.NFirstCharsAsSubString(n)

			def NFirstCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
	
		def FirstNCharsAsSubString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsSubStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)

		def FirstNCharsAsString(n)
			return This.NFirstCharsAsSubString(n)
	
			def FirstNCharsAsStringQ(n)
				return This.NFirstCharsAsSubStringQ(n)
		#>

		#< @FunctionSpecificForms

		def First2CharsAsSubString()
			return This.NFirstCharsAsSubString(2)

			def First2CharsAsString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def 2FirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def FirstTwoCharsAsString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(2)

			def TwoFirstCharsAsString()
				return This.NFirstCharsAsSubString(2)

		def First3CharsAsSubString()
			return This.NFirstCharsAsSubString(3)

			def First3CharsAsString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def 3FirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def FirstThreeCharsAsString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsSubString()
				return This.NFirstCharsAsSubString(3)

			def ThreeFirstCharsAsString()
				return This.NFirstCharsAsSubString(3)

		#>

	  #------------------------------------------#
	 #   N LAST CHARS RETURNED AS A SUBSTRING   #
	#------------------------------------------#

	def NLastCharsAsSubString(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftCharsAsSubString(n)
		else
			return This.NRightCharsAsSubString(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsAsSubStringQ(n)
			return new stzString( This.NLastCharsAsSubString(n) )

		#>

		#< @FunctionAlternativeForm

		def NLastCharsAsString(n)
			return This.NLastCharsAsSubString(n)

			def NLastCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsSubString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsSubStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		def LastNCharsAsString(n)
			return This.NLastCharsAsSubString(n)
	
			def LastNCharsAsStringQ(n)
				return This.NLastCharsAsSubStringQ(n)

		#>

		#< @FunctionSpecificForms

		def Last2CharsAsSubString()
			return This.NLastCharsAsSubString(2)

			def Last2CharsAsString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def 2LastCharsAsString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def LastTwoCharsAsString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsSubString()
				return This.NLastCharsAsSubString(2)

			def TwoLastCharsAsString()
				return This.NLastCharsAsSubString(2)

		def Last3CharsAsSubString()
			return This.NLastCharsAsSubString(3)

			def Last3CharsAsString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def 3LastCharsAsString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def LastThreeCharsAsString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsSubString()
				return This.NLastCharsAsSubString(3)

			def ThreeLastCharsAsString()
				return This.NLastCharsAsSubString(3)

		#>

	  #-----------------------------------------------------------#
	 #   GETTING THE NEXT NTH CHAR STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------#

	def NextNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return NULL
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstStringItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString, :LastStringItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(1, This.NumberOfChars() - 1)
			if pnStartingAt + n <= This.NumberOfChars()
				cResult = This.CharAt(pnStartingAt + n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def NextNthCharQ(n, pnStartingAt)
			return This.NextNthCharQR(n, pnStartingAt, :stzString)

		def NextNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NextNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.NextNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthNextChar()
			return This.NextNthChar()

			def NthNextCharQ()
				return This.NthNextCharQR(:stzString)
	
			def NthNextCharQR(pcReturnType)
				return This.NextNthCharQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2ndChar()
			return This.NextNthChar(2)

			def 2ndNextChar()
				return This.NextNthChar(2)

			def NextSecondChar()
				return This.NextNthChar(2)

			def SecondNextChar()
				return This.NextNthChar(2)

		def Next3rdChar()
			return This.NextNthChar(3)

			def 3rdNextChar()
				return This.NextNthChar(3)

			def NextThirdChar()
				return This.NextNthChar(3)

			def ThirdNextChar()
				return This.NextNthChar(3)

		#>

	  #-------------------------------------------------------#
	 #   GETTING THE NEXT CHAR STARTING AT A GIVEN POSITION  #
	#-------------------------------------------------------#

	def NextChar(paStartingAt)
		return This.NextNthChar(1)

		#< @FunctionFluentForm

		def NextCharQ(pnStartingAt)
			return This.NextCharQR(pnStartingAt, :stzString)

		def NextCharQR(pnStartingAt, pcReturnType)
			return This.NextNthCharQR(1, pcReturnType)

		#>

	  #----------------------------------------------------------------#
	 #   GETTING THE PREVIOUS NTH CHAR STARTING AT A GIVEN POSITION   #
	#----------------------------------------------------------------#

	def PreviousNthChar(n, pnStartingAt)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		cResult = ""

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if Q(pnStartingAt).IsOneOfTheseCS([
				:First, :FirstPosition, :FirstString, :FirstStringItem ], :CS = FALSE)

				pnStartingAt = 1
			
			but Q(pnStartingAt).IsOneOfTheseCS([
				:Last, :LastPosition, :LastString, :LastStringItem ], :CS = FALSE)

				pnStartingAt = This.NumberOfStrings()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			stzRaise("Incorrect param! pnStartingAt must be a number.")
		ok

		if Q(pnStartingAt).IsBetween(2, This.NumberOfChars())
			if pnStartingAt - n >= 1
				cResult = This.CharAt(pnStartingAt - n)
			ok
		ok

		return cResult

		#< @FunctionFluentForms

		def PreviousNthCharQ(n, pnStartingAt)
			return This.PreviousNthCharQR(n, pnStartingAt, :stzString)

		def PreviousNthCharQR(n, pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousNthChar(n, pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousNthChar(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
		
		#< @FunctionAlternativeForms

		def NthPreviousChar()
			return This.PreviousNthChar()

			def NthPreviousCharQ()
				return This.NthPreviousCharQR(:stzString)
	
			def NthPreviousCharQR(pcReturnType)
				return This.PreviousNthCharQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2ndChar()
			return This.PreviousNthChar(2)

			def 2ndPreviousChar()
				return This.PreviousNthChar(2)

			def PreviousSecondChar()
				return This.PreviousNthChar(2)

			def SecondPreviousChar()
				return This.PreviousNthChar(2)

		def Previous3rdChar()
			return This.PreviousNthChar(3)

			def 3rdPreviousChar()
				return This.PreviousNthChar(3)

			def PreviousThirdChar()
				return This.PreviousNthChar(3)

			def ThirdPreviousChar()
				return This.PreviousNthChar(3)

		#>

	  #------------------------------------------------------------#
	 #   GETTING THE PREVIOUS CHAR STARTING AT A GIVEN POSITION   #
	#------------------------------------------------------------#

	def PreviousChar(n)
		return This.PreviousNthChar(n, 1)

		#< @FunctionFluentForm

		def PreviousCharQ(pnStartingAt)
			return This.PreviousCharQR(pnStartingAt, :stzString)

		def PreviousCharQR(pnStartingAt, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.PreviousChar(pnStartingAt) )

			on :stzChar
				return new stzChar( This.PreviousChar(pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off	
		#>

	  #------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A SUBSTRING)   #
	#------------------------------------------------------------------------#

	def NextNCharsAsSubString(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt, pnStartingAt + n - 1)

		return cResult

		#< @FunctionFluentForm

		def NextNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString(This.NextNCharsAsSubString(n, pnStartingAt))

		#>

		#< @FunctionAlternativeForm

		def NextNCharsAsString(n, pnStartingAt)
			return This.NextNCharsAsSubString(n, pnStartingAt)

			def NextNCharsAsStringQ(n, pnStartingAt)
				return This.NextNCharsAsSubStringQ(n, pnStartingAt)

		#>

		#< @FunctionSpecificForms

		def Next2CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(2, pnStartingAt)

			def Next2CharsAsString(pnStartingAt)
				return This.Next2CharsAsSubString(pnStartingAt)

			def 2NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def 2NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def NextTwoCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

			def TwoNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(2, pnStartingAt)

		def Next3CharsAsSubString(pnStartingAt)
			return This.NextNCharsAsSubString(3, pnStartingAt)

			def Next3CharsAsString(pnStartingAt)
				return This.Next3CharsAsSubString(pnStartingAt)

			def 3NextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def 3NextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def NextThreeCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsSubString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

			def ThreeNextCharsAsString(pnStartingAt)
				return This.NextNCharsAsSubString(3, pnStartingAt)

		#>

	  #-------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A SUBSTRING  #
	#-------------------------------------------------------------------------#

	def PreviousNCharsAsSubString(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		cResult = This.Section(pnStartingAt - n + 1, pnStartingAt)

		return cResult

		#< @FunctionFluentForm

		def PreviousNCharsAsSubStringQ(n, pnStartingAt)
			return new stzString( This.PreviousNCharsAsSubString(n, pnStartingAt) )

		#>

		#< @FunctionAlternativeForm

		def PreviousNCharsAsString(n, pnStartingAt)
			return This.PreviousNCharsAsSubString(n, pnStartingAt)

			def PreviousNCharsAsStringQ(n, pnStartingAt)
				return This.PreviousNCharsAsSubStringQ(n, pnStartingAt)
	
		#>

		#< @FunctionSpecificForms

		def Previous2CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def Previous2CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def 2PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def PreviousTwoCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

			def TwoPreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(2, pnStartingAt)

		def Previous3CharsAsSubString(pnStartingAt)
			return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def Previous3CharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def 3PreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)
	
			def PreviousThreeCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def PreviousThreeCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsSubString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

			def ThreePreviousCharsAsString(pnStartingAt)
				return This.PreviousNCharsAsSubString(3, pnStartingAt)

		#>

	  #===============================================#
	 #   N RIGHT CHARS RETURNED AS A LIST OF CHARS   #
	#===============================================#

	def NRightChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		acResult = []

		if This.IsRightToleft()
			acResult = This.SectionQ( 1, n ).Chars()
		else
			acResult = This.SectionQ( This.NumberOfChars() - n + 1, NumberOfChars() ).Chars()
		end
					
		return acResult

		#< @FunctionFluentForm

		def NRightCharsQ(n)
			return This.NRightCharsQR(n, :stzList)

		def NRightCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NRightChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NRightChars(n) )

			on :stzListOfChars
				return new stzListOfchars( This.NRightChars(n) )

			on :stzString
				return new stzString( This.NRightCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def RightNChars(n)
			return This.NRightChars(n)
	
			def RightNCharsQ(n)
				return This.NRightCharsQ(n)

			def RightNCharsQR(n, pcReturnType)
				return This.NRightCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Right2Chars()
			return This.NRightChars(2)

			def 2RightChars()
				return This.NRightChars(2)

			def RightTwoChars()
				return This.NRightChars(2)

			def TwoRightChars()
				return This.NRightChars(2)

	
		def Right3Chars()
			return This.NRightChars(3)

			def 3RightChars()
				return This.NRightChars(3)

			def RightThreeChars()
				return This.NRightChars(3)

			def ThreeRightChars()
				return This.NRightChars(3)

		#>

	  #----------------------------------------------#
	 #   N LEFT CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLeftChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		acResult = []

		if IsRightToleft()
			acResult = SectionQ( This.NumberOfChars()-n+1, NumberOfChars() ).Chars()
		else
			acResult = SectionQ( 1, n).Chars()
		end
	
		return acResult


		#< @FunctionFluentForm

		def NLeftCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NLeftCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLeftChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLeftChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLeftChars(n) )

			on :stzString
				return new stzString( This.NLeftCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LeftNChars(n)
			return This.NLeftChars(n)
	
			def LeftNCharsQ(n)
				return This.NLeftCharsQ(n)

			def LeftNCharsQR(n, pcReturnType)
				return This.NLeftCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Left2Chars()
			return This.NLeftChars(2)

			def 2LefthtChars()
				return This.NLefttChars(2)

			def LeftTwoChars()
				return This.NLeftChars(2)

			def TwoLeftChars()
				return This.NLeftChars(2)

	
		def Left3Chars()
			return This.NLeftChars(3)

			def 3LeftChars()
				return This.NLeftChars(3)

			def LeftThreeChars()
				return This.NLeftChars(3)

			def ThreeLeftChars()
				return This.NLeftChars(3)

		#>

	  #-----------------------------------------------#
	 #   N FIRST CHARS RETURNED AS A LIST OF CHARS   #
	#-----------------------------------------------#

	def NFirstChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if n = 0
			return []
		ok

		if This.IsRightToLeft()
			return This.NRightChars(n)
		else
			return This.NLeftChars(n)
		ok

		#< @FunctionFluentForm

		def NFirstCharsQ(n)
			return This.NLeftCharsQR(n, :stzList)

		def NFirstCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NFirstChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NFirstChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NFirstChars(n) )

			on :stzString
				return new stzString( This.NFirstCharsQR(n, :stzListOfStrings).Concatenated() )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def FirstNChars(n)
			return This.NFirstChars(n)
	
			def FirstNCharsQ(n)
				return This.NFirstCharsQ(n)

			def FirstNCharsQR(n, pcReturnType)
				return This.NFirstCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def First2Chars()
			return This.NFirstChars(2)

			def 2FirstChars()
				return This.NFirstChars(2)

			def FirstTwoChars()
				return This.NFirstChars(2)

			def TwoFirstChars()
				return This.NFirstChars(2)

		def First3Chars()
			return This.NFirstChars(3)

			def 3FirstChars()
				return This.NFirstChars(3)

			def FirstThreeChars()
				return This.NFirstChars(3)

			def ThreeFirstChars()
				return This.NFirstChars(3)

		def First4Chars()
			return This.FirstNChars(4)
	
			def 4FirstChars()
				return This.First4Chars()
	
			def FirstFourChars()
				return This.First4Chars()
	
			def FourFirstChars()
				return This.First4Chars()
	
		def First5Chars()
			return This.FirstNChars(5)
	
			def 5FirstChars()
				return This.First5Chars()
	
			def FirstFiveChars()
				return This.First5Chars()
	
			def FiveFirstChars()
				return This.First5Chars()
	
		def First6Chars()
			return This.FirstNChars(6)
	
			def 6FirstChars()
				return This.First6Chars()
	
			def FirstSixChars()
				return This.First6Chars()
	
			def SixFirstChars()
				return This.First6Chars()
	
		def First7Chars()
			return This.FirstNChars(7)
	
			def 7FirstChars()
				return This.First7Chars()
	
			def FirstSevenChars()
				return This.First7Chars()
	
			def SevenFirstChars()
				return This.First7Chars()
	
		def First8Chars()
			return This.FirstNChars(8)
	
			def 8FirstChars()
				return This.First8Chars()
	
			def FirstEightChars()
				return This.First8Chars()
	
			def EightFirstChars()
				return This.First8Chars()
	
		def First9Chars()
			return This.FirstNChars(9)
	
			def 9FirstChars()
				return This.First9Chars()
	
			def FirstNineChars()
				return This.First9Chars()
	
			def NineFirstChars()
				return This.First9Chars()
	
		def First10Chars()
			return This.FirstNChars(10)
	
			def 10FirstChars()
				return This.First10Chars()
	
			def FirstTenChars()
				return This.First10Chars()
	
			def TenFirstChars()
				return This.First10Chars()
	
		#>

	  #----------------------------------------------#
	 #   N LAST CHARS RETURNED AS A LIST OF CHARS   #
	#----------------------------------------------#

	def NLastChars(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if This.IsRightToLeft()
			return This.NLeftChars(n)
		else
			return This.NRightChars(n)
		ok

		#< @FunctionFluentForm

		def NLastCharsQ(n)
			return This.NLastCharsQR(n, pcReturnType)

		def NLastCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NLastChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NLastChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.NLastChars(n) )

			on :stzString
				return new stzString( This.NLastCharsQR(n, :stzListOfStrings).Concatenated() )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def LastNChars(n)
			return This.NLastChars(n)
	
			def LastNCharsQ(n)
				return This.NLastCharsQ(n)

			def LastNCharsQR(n, pcReturnType)
				return This.NLastCharsQR(n, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Last2Chars()
			return This.NLastChars(2)

			def 2LastChars()
				return This.NLastChars(2)

			def LastTwoChars()
				return This.NLastChars(2)

			def TwoLastChars()
				return This.NLastChars(2)

		def Last3Chars()
			return This.NLastChars(3)

			def 3LastChars()
				return This.NLastChars(3)

			def LastThreeChars()
				return This.NLastChars(3)

			def ThreeLastChars()
				return This.NLastChars(3)

		def Last4Chars()
			return This.LastNChars(4)
	
			def 4LastChars()
				return This.Last4Chars()
	
			def LastFourChars()
				return This.Last4Chars()
	
			def FourLastChars()
				return This.Last4Chars()
	
		def Last5Chars()
			return This.LastNChars(5)
	
			def 5LastChars()
				return This.Last5Chars()
	
			def LastFiveChars()
				return This.Last5Chars()
	
			def FiveLastChars()
				return This.Last5Chars()
	
		def Last6Chars()
			return This.LastNChars(6)
	
			def 6LastChars()
				return This.Last6Chars()
	
			def LastSixChars()
				return This.Last6Chars()
	
			def SixLastChars()
				return This.Last6Chars()
	
		def Last7Chars()
			return This.LastNChars(7)
	
			def 7LastChars()
				return This.Last7Chars()
	
			def LastSevenChars()
				return This.Last7Chars()
	
			def SevenLastChars()
				return This.Last7Chars()
	
		def Last8Chars()
			return This.LastNChars(8)
	
			def 8LastChars()
				return This.Last8Chars()
	
			def LastEightChars()
				return This.Last8Chars()
	
			def EightLastChars()
				return This.Last8Chars()
	
		def Last9Chars()
			return This.LastNChars(9)
	
			def 9LastChars()
				return This.Last9Chars()
	
			def LastNineChars()
				return This.Last9Chars()
	
			def NineLastChars()
				return This.Last9Chars()
	
		def Last10Chars()
			return This.LastNChars(10)
	
			def 10LastChars()
				return This.Last10Chars()
	
			def LastTenChars()
				return This.Last10Chars()
	
			def TenLastChars()
				return This.Last10Chars()
	
		#>

	  #---------------------------------------------------------------------------#
	 #  NEXT N CHARS STARTING AT A GIVEN POSITION (RETURNED AS A LIST OF CHARS)  #
	#---------------------------------------------------------------------------#

	def NextNChars(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt, pnStartingAt + n - 1).Chars()

		return acResult

		#< @FunctionFluentForm

		def NextNCharsQ(n, pnStartingAt)
			return This.NextNCharsQR(n, pnStartingAt, :stzList)

		def NextNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.NextNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NextNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.NextNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NNextChars(n, pnStartingAt)
			return This.NextNChars(n, pnStartingAt)

			def NNextCharsQ(n, pnStartingAt)
				return This.NNextCharsQR(n, pnStartingAt, :stzList)

			def NNextCharsQR(n, pnStartingAt, pcReturnType)
				return This.NextNCharsQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Next2Chars(pnStartingAt)
			return This.NextNChars(2, pnStartingAt)

			def 2NextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def NextTwoChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

			def TwoNextChars(pnStartingAt)
				return This.NextNChars(2, pnStartingAt)

		def Next3Chars(pnStartingAt)
			return This.NextNChars(3, pnStartingAt)

			def 3NextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def NextThreeChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

			def ThreeNextChars(pnStartingAt)
				return This.NextNChars(3, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------#
	 #  PREVIOUS N CHARS STARTING AT A GIVEN POSITION RETURNED AS A LIST OF CHARS  #
	#-----------------------------------------------------------------------------#

	def PreviousNChars(n, pnStartingAt)

		# Checking params

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()
			ok
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pnStartingAt < 0
			pnStartingAt = This.NumberOfChars() - Abs(pnStartingAt) + 1
		ok

		# Doing the job

		acResult = This.SectionQ(pnStartingAt - n + 1, pnStartingAt).Chars()

		return acResult

		#< @FunctionFluentForm

		def PreviousNCharsQ(n, pnStartingAt)
			return This.PreviousNCharsQR(n, pnStartingAt, :stzList)

		def PreviousNCharsQR(n, pnStartingAt, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfStrings
				return new stzListOfStrings( This.PreviousNChars(n, pnStartingAt) )

			on :stzListOfChars
				return new stzListOfChars( This.PreviousNChars(n, pnStartingAt) )

			other
				stzRaise("Unsupported return type!")
			off		

		#>

		#< @FunctionAlternativeForms

		def NPreviousChars(n, pnStartingAt)
			return This.PreviousNChars(n, pnStartingAt)

			def NPreviousCharsQ(n, pnStartingAt)
				return This.NPreviousCharsQR(n, pnStartingAt, :stzList)

			def NPreviousCharsQR(n, pnStartingAt, pcReturnType)
				return This.PreviousNCharsQR(n, pnStartingAt, pcReturnType)

		#>

		#< @FunctionSpecificForms

		def Previous2Chars(pnStartingAt)
			return This.PreviousNChars(2, pnStartingAt)

			def 2PreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def PreviousTwoChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

			def TwoPreviousChars(pnStartingAt)
				return This.PreviousNChars(2, pnStartingAt)

		def Previous3Chars(pnStartingAt)
			return This.PreviousNChars(3, pnStartingAt)

			def 3PreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def PreviousThreeChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

			def ThreePreviousChars(pnStartingAt)
				return This.PreviousNChars(3, pnStartingAt)

		#>

	  #====================================================#
	 #  INFERING A RING OR SOFTANZA TYPE FROM THE STRING  #
	#====================================================#

	def InfereType()
		cStr = This.Lowercased()

		# Checking if the string correponds to one of the 4 Ring types

		if cStr = :number or cStr = :numbers or Q(cStr).BeginsWith(:Number)
			return :Number
	
		but cStr = :string or cStr = :strings or Q(cStr).BeginsWith(:String)
			return :String
	
		but cStr = :list or cStr = :lists or Q(cStr).BeginsWith(:List) or
		    cStr = :pair or cStr = :pairs or Q(cStr).BeginsWith(:pair)
	
			return :List
	
		but cStr = :object or cStr = :objects or Q(cStr).BeginsWith(:Object)
			return :Object
	
		ok
	
		# Checking if the string correponds to one of the Softanza types

		if Q(cStr).BeginsWithCS("stz", :CS = FALSE)
			acStzClasses = StzClassesXT()
			nLen = len(acStzClasses)

			for i = 1 to nLen
				aPair = acStzClasses[i]
				if aPair[1] = cStr or aPair[2] = cStr
					return aPair[1]
				ok
			next

		but Q("stz" + cStr).IsStzType()
			return "stz" + cStr

		but Q(cStr).IsPluralOfAStzType()
			return PluralToStzType(cStr)

		but Q("stz" + cStr).IsPluralOfAStzType()
			return PluralToStzType("stz" + cStr)

		ok

		#< @FunctionAlternativeForms

		def InfereTypeQ()
			return new stzString( This.InfereType() )

		def InfereStzClass()
			return This.InfereType()

			def InfereStzClassQ()
				return new stzString( This.InfereStzClass() )

		def InfereStzClassName()
			return This.InfereType()

			def InfereStzClassNameQ()
				return new stzString( This.InfereStzClass() )

		#>

	def InferedType()
		return This.InfereType()

		#< @FunctionAlternativeForms

		def InferedStzClass()
			return This.InfereType()

		def InferedStzClassName()
			return This.InfereType()

		#>

	  #----------------------------------------------------#
	 #  INFERING A SOFTANZA CLASS METHOD FROM THE STRING  #
	#----------------------------------------------------#

	def InfereMethod(pcFromStzClass)

		if isList(pcFromStzClass) and
		   Q(pcFromStzClass).IsOneOfTheseNamedParams([ :From, :In, :Of ])
			pcFromStzClass = pcFromStzClass[2]
		ok

		if NOT isString(pcFromStzClass)
			stzRaise("Incorrect param type! pcFromStzClass must be a string.")
		ok

		if Q(pcFromStzClass).IsPluralOfAStzType()
			pcFromStzClass = PluralToStzType(pcFromStzClass)
		ok

		if NOT Q(pcFromStzClass).IsStzClass()
			stzRaise("Syntax error! pcFromStzClass must be a valid Softanza class name.")
		ok

		cCode = 'acTheseMethods = Stz("' +
			Q(pcFromStzClass).FirstNCharsRemoved(3) + '",
			:Methods)'

		eval(cCode)

		cMethod = ""

		oList = new stzList( acTheseMethods )

		if oList.ContainsCS( "is" + This.String(), :CS = FALSE )
			cMethod = "is" + This.String()

		but oList.ContainsCS( "is" + This.LastCharRemoved(), :CS = FALSE )
			cMethod = "is" + This.LastCharRemoved()

		else
			stzRaise("Sorry! Can't infere the method name from the provided string.")
		ok

		return cMethod

		def InfereMethodQ()
			return new stzString( This.InfereMethod() )

	def InferedMethod()
		return InfereMthod()

	  #--------------------------------------------------------------#
	 #    CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	#--------------------------------------------------------------#

	def IsStzClassName()
		acStzClasses = StzClasses()

		n = ring_find( StzClasses(), This.Lowercased() )

		if n > 0
			return TRUE
		else
			return FALSE
		ok

		def IsStzType()
			return This.IsStzClassName()

		def IsStzClass()
			return This.IsStzClassName()

		def IsAStzClassName()
			return This.IsStzClassName()

		def IsAStzType()
			return This.IsStzClassName()

		def IsAStzClass()
			return This.IsStzClassName()

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF ANY SOFTANZA TYPE  #
	#------------------------------------------------------------------#

	def IsPluralOfAStzType()

		if QR( StzTypesXT(), :stzListOfPairs ).
		   SecondItemsQ().
		   ContainsCS( This.Content(), :CaseSensitive = FALSE )

			return TRUE

		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def IsPluralOfStzType()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClass()
			return This.IsPluralOfAStzType()

		def IsPluralOfAStzClassName()
			return This.IsPluralOfAStzType()

		def IsPluralOfStzClassName()
			return This.IsPluralOfAStzType()

		#--

		def IsStzClassInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPluralForm()
			return This.IsPluralOfAStzType()

		def IsStzClassInPlural()
			return This.IsPluralOfAStzType()

		def IsStzClassNameInPlural()
			return This.IsPluralOfAStzType()

		def IsStzTypeInPlural()
			return This.IsPluralOfAStzType()

		#>

	   #-------------------------------------------------------------#
	  #   CHECKING IF THE STRING CORRESPONDS TO A STZ CLASS NAME    #
	 #   NO MATTER IT WAS IN SINGULAR OR PLURAL FORM               #
	#-------------------------------------------------------------#

	def IsStzClassNameXT()
		
		if This.IsStzClassName() or This.IsStzClassNameInPluralForm()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsStzTypeXT()
			return This.IsStzClassNameXT()

		def IsStzClassXT()
			return This.IsStzClassNameXT()

		def IsAStzClassNameXT()
			return This.IsStzClassNameXT()

		def IsAStzTypeXT()
			return This.IsStzClassNameXT()

		def IsAStzClassXT()
			return This.IsStzClassNameXT()

		#>

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE PLURAL FORM OF A GIVEN SOFTANZA TYPE  #
	#----------------------------------------------------------------------#

	def IsPluralOfThisStzType(cType)

		if Q(cType).IsAStzType() and
		   PluralOfThisStzType(cType) = This.String()

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsPluralOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsPluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsPluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#--

		def IsThePluralFormOfThisStzType(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClassName(cType)
			return This.IsPluralOfThisStzType()

		def IsThePluralFormOfThisStzClass(cType)
			return This.IsPluralOfThisStzType()

		#>

	   #==================================================#
	  #  SITTING ON A GIVEN POSITION (OR SECTION) AND    #
	 #  THEN HARVESTING N CHARS BEORE AND N CHARS LEFT  #
	#==================================================#

	def Sit(paPositionOrSection, paHarvest)
		/* EXAMPLE

		o1 = new stzString("what a <<nice>>> day!")

		o1.Sit(
			:OnSection = [10, 13],
			:Harvest = [ :NCharsBefore = 2, :NCharsAfter = 3 ]
		)

		#--> [ "<<", ">>>" ]

		*/

		if isList(paPositionOrSection) and
			Q(paPositionOrSection).IsOneOfTheseNamedParams([
				:On, :OnPosition, :OnSection,
				:Position, :Section
			])

			paPositionOrSection = paPositionOrSection[2]
		ok

		if isNumber(paPositionOrSection)

			aTemp = []
			aTemp + paPositionOrSection
			aTemp + paPositionOrSection

			paPositionOrSection = aTemp
		ok

		if NOT ( isList(paPositionOrSection) and
			 Q(paPositionOrSection).IsPairOfNumbers() )

			stzRaise("Incorrect param! paPositionOrSection must be a position (number) or a section (pair of numbers).")
		ok

		aSection = paPositionOrSection
		bReturnSections = FALSE

		if isList(paHarvest) and
		   Q(paHarvest).IsOneOfTheseNamedParams([

				:Harvest, :AndHarvest,
				:AndThenHarvest, :ThenHarvest,

				:Yield, :AndYield,
				:AndThenYield, :ThenYield,

				:HarvestSection, :AndHarvestSection,
				:AndThenHarvestSection, :ThenHarvestSection,

				:YieldSection, :AndYieldSection,
				:AndThenYieldSection, :ThenYieldSection,

				:HarvestSections, :AndHarvestSections,
				:AndThenHarvestSections, :ThenHarvestSections,

				:YieldSections, :AndYieldSections,
				:AndThenYieldSections, :ThenYieldSections ])

			if Q(paHarvest[1]).ContainsCS(:Section, :CS = FALSE)
				bReturnSections = TRUE
			ok

			paHarvest = paHarvest[2]
		ok

		if NOT len(paHarvest) = 2
			stzRaise("Incorrect param! paHarvest must be a list of 2 items.")
		ok

		if isList(paHarvest[1]) and Q(paHarvest[1]).IsNCharsBeforeNamedParam()
			paHarvest[1] = paHarvest[1][2]
		ok

		if isList(paHarvest[2]) and Q(paHarvest[2]).IsNCharsAfterNamedParam()
			paHarvest[2] = paHarvest[2][2]
		ok

		if NOT BothAreNumbers(paHarvest[1], paHarvest[2])
			stzRaise("Incorrect param! paHarvest must be a pair of numbers.")
		ok

		nCharsBefore = paHarvest[1]
		if nCharsBefore > aSection[1] - 1
			nCharsBefore = aSection[1] - 1
		ok

		nCharsAfter  = paHarvest[2]
		if nCharsAfter > This.NumberOfChars() - aSection[2]
			nCharsAfter = This.NumberOfChars() - aSection[2]
		ok

		anSectionBefore = [0, 0]

		if nCharsBefore != 0
			anSectionBefore[1] = (aSection[1] - nCharsBefore)
			anSectionBefore[2] = (aSection[1] - 1)
		ok

		anSectionAfter = [0, 0]
		if anSectionAfter != 0
			anSectionAfter[1] = (aSection[2] + 1)
			anSectionAfter[2] = (aSection[2] + nCharsAfter)
		ok

		if bReturnSections
			aResult = [ anSectionBefore, anSectionAfter ]
			
		else
			aResult = This.Sections([ anSectionBefore, anSectionAfter ])
		ok

		return aResult

		def Settle(paPositionOrSection, paHervest)
			return Sit(paPositionOrSection, paHervest)

		def Enclose(paSection, paHervest)
			return Sit(paSection, paHervest)

	  #==============================#
	 #     BOUNDS OF THE STRING     #
	#==============================#

	// Verifies if the string is bounded by substrings 1 and 2 
	def IsBoundedByCS(pacBounds, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("--")
		? o1.IsBoundedBy("-") #--> TRUE

		o1 = new stzString("-_")
		? o1.IsBoundedBy([ "-", "_" ]) #--> TRUE

		*/

		# Managing this special syntax:
		# ? Q("").IsBoundedBy([ "-", :In = "--" ])

		if isList(pacBounds) and Q(pacBounds).IsPair() and
		   isList(pacBounds[2]) and Q(pacBounds[2]).IsPair()

			if Q(pacBounds[2]).IsInNamedParam()
				return This.IsBoundedByInCS(pacBounds[1], :In = pacBounds[2], pCaseSensitive)

			but Q(pacBounds[2]).IsAndNamedParam()
				pacBounds[2] = pacBounds[2][2]
			ok

		ok

		if isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a list of pairs.")
		ok

		if This.BeginsWithCS(cBound1, pCaseSensitive) and
		   This.EndsWithCS(cBound2, pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsBoundedBy(pacBounds)
		return This.IsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

	   #--------------------------------------------------------#
	  #  CHECKING IF THE STRING IS BOUNDED BY A GIVEN PAIR OF  #
	 #  SUBSTRINGS INSIDE A GIVEN STRING                      #
	#--------------------------------------------------------#

	# NOTE: There is a more elegant alternative I suggest to use: IsBoundeByXT()
	def IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("")
		? o1.IsBoundedByIn([ "-", "-" ], :In = "... -- ...")
		#--> TRUE

		*/

		if isString(pacBounds)
			aTemp = []
			aTemp + pacBounds + pacBounds

			pacBounds = aTemp
		ok

		if NOT ( isList(pacBounds) and Q(pacBounds).IsPairOfStrings() )
			StzRaise("Incorrect param type! paBounds must be a pair of strings.")
		ok


		if isList(pIn) and Q(pIn).IsInOrInsideNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pIn must be a string or list.")
		ok

		bResult = FALSE

		if isString(pIn)

			oStr = new stzString(pIn)
			bResult = oStr.SubStringIsBoundedByCS( This.String(), pacBounds, pCaseSensitive )

		but isList(pIn) and Q(pIn).IsListOfStrings()

			# TODO
			StzRaise("Currently, the function works only on one string. List of strings are not supported.")
		ok
	
		return bResult

		#< @FunctionAlternativeForms

		def IsBoundedByCSIB(pacBounds, pIn, pCaseSensitive)
			return This.IsBoundedByInCS(pacBounds, pIn, pCaseSensitive)

		def IsBetweenCSIB(pacBounds, pIn, pCaseSensitive)

			if NOT isList(pacBounds) and len(pacBounds) = 2
				StzRaise("Incorrect param! pacBounds must be a list of 2 items.")
			ok

			acBounds = []

			if isString(pacBounds[1])
				acBounds + pacBounds[1]
			ok

			if isString(pacBounds[2])
				acBounds + pacBounds[2]

			but isList(pacBounds[2]) and
			   Q(pacBounds[2]).IsAndNamedParam() and
			   isString(pacBounds[2][2])

				acBounds + pacBounds[2][2]
				
			ok

			if NOT Q(acBounds).IsPairOfStrings()
				StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
			ok

			bResult = This.IsBoundedByInCS(acBounds, pIn, pCaseSensitive)

			return bResult
		#>


	#-- WITHOUT CASESENSITIVITY

	def IsBoundedByIn(pacBounds, pIn)
		return This.IsboundedByInCS(pacBounds, pIn, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def IsBoundedByIB(pacBounds, pIn)
			return This.IsBoundedByIn(pacBounds, pIn)

		def IsBetweenIB(pacBounds, pIn)
			return This.IsBetweenCSIB(pacBounds, pIn, :CaseSensitive = TRUE)

		#>

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDING OF A GIVEN STRING INSIDE ANOTHER STRING  #
	#------------------------------------------------------------------------------#

	def IsBoundOfCS(pcSubStr, pcInStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("_")
		? o1.IsBoundOf("world", :In = "hello _world_ and <world>!")
		#--> TRUE
		*/

		pcStr = pcInStr[2]
		acBounds = Q(pcStr).BoundsOfCS(pcSubStr, :UpToNChars = This.NumberOfChars(), pCaseSensitive )
		#--> [ [ "_", "_" ], [ "<", ">" ] ]

		bResult = Q(acBounds).Contains( [ This.String(), This.String() ] )
		return bResult

	#-- WITHOUT CASESNESITUVURT

	def IsBoundOf(pcSubStr, pcInStr)
		bResult = This.IsBoundOfCS(pcSubStr, pcInStr, :CaseSensitive = TRUE)
		return bResult

	def IsFirstBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).FirstBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsLastBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LastBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

		def IsSecondBoundOfCS(pcOtherStr, pCaseSensitive)
			return This.IsLastBoundOfCS(pcOtherStr, pCaseSensitive)

	def IsLeftBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).LeftBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	def IsRightBoundOfCS(pcOtherStr, pCaseSensitive)
		if Q(pcOtherStr).RightBoundsCS().IsEqualToCS(This.String(), pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

	  #------------------------------------#
	 #     ADDING BOUNDS TO THE STRING    #
	#------------------------------------#

	def AddBounds(pacBounds)
		if isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			cBound1 = pacBounds[1]
			cBound2 = pacBounds[2]

		but isString(pacBounds)
			cBound1 = pacBounds
			cBound2 = pacBounds

		else
			StzString("Incorrect param type! pacBounds mus tbe a string or pair of strings.")
		ok

		cResult = cBound1 + This.String() + cBound2
		This.UpdateWith( cResult )

		def AddBoundsQ(pacBounds)
			This.AddBounds(pacBounds)
			return This

		def BoundWith(pacBounds)
			This.AddBounds(pacBounds)

			def BoundWithQ(pacBounds)
				This.BoundWith(pacBounds)
				return This

	def StringWithBoundsAdded(pacBounds)
		cResult = This.Copy().AddBoundsQ(pacBounds).Content()

		def StringBoundedWith(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

		def BoundedWith()
			return This.StringWithBoundsAdded(pacBounds)

		def BoundsAdded()
			return This.StringWithBoundsAdded(pacBounds)

		def StringBoundedBy(pacBounds)
			return This.StringWithBoundsAdded(pacBounds)

	  #--------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY TWO OTHER SUBSTRINGS  #
	#--------------------------------------------------------------------#

	def SubStringIsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		/* EXAMPLES

		o1 = new stzString("aaaaa bbbbb")
		
		? o1.SubStringIsBoundedBy("", "aa") #--> TRUE

		? o1.SubStringIsBoundedBy("", "bb") #--> TRUE
		
		? o1.SubStringIsBoundedBy("", [ "aa", "aaa" ] ) #--> TRUE

		*/

		if CheckParams() = TRUE
			if isList(pacBounds)
				if len(pacBounds) != 2
					pacBounds = Q(pacBounds).Pairified()
				ok

			but isString(pacBounds)
				aTemp = []
				aTemp  + pacBounds + pacBounds
				pacBounds = aTemp
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
		ok

		# Doing the job

		nLen1 = Q(pacBounds[1]).NumberOfChars()
		nLen2 = Q(pacBounds[2]).NumberOfChars()

		aSections = This.FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)

		bResult = FALSE

		for i = 1 to nLen

			acEffectiveBounds = This.Sit( :OnSection = aSections[i], :AndYield = [ nLen1, nLen2 ])

			if Q(acEffectiveBounds[1]).IsEqualToCS(pacBounds[1], pCaseSensitive) and
			   Q(acEffectiveBounds[2]).IsEqualToCS(pacBounds[2], pCaseSensitive)

				bResult = TRUE
				exit
			ok
		next

		return bResult
		

	def SubStringIsBoundedBy(pcSubStr, pacBounds)
		return This.SubStringIsBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN SUBSTRING IS BOUNDED BY MANY PAIRS OF SUBSTRINGS  #
	#------------------------------------------------------------------------#
	
	def SubStringIsBoundedByManyCS(pcSubStr, pacPairsOfBounds, pCaseSensitive)
		/* EXAMPLE

		? o1.SubStringIsBoundedBy("", [ [ "aa","aaa" ], ["bb","bbb"] ]) #--> TRUE

		*/

		if NOT isList(pacPairsOfBounds)
			StzRaise("Incorrect param type! pacPairsOfBounds must be a list.")
		ok

		bResult = TRUE
		
		nLen = len(pacPairsOfBounds)
		for i = 1 to nLen
			if NOT This.SubStringIsBoundedByCS(pcSubStr, pacPairsOfBounds[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsBoundedByMany(pacSubStr, pacPairsOfBounds)
		return This.SubStringIsBoundedByManyCS(pacSubStr, pacPairsOfBounds, :CaseSensitive = TRUE)

	  #=============================================================================#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING BY RETURNING THEIR SECTIONS  #
	#=============================================================================#

	def FindBoundsAsSectionsCS(pCaseSensitive)

		aResult = [
			This.FindLeadingCharsAsSectionCS(pCaseSensitive),
			This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

		def FindFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsAsSectionsCS(pCaseSensitive)
			return This.FindBoundsAsSectionsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsAsSectionsCS(pCaseSensitive)
				return This.FindBoundsAsSectionsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBoundsAsSections()
		return This.FindBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringBoundsAsSections()
			return This.FindBoundsAsSections()

		def FindFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindFirstAndLastStringBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindFirstAndSecondStringBoundsAsSections()
				return This.FindBoundsAsSections()
	
		def FindStringFirstAndLastBoundsAsSections()
			return This.FindBoundsAsSections()

			def FindStringFirstAndSecondBoundsAsSections()
				return This.FindBoundsAsSections()
	
		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsAsSectionCS(pCaseSensitive),
			This.FindLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBoundsAsSections()
		return This.FindLastAndFirstBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringLastAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		def FindStringSecondAndFirstBoundsAsSections()
			return This.FindLastAndFirstBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSectionsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLeftAndRightBoundsAsSections()
		return This.FindLeftAndRightBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLeftAndRightBoundsAsSections()
			return This.FindLeftAndRightBoundsAsSections()

		#>

	  #-------------------------------------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUBDS (IF ANY) OF THE STRING AND RETURNING THEIR SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsAsSectionCS(pCaseSensitive)
			a2 = This.FindTrailingCharsAsSectionCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSectionsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRightAndLeftBoundsAsSections()
		return This.FindRightAndLeftBoundsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringRightAndLeftBoundsAsSections()
			return This.FindRightAndLeftBoundsAsSections()

		#>

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS BOUNDED (HAS BOUNDS)  #
	#==================================================#

	def IsBoundedCS(pCaseSensitive)
		if len(This.BoundsCS(pCaseSensitive)) > 0
			return TRUE
		else
			return FALSE
		ok

		def HasBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

		def ContainsBoundsCS(pCaseSensitive)
			return This.HasBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsBounded()
		return This.IsBoundedCS(:CaseSensitive = TRUE)

		def HasBounds()
			return This.IsBounded()

		def ContainsBounds()
			return This.HasBounds()

	  #-------------------------------------------------#
	 #  FINDING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def FindBoundsCS(pCaseSensitive)

		aResult = [
			This.FindLeadingCharsCS(pCaseSensitive),
			This.FindTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

		def FindFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindFirstAndLastStringBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindFirstAndSecondStringBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		def FindStringFirstAndLastBoundsCS(pCaseSensitive)
			return This.FindBoundsCS(pCaseSensitive)

			def FindStringFirstAndSecondBoundsCS(pCaseSensitive)
				return This.FindBoundsCS(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBounds()
		return This.FindBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringBounds()
			return This.FindBounds()

		def FindFirstAndLastBounds()
			return This.FindBounds()

			def FindFirstAndSecondBounds()
				return This.FindBounds()
	
		def FindFirstAndLastStringBounds()
			return This.FindBounds()

			def FindFirstAndSecondStringBounds()
				return This.FindBounds()
	
		def FindStringFirstAndLastBounds()
			return This.FindBounds()

			def FindStringFirstAndSecondBounds()
				return This.FindBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLastAndFirstBoundsCS(pCaseSensitive)

		aResult = [
			This.FindTrailingCharsCS(pCaseSensitive),
			This.FindLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringLastAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		def FindStringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.FindLastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAndFirstBounds()
		return This.FindLastAndFirstBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringLastAndFirstBounds()
			return This.FindLastAndFirstBounds()

		def FindStringSecondAndFirstBounds()
			return This.FindLastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  FINDING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindLeftAndRightBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)

		else
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.This.FindTrailingCharsCS(pCaseSensitive)
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringLeftAndRightBoundsCS(pCaseSensitive)
			return This.FindLeftAndRightBoundsCS(pCaseSensitive)

	#--

	def FindLeftAndRightBounds()
		return This.FindLeftAndRightBoundsCS(:CaseSensitive = TRUE)

		def FindStringLeftAndRightBounds()
			return This.FindLeftAndRightBounds()

	  #--------------------------------------------------------#
	 #  FINDING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def FindRightAndLeftBoundsCS(pCaseSensitive)

		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FindLeadingCharsCS(pCaseSensitive)
			a2 = This.FindTrailingCharsCS(pCaseSensitive)

		else
			a1 = This.This.FindTrailingCharsCS(pCaseSensitive)
			a2 = This.FindLeadingCharsCS(pCaseSensitive)
			
		ok

		aResult = [ a1, a2 ]

		return aResult

		def FindStringRightAndLeftBoundsCS(pCaseSensitive)
			return This.FindRightAndLeftBoundsCS(pCaseSensitive)

	#--

	def FindRightAndLeftBounds()
		return This.FindRightAndLeftBoundsCS(:CaseSensitive = TRUE)

		def FindStringRightAndLeftBounds()
			return This.FindRightAndLeftBounds()

	  #-------------------------------------------------#
	 #  GETTING THE TWO BOUNDS (IF ANY) OF THE STRING  #
	#=================================================#

	def BoundsCS(pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("<<Ring>>")
		? o1.Bounds()
		#--> [ "<<", ">>" ]

		EXAMPLE 2

		o1 = new stzString("---Ring___")
		? o1.Bounds()
		#--> [ "---, "___" ]

		*/

		acResult = []

		if This.ContainsLeadingAndTrailingCharsCS(pCaseSensitive)

			acResult = [
				This.LeadingCharsAsStringCS(pCaseSensitive),
				This.TrailingCharsAsStringCS(pCaseSensitive)
			]
		ok

		return acResult

		#< @FunctionAlternativeForms

		def StringBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def FirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		def StringFirstAndLastBoundsCS(pCaseSensitive)
			return This.BoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Bounds()
		return This.BoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def StringBounds()
			return This.Bounds()

		def FirstAndLastBounds()
			return This.Bounds()

		def StringFirstAndLastBounds()
			return This.Bounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LastAndFirstBoundsCS(pCaseSensitive)
		acResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FirstBoundCS(pCaseSensitive)
		]

		return acResult

		#< @FunctionAlternatoveForms

		def SecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringLastAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		def StringSecondAndFirstBoundsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBounds()
		return This.LastAndFirstBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternatoveForms

		def SecondAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringLastAndFirstBounds()
			return This.LastAndFirstBounds()

		def StringSecondAndFirstBounds()
			return This.LastAndFirstBounds()

		#>

	  #--------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def LeftAndRightBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = This.LastBoundCS(pCaseSensitive)

		else
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = Thus.FirstBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringLeftAndRightBoundsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBounds()
		return This.LeftAndRightBoundsCS(:CaseSensitive = TRUE)

		def StringLeftAndRightBounds()
			return This.LeftAndRightBoundsCS()

	  #--------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS (IF ANY) OF THE STRING  #
	#--------------------------------------------------------#

	def RightAndLeftBoundsCS(pCaseSensitive)
		a1 = []
		a2 = []

		if This.IsLeftToRight()
			a1 = This.LastBoundCS(pCaseSensitive)
			a2 = This.FirstBoundCS(pCaseSensitive)

		else
			a1 = This.FirstBoundCS(pCaseSensitive)
			a2 = Thus.LastBoundCS(pCaseSensitive)

		ok

		acResult = [ a1, a2 ]

		return acResult

		def StringRightAndLeftBoundsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBounds()
		return This.RightAndLeftBoundsCS(:CaseSensitive = TRUE)

		def StringRightAndLeftBounds()
			return This.RightAndLeftBoundsCS()

	  #------------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#========================================================================#

	def BoundsCSZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def FirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZ(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.BoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZ()
		return This.BoundsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirPositions()
			return This.BoundsZ()

		def StringBoundsZ()
			return This.BoundsZ()

		def StringBoundsAndTheirPositions()
			return This.BoundsZ()

		#--

		def FirstAndLastBoundsZ()
			return This.BoundsZ()

		def FirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		def StringFirstAndLastBoundsZ()
			return This.BoundsZ()

		def StringFirstAndLastBoundsAndTheirPositions()
			return This.BoundsZ()

		#>

	  #-----------------------------------------------------------------------#
	 #  GETTING THE BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#-----------------------------------------------------------------------#

	def BoundsCSZZ(pCaseSensitive)

		aResult = Association([
			This.BoundsCS(pCaseSensitive),
			This.FindBoundsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		#< @FunctionAlternativeForms

		def BoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#--

		def FirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def FirstAndLastBoundsAndThierSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsCSZZ(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		def StringFirstAndLastBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.BoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BoundsZZ()
		return This.BoundsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsAndTheirSections()
			return This.BoundsZZ()

		def StringBoundsZZ()
			return This.BoundsZZ()

		def StringBoundsAndTheirSrctions()
			return This.BoundsZZ()

		#--

		def FirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def FirstAndLastBoundsAndThierSections()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsZZ()
			return This.BoundsZZ()

		def StringFirstAndLastBoundsAndTheirSections()
			return This.BoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirPositionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZ()
		return This.LastAndFirstBoundsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

		def LastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def SecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsZ()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsZ()
				return This.LastAndFirstBoundsZ()
	
		def StringLastAndFirstBoundsAndTheirPositions()
			return This.LastAndFirstBoundsZ()

			def StringSecondAndFirstBoundsAndTheirPositions()
				return This.LastAndFirstBoundsZ()
	
		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LAST AND FIRST BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LastAndFirstBoundsCSZZ(pCaseSensitive)

		aLast = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		aFirst = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		aResult = [ aLast, aFirst ]

		return aResult

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		def LastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def SecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsCSZZ(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsCSZZ(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		def StringLastAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

			def StringSecondAndFirstBoundsAndTheirSectionsCS(pCaseSensitive)
				return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def LastAndFirstBoundsZZ()
		return This.LastAndFirstBoundsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

		def LastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def SecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsZZ()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsZZ()
				return This.LastAndFirstBoundsZZ()
	
		def StringLastAndFirstBoundsAndTheirSections()
			return This.LastAndFirstBoundsZZ()

			def StringSecondAndFirstBoundsAndTheirSections()
				return This.LastAndFirstBoundsZZ()

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZ()
		return This.LeftAndrightBoundsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsZ()
			return This.LeftAndRightBoundsZ()

		def StringLeftAndRightBoundsAndTheirPositions()
			return This.LeftAndRightBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING LEFT AND RIGHT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def LeftAndRightBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)

		else
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)
		ok


		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsCSZZ(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		def StringLeftAndRightBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.LeftAndRightBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftAndRightBoundsZZ()
		return This.LeftAndRightBoundsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndrightBoundsZZ()
			return This.LeftAndRightBoundsZZ()

		def StringLeftAndRightBoundsAndTheirSections()
			return This.LeftAndRightBoundsZZ(pCaseSensitive)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR POSITIONS  #
	#-----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirPositionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZ()
		return This.RightAndLeftBoundsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsZ()
			return This.RightAndLeftBoundsZ()

		def StringRightAndLeftBoundsAndTheirPositions()
			return This.RightAndLeftBoundsZ()

		#>

	  #----------------------------------------------------------------------------------#
	 #  GETTING RIGHT AND LEFT BOUNDS OF THE STRING (IF ANY) ALONG WITH THEIR SECTIONS  #
	#----------------------------------------------------------------------------------#

	def RightAndLeftBoundsCSZZ(pCaseSensitive)

		if This.IsLeftToRight()
			return This.LastAndFirstBoundsCSZZ(pCaseSensitive)

		else
			return This.FirstAndLastBoundsCSZZ(pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
		return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsCSZZ(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		def StringRightAndLeftBoundsAndTheirSectionsCS(pCaseSensitive)
			return This.RightAndLeftBoundsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightAndLeftBoundsZZ()
		return This.RightAndLeftBoundsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightAndLeftBoundsAndTheirSections()
		return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsZZ()
			return This.RightAndLeftBoundsZZ()

		def StringRightAndLeftBoundsAndTheirSections()
			return This.RightAndLeftBoundsZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING  #
	#=========================================#

	def FindFirstBoundCS(pCaseSensitive)
		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			return 1
		else
			return 0
		ok

		def FindStringFirstBoundCS(pCaseSensitive)
			return This.FindFirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBound()
		return This.FindFirstBoundCS(:CaseSensitive = TRUE)

		def FindStringFirstBound()
			return This.FindFirstBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfLeadingCharsCS(pCaseSensitive)
		if n > 0
			anResult + 1 + n
		ok

		return anResult

		def FindStringFirstBoundAsSectionCS(pCaseSensitive)
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBoundAsSection()
		return This.FindFirstBoundAsSectionCS(:CaseSensitive = TRUE)

		def FindStringFirstBoundAsSection()
			return This.FindFirstBoundAsSection()

	  #-----------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING  #
	#-----------------------------------------#

	def FirstBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[1]
		return cResult

		def StringFirstBoundCS(pCaseSensitive)
			return This.FirstBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FirstBound()
		return This.FirstBoundCS(:CaseSensitive = TRUE)

		def StringFirstBound()
			return This.FirstBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def FirstBoundCSZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundCSZ(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		def StringFirstBoundAndItsPositionCS(pCaseSensitive)
			return This.FirstBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZ()
		return This.FirstBoundCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsPosition()
			return This.FirstBoundZ()

		def StringFirstBoundZ()
			return This.FirstBoundZ()

		def StringFirstBoundAndItsPosition()
			return This.FirstBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE FIRST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def FirstBoundCSZZ(pCaseSensitive)
		aResult = [
			This.FirstBoundCS(pCaseSensitive),
			This.FindFirstBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundCSZZ(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		def StringFirstBoundAndItsSectionCS(pCaseSensitive)
			return THis.FirstBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstBoundZZ()
		return This.FirstBoundCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FirstBoundAndItsSection()
			return This.FirstBoundZZ()

		def StringFirstBoundZZ()
			return THis.FirstBoundZZ()

		def StringFirstBoundAndItsSection()
			return THis.FirstBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING  #
	#========================================#

	def FindLastBoundCS(pCaseSensitive)
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			return This.NumberOfChars() - n + 1
		else
			return 0
		ok

		#< @FunctionAlternativeForms

		def FindStringLastBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		def FindStringSecondBoundCS(pCaseSensitive)
			return This.FindLastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBound()
		return This.FindLastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBound()
			return This.FindLastBound()

		def FindSecondBound()
			return This.FindLastBound()

		def FindStringSecondBound()
			return This.FindLastBound()

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastBoundAsSectionCS(pCaseSensitive)

		anResult = []

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			nLen = This.NumberOfChars()
			anResult + (nLen - n + 1) + nLen
		ok

		return anResult

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		def FindStringSecondBoundAsSectionCS(pCaseSensitive)
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBoundAsSection()
		return This.FindLastBoundAsSectionCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindStringLastBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		def FindStringSecondBoundAsSection()
			return This.FindLastBoundAsSection()

		#>

	  #----------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING  #
	#----------------------------------------#

	def LastBoundCS(pCaseSensitive)
		cResult = This.BoundsCS(pCaseSensitive)[2]
		return cResult

		#< @FunctionAlternativeForms

		def StringLastBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def SecondBoundCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		def StringSecondBoundsCS(pCaseSensitive)
			return This.LastBoundCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBound()
		return This.LastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def StringLastBounds()
			return This.LastBound()

		def SecondBound()
			return This.LastBound()

		def StringSecondBounds()
			return This.LastBound()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LastBoundCSZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZ(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def LastBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		def SecondBoundAndItsPositionCS(pCaseSensitive)
			return This.LastBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZ()
		return This.LastBoundCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZ()
			return This.LastBoundZ()

		def LastBoundAndItsPosition()
			return This.LastBoundZ()

		def SecondBoundAndItsPosition()
			return This.LastBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LAST BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LastBoundCSZZ(pCaseSensitive)
		aResult = [
			This.LastBoundCS(pCaseSensitive),
			This.FindLastBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def SecondBoundCSZZ(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def LastBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		def SecondBoundAndItsSectionCS(pCaseSensitive)
			return This.LastBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastBoundZZ()
		return This.LastBoundCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SecondBoundZZ()
			return This.LastBoundZZ()

		def LastBoundAndItsSection()
			return This.LastBoundZZ()

		def SecondBoundAndItsSection()
			return This.LastBoundZZ()

		#>

	  #----------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING  #
	#========================================#

	def FindLeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundCS(pCaseSensitive)
		ok


		def FindStringLeftBoundCS(pCaseSensitive)
			return This.FindLeftBoundCS(pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindLeftBound()
		return This.FindLeftBoundCS(:CaseSensitive = TRUE)


		def FindStringLeftBound()
			return This.FindLeftBound()

	  #------------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLeftBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToLeft()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)
		ok


		def FindStringLeftBoundAsSectionCS(pCaseSensitive)
			return This.FindLeftBoundAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLeftBoundAsSection()
		return This.FindLeftBoundAsSectionCS(:CaseSensitive = TRUE)


		def FindStringLeftBoundAsSection()
			return This.FindLeftBoundAsSection()

	  #----------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING  #
	#----------------------------------------#

	def LeftBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[1]

		else # case IsRightToLeft()
			return This.BoundsCS(pCaseSensitive)[2]
		ok


		def StringLeftBoundCS(pCaseSensitive)
			return This.LeftBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def LeftBound()
		return This.LeftBoundCS(:CaseSensitive = TRUE)

		def StringLeftBound()
			return This.LeftBound()

	  #----------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#----------------------------------------------------------------#

	def LeftBoundCSZ(pCaseSensitive)
		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundCSZ(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		def StringLeftBoundAbdItsPositionCS(pCaseSensitive)
			return This.LeftBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZ()
		return This.LeftBoundCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsPosition()
			return This.LeftBoundZ()

		def StringLeftBoundZ()
			return This.LeftBoundZ()

		def StringLeftBoundAbdItsPosition()
			return This.LeftBoundZ()

		#>

	  #---------------------------------------------------------------#
	 #  GETTING THE LEFT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#---------------------------------------------------------------#

	def LeftBoundCSZZ(pCaseSensitive)

		aResult = [
			This.LeftBoundCS(pCaseSensitive),
			This.FindLeftBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundCSZZ(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		def StringLeftBoundAbdItsSectionCS(pCaseSensitive)
			return This.LeftBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LeftBoundZZ()
		return This.LeftBoundCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundAndItsSection()
			return This.LeftBoundZZ()

		def StringLeftBoundZZ()
			return This.LeftBoundZZ()

		def StringLeftBoundAbdItsSection()
			return This.LeftBoundZZ()

		#>

	  #-----------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING  #
	#=========================================#

	def FindRightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundCS(pCaseSensitive)
		ok


		def FindStringRightBoundCS(pCaseSensitive)
			return This.FindRightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRightBound()
		return This.FindRightBoundCS(:CaseSensitive = TRUE)

		def FindStringRightBound()
			return This.FindRightBound()

	  #-------------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUND OF THE STRING AND RETURNING ITS POSITION AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindRightBoundAsSectionCS(pCaseSensitive)

		if This.IsLeftToRight()
			return This.FindLastBoundAsSectionCS(pCaseSensitive)

		else # case IsRightToRight()
			return This.FindFirstBoundAsSectionCS(pCaseSensitive)
		ok


		def FindStringRightBoundAsSectionCS(pCaseSensitive)
			return This.FindRightBoundAsSectionCS(pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindRightBoundAsSection()
		return This.FindRightBoundAsSectionCS(:CaseSensitive = TRUE)


		def FindStringRightBoundAsSection()
			return This.FindRightBoundAsSection()

	  #-----------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING  #
	#-----------------------------------------#

	def RightBoundCS(pCaseSensitive)
		if This.IsLeftToRight()
			return This.BoundsCS(pCaseSensitive)[2]

		else # case IsRightToRight()
			return This.BoundsCS(pCaseSensitive)[1]
		ok

		def StringRightBoundCS(pCaseSensitive)
			return This.RightBoundCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RightBound()
		return This.RightBoundCS(:CaseSensitive = TRUE)

		def StringRightBound()
			return This.RightBound()

	  #-----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS POSITION  #
	#-----------------------------------------------------------------#

	def RightBoundCSZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundCSZ(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		def StringRightBoundAndItsPositionCS(pCaseSensitive)
			return This.RightBoundCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZ()
		return This.RightBoundCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsPosition()
			return This.RightBoundZ()

		def StringRightBoundZ()
			return This.RightBoundZ()

		def StringRightBoundAndItsPosition()
			return This.RightBoundZ()

		#>

	  #----------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUND OF THE STRING ALONG WITH ITS SECTION  #
	#----------------------------------------------------------------#

	def RightBoundCSZZ(pCaseSensitive)
		aResult = [
			This.RightBoundCS(pCaseSensitive),
			This.FindRightBoundAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundCSZZ(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		def StringRightBoundAndItsSectionCS(pCaseSensitive)
			return This.RightBoundCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RightBoundZZ()
		return This.RightBoundCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightBoundAndItsSection()
			return This.RightBoundZZ()

		def StringRightBoundZZ()
			return This.RightBoundZZ()

		def StringRightBoundAndItsSection()
			return This.RightBoundZZ()

		#>

	  #---------------------------------#
	 #  REMOVING BOUNDS OF THE STRING  #
	#=================================#

	def RemoveStringBoundsCS(pCaseSensitive)

		if This.IsBoundedCS(pCaseSensitive)
			aSections = This.FindStringBoundsAsSectionsCS(pCaseSensitive)
			This.RemoveSections(aSections)
		ok

		#< @FunctionFluentForm

		def RemoveStringBoundsCSQ(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveBoundsCSQ(pCaseSensitive)
				This.RemoveBoundsCS(pCaseSensitive)
				return This
	
		#--

		def RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveStringFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveStringFirstAndLastBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndLastBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndLastBoundsCS(pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveFirstAndSecondBoundsCSQ(pCaseSensitive)
				This.RemoveFirstAndSecondBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveStringSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLastAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveLastAndFirstBoundsCS(pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveSecondAndFirstBoundsCSQ(pCaseSensitive)
				This.RemoveSecondAndFirstBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveStringLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveLeftAndRightBoundsCSQ(pCaseSensitive)
				This.RemoveLeftAndRightBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveStringRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveStringRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsCS(pCaseSensitive)
			This.RemoveStringBoundsCS(pCaseSensitive)

			def RemoveRightAndLeftBoundsCSQ(pCaseSensitive)
				This.RemoveRightAndLeftBoundsCS(pCaseSensitive)
				return This

		#>

	def StringBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveStringBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringFirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndLastBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringFirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def FirstAndSecondBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LastAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def StringSecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def SecondAndFirstBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringLeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def LeftAndRightBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#--

		def StringRightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		def RightAndLeftBoundsRemovedCS(pCaseSensitive)
			return This.StringBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringBounds()
		return This.RemoveStringBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringBoundsQ()
			This.RemoveStringBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBounds()
			This.RemoveStringBounds()

			def RemoveBoundsQ()
				This.RemoveBounds()
				return This
	
		#--

		def RemoveStringFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndLastBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		def RemoveStringFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveStringFirstAndSecondBoundsQ()
				This.RemoveStringFirstAndLastBounds()
				return This

		#--

		def RemoveFirstAndLastBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndLastBoundsQ()
				This.RemoveFirstAndLastBounds()
				return This

		def RemoveFirstAndSecondBounds()
			This.RemoveStringBounds()

			def RemoveFirstAndSecondBoundsQ()
				This.RemoveFirstAndSecondBounds()
				return This

		#--

		def RemoveStringLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringLastAndFirstBoundsQ()
				This.RemoveStringLastAndFirstBounds()
				return This

		def RemoveStringSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveStringSecondAndFirstBoundsQ()
				This.RemoveStringSecondAndFirstBounds()
				return This

		#--

		def RemoveLastAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveLastAndFirstBoundsQ()
				This.RemoveLastAndFirstBounds()
				return This

		def RemoveSecondAndFirstBounds()
			This.RemoveStringBounds()

			def RemoveSecondAndFirstBoundsQ()
				This.RemoveSecondAndFirstBounds()
				return This

		#--

		def RemoveStringLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveStringLeftAndRightBoundsQ()
				This.RemoveStringLeftAndRightBounds()
				return This

		#--

		def RemoveLeftAndRightBounds()
			This.RemoveStringBounds()

			def RemoveLeftAndRightBoundsQ()
				This.RemoveLeftAndRightBounds()
				return This

		#--

		def RemoveStringRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveStringRightAndLeftBoundsQ()
				This.RemoveStringRightAndLeftBounds()
				return This

		#--

		def RemoveRightAndLeftBounds()
			This.RemoveStringBounds()

			def RemoveRightAndLeftBoundsQ()
				This.RemoveRightAndLeftBounds()
				return This

		#>

	def StringBoundsRemoved()
		cResult = This.Copy().RemoveStringBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringFirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndLastBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringFirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		def FirstAndSecondBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def LastAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def StringSecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		def SecondAndFirstBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringLeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		def LeftAndRightBoundsRemoved()
			return This.StringBoundsRemoved()

		#--

		def StringRightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		def RightAndLeftBoundsRemoved()
			return This.StringBoundsRemoved()

		#>

	  #--------------------------------------#
	 #  REMOVING LEFT BOUND OF THE STRING   #
	#======================================#

	def RemoveStringLeftBoundCS(pCaseSensitive)
	
		cBounds = This.LeftBoundCS(pCaseSensitive)
		This.RemoveFromLeftCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundCSQ(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundCS(pCaseSensitive)
			This.RemoveStringLeftBoundCS(pCaseSensitive)

			def RemoveLeftBoundCSQ(pCaseSensitive)
				This.RemoveLeftBoundCS(pCaseSensitive)
				return This

		#>

	def StringLeftBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pCaseSensitive).Content()
		return cResult

		def LeftBoundRemovedCS(pCaseSensitive)
			return This.StringLeftBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLeftBound()
		This.RemoveStringLeftBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringLeftBoundQ()
			This.RemoveStringLeftBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBound()
			This.RemoveStringLeftBound()

			def RemoveLeftBoundQ()
				This.RemoveLeftBound()
				return This

		#>

	def StringLeftBoundRemoved()
		cResult = This.Copy().RemoveStringLeftBoundQ().Content()
		return cResult

		def LeftBoundRemoved()
			return This.StringLeftBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringRightBoundCS(pCaseSensitive)
	
		cBounds = This.RightBoundCS(pCaseSensitive)
		This.RemoveFromRightCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringRightBoundCSQ(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundCS(pCaseSensitive)
			This.RemoveStringRightBoundCS(pCaseSensitive)

			def RemoveRightBoundCSQ(pCaseSensitive)
				This.RemoveRightBoundCS(pCaseSensitive)
				return This

		#>

	def StringRightBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pCaseSensitive).Content()
		return cResult

		def RightBoundRemovedCS(pCaseSensitive)
			return This.StringRightBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringRightBound()
		This.RemoveStringRightBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringRightBoundQ()
			This.RemoveStringRightBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBound()
			This.RemoveStringRightBound()

			def RemoveRightBoundQ()
				This.RemoveRightBound()
				return This

		#>

	def StringRightBoundRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundQ().Content()
		return cResult

		def RightBoundRemoved()
			return This.StringRightBoundRemoved()

	  #---------------------------------------#
	 #  REMOVING FIRST BOUND OF THE STRING   #
	#---------------------------------------#

	def RemoveStringFirstBoundCS(pCaseSensitive)
	
		cBounds = This.FirstBoundCS(pCaseSensitive)
		This.RemoveFromStartCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundCSQ(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundCS(pCaseSensitive)
			This.RemoveStringFirstBoundCS(pCaseSensitive)

			def RemoveFirstBoundCSQ(pCaseSensitive)
				This.RemoveFirstBoundCS(pCaseSensitive)
				return This

		#>

	def StringFirstBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pCaseSensitive).Content()
		return cResult

		def FirstBoundRemovedCS(pCaseSensitive)
			return This.StringFirstBoundRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringFirstBound()
		This.RemoveStringFirstBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringFirstBoundQ()
			This.RemoveStringFirstBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBound()
			This.RemoveStringFirstBound()

			def RemoveFirstBoundQ()
				This.RemoveFirstBound()
				return This

		#>

	def StringFirstBoundRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundQ().Content()
		return cResult

		def FirstBoundRemoved()
			return This.StringFirstBoundRemoved()

	  #--------------------------------------#
	 #  REMOVING LAST BOUND OF THE STRING   #
	#--------------------------------------#

	def RemoveStringLastBoundCS(pCaseSensitive)
	
		cBounds = This.LastBoundCS(pCaseSensitive)
		This.RemoveFromEndCS(cBounds, pCaseSensitive)

		#< @FunctionFluentForm

		def RemoveStringLastBoundCSQ(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveLastBoundCSQ(pCaseSensitive)
				This.RemoveLastBoundCS(pCaseSensitive)
				return This


		def RemoveStringSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveStringSecondBoundCSQ(pCaseSensitive)
				This.RemoveStringSecondBoundCS(pCaseSensitive)
				return This

		def RemoveSecondBoundCS(pCaseSensitive)
			This.RemoveStringLastBoundCS(pCaseSensitive)

			def RemoveSecondBoundCSQ(pCaseSensitive)
				This.RemoveSecondBoundCS(pCaseSensitive)
				return This

		#>

	def StringLastBoundRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def StringSecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		def SecondBoundRemovedCS(pCaseSensitive)
			return This.StringLastBoundRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveStringLastBound()
		This.RemoveStringLastBoundCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveStringLastBoundQ()
			This.RemoveStringLastBound()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBound()
			This.RemoveStringLastBound()

			def RemoveLastBoundQ()
				This.RemoveLastBound()
				return This


		def RemoveStringSecondBound()
			This.RemoveStringLastBound()

			def RemoveStringSecondBoundQ()
				This.RemoveStringSecondBound()
				return This

		def RemoveSecondBound()
			This.RemoveStringLastBound()

			def RemoveSecondBoundQ()
				This.RemoveSecondBound()
				return This

		#>

	def StringLastBoundRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundRemoved()
			return This.StringLastBoundRemoved()

		def StringSecondBoundRemoved()
			return This.StringLastBoundRemoved()

		def SecondBoundRemoved()
			return This.StringLastBoundRemoved()

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR SECTIONS  #
	#====================================================================================#

	def FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsCSZZ(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1][2]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2][2]
		ok

		return aResult

		def FindTheseBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseStringBoundsAsSections(pcBound1, pcBound2)
		return This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindTheseBoundsAsSections(pcBound1, pcBound2)
			return This.FindTheseStringBoundsAsSections(pcBound1, pcBound2)

	  #------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING AND RETURNING THEIR SECTIONS  #
	#====================================================================================#

	def FindTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsCSZ(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1][2]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2][2]
		ok

		return aResult

		def FindTheseBoundsAsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseStringBounds(pcBound1, pcBound2)
		return This.FindTheseStringBoundsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindTheseBounds(pcBound1, pcBound2)
			return This.FindTheseStringBounds(pcBound1, pcBound2)

	  #-----------------------------------------------------------------------------#
	 #  GETTING THE GIVEN TWO BOUNDS (IF ANY) OF THE STRING ALONG THEIR POSITIONS  #
	#-----------------------------------------------------------------------------#

	def TheseStringBoundsCSZ(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsCSZ(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult +aBounds[2]
		ok

		return aResult

		def TheseBoundsCSZ(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsCSZ(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseStringBoundsZ(pcBound1, pcBound2)
		return This.TheseStringBoundsCSZ(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def TheseBoundsZ(pcBound1, pcBound2)
			return This.TheseStringBoundsZ(pcBound1, pcBound2)

	  #----------------------------------------------------------------------------#
	 #  GETTING THE GIVEN TWO BOUNDS (IF ANY) OF THE STRING ALONG THEIR SECTIONS  #
	#----------------------------------------------------------------------------#

	def TheseStringBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

		aBounds = This.StringBoundsCSZZ(pCaseSensitive)

		nLen = len(aBounds)
		if nLen = 0
			return []
		ok

		aResult = []

		cBound1 = aBounds[1][1]
		if StzStringQ(cBound1).IsEqualToCS(pcBound1, pCaseSensitive)
			aResult + aBounds[1]
		ok

		cBound2 = aBounds[2][1]
		if StzStringQ(cBound2).IsEqualToCS(pcBound2, pCaseSensitive)
			aResult + aBounds[2]
		ok

		return aResult

		def TheseBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsCSZZ(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def TheseStringBoundsZZ(pcBound1, pcBound2)
		return This.TheseStringBoundsCSZZ(pcBound1, pcBound2, :CaseSensitive = TRUE)

		def TheseBoundsZZ(pcBound1, pcBound2)
			return This.TheseStringBoundsZZ(pcBound1, pcBound2)


	  #--------------------------------------------------------#
	 #  REMOVING THE GIVEN TWO BOUNDS (IF ANY) IN THE STRING  #
	#========================================================#

	def RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindTheseStringBoundsAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveTheseStringBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, pCaseSensitive)

			def RemoveTheseBoundsCSQ(pcBound1, pcBound2, pCaseSensitive)
				This.RemoveTheseBoundsCS(pcBound1, pcBound2, pCaseSensitive)
				return This

		#>

	def TheseStringBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseStringBoundsCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def TheseBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)
			return This.TheseStringBoundsRemovedCS(pcBound1, pcBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseStringBounds(pcBound1, pcBound2)
		return This.RemoveTheseStringBoundsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveTheseStringBoundsQ(pcBound1, pcBound2)
			This.RemoveTheseStringBounds(pcBound1, pcBound2)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveTheseBounds(pcBound1, pcBound2)
			This.RemoveTheseStringBounds(pcBound1, pcBound2)

			def RemoveTheseBoundsQ(pcBound1, pcBound2)
				This.RemoveTheseBounds(pcBound1, pcBound2)
				return This

		#>

	def TheseStringBoundsRemoved(pcBound1, pcBound2)
		cResult = This.Copy().RemoveTheseStringBoundsQ(pcBound1, pcBound2).Content()
		return cResult

		#< @FunctionAlternativeForm

		def TheseBoundsRemoved(pcBound1, pcBound2)
			return This.TheseStringBoundsRemoved(pcBound1, pcBound2)

		#>

	  #---------------------------------#
	 #  SWAPPING BOUNDS OF THE STRING  #
	#=================================#

	def SwapBoundsCS(pCaseSensitive)
		aSections = This.FindBoundsAsSectionsCS(pCaseSensitive)
		This.SwapSections( aSections[1], aSections[2] )

		#< @FunctionFluentForm

		def SwapBoundsCSQ(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBoundsCS(pCaseSensitive)
			This.SwapBoundsCS(pCaseSensitive)

			def SwapStringBoundsCSQ(pCaseSensitive)
				This.SwapStringBoundsCS(pCaseSensitive)
				return This

		#>

	def BoundsSwappedCS(pCaseSensitive)
		cResult = This.Copy(). SwapBoundsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SwapBounds()
		return This.SwapBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SwapBoundsQ()
			This.SwapBounds()
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapStringBounds()
			This.SwapBounds()

			def SwapStringBoundsQ()
				This.SwapStringBounds()
				return This

		#>

	def BoundsSwapped()
		cResult = This.Copy(). SwapBoundsQ().Content()
		return cResult

		def StringBoundsSwapped()
			return This.BoundsSwapped()


	  #=========================================================#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

			#--

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		def FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBoundsAsSections(pcSubStr)
		return This.FindSubStringBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindBoundsOfAsSections(pcSubStr)
			return This.FindSubStringBoundsAsSections(pcSubStr)

	  #---------------------------------------------------------#
	 #  FINDING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------#

	def FindSubStringBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		def FindBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringBounds(pcSubStr)
		return This.FindSubStringBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindBoundsOf(pcSubStr)
			return This.FindSubStringBounds(pcSubStr)

	  #---------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS BOUNDS OF A GIVEN SUBSTRING  #
	#---------------------------------------------------------------#

	def ContainsBoundsOfCS(pcSubStr, pCaseSensitive)
		if len( This.BoundsOfCS(pcSubStr, pCaseSensitive) ) > 0
			return TRUE

		else
			return FALSE
		ok

		def SubStringIsBoundedCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

		def SubStringHasBoundsCS(pcSubStr, pCaseSensitive)
			return This.ContainsBoundsOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundsOf(pcSubStr)
		return This.ContainsBoundsOfCS(pcSubStr, :CaseSensitive = TRUE)

		def SubStringIsBounded(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

		def SubStringHasBounds(pcSubStr)
			return This.ContainsBoundsOf(pcSubStr)

	  #---------------------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][1]
			c = acChars[n1-1]

			for j = n1 - 2 to 1 step - 1
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ j + 1, n1 - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringFirstBoundsAsSections(pcSubStr)
		return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		def FindFirstBoundsAsSections(pcSubStr)
			return This.FindSubStringFirstBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		# Getting the list if chars and sections of pcSubStr

		nLenStr = This.NumberOfChars()
		if nLenStr = 0
			return []
		ok

		acChars = This.Chars()

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		nLen = len(aSections)
		if nLen = 0
			return []
		ok

		# Removing extreme cases

		if aSections[1][1] = 1
			ring_del(aSections, 1)
			nLen--
		ok

		if aSections[nLen][2] = nLenStr
			ring_del(aSections, nLen)
			nLen--
		ok

		# Doing the job

		aResult = []

		for i = 1 to nLen

			n1 = aSections[i][2]
			c = acChars[n1+1]

			for j = n1 + 2 to nLenStr
				if acChars[j] != c
					exit
				ok
			next

			aResult + [ n1 + 1, j - 1 ]

		next

		return aResult

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLastBoundsAsSections(pcSubStr)
		return This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindLastBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#--

		def FindSubStringSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		def FindSecondBoundsAsSections(pcSubStr)
			return This.FindSubStringLastBoundsAsSections(pcSubStr)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------------------#

	def FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringLeftBoundsAsSections(pcSubStr)
		return This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		def FindLeftBoundsAsSections(pcSubStr)
			return This.FindSubStringLeftBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS AS SECTIONS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------------------#

	def FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)

		else
			return This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringRightBoundsAsSections(pcSubStr)
		return This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOfAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		def FindRightBoundsAsSections(pcSubStr)
			return This.FindSubStringRightBoundsAsSections(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE FIRST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindFirstBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForms

		def FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FindFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringFirstBounds(pcSubStr)
		return This.FindSubStringFirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstBoundsOf(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		def FindFirstBounds(pcSubStr)
			return This.FindSubStringFirstBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LAST BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
		aSections = This.FindLastBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		anResult = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForsm

		def FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def FindSubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def FindSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLastBounds(pcSubStr)
		return This.FindSubStringLastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForsm

		def FindLastBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindLastBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#--

		def FindSubStringSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBoundsOf(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		def FindSecondBounds(pcSubStr)
			return This.FindSubStringLastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def FindLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringLeftBounds(pcSubStr)
		return This.FindSubStringLeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeftBoundsOf(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		def FindLeftBounds(pcSubStr)
			return This.FindSubStringLeftBounds(pcSubStr)

		#>

	  #---------------------------------------------------------------#
	 #  FINDING THE RIGHT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#---------------------------------------------------------------#

	def FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FindLastBoundsOfCS(pcSubStr, pCaseSensitive)
		else
			return This.FindFirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def FindRightBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def FindRightBoundsCS(pcSubStr, pCaseSensitive)
			return This.FindSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindSubStringRightBounds(pcSubStr)
		return This.FindRightBoundsOfCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindRightBoundsOf(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		def FindRightBounds(pcSubStr)
			return This.FindSubStringRightBounds(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #  GETTING THE BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#=========================================================#

	def SubStringBoundsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE 1

		o1 = new stzString("Hello <<Ring>>, the beautiful ((Ring))!")
		? o1.BoundsOf("Ring")
		#--> [ ["<<", ">>"], [ "((", "))" ] ]

		*/

		aSections = This.FindBoundsOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			on :stzListOfStrings
				return new stzListOfStrings(This.SubStringBoundsCS(pcSubStr, pCaseSensitive))

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def BoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def BoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQR(pcSubStr, pCaseSensitive, :stzList)

			def BoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
		#--

		def SubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndLastBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def SubStringFirstAndSecondBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndLastBoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def FirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsCS(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				return This.BoundsOfCSQ(pcSubStr, pCaseSensitive)

			def FirstAndSecondBoundsOfCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SubStringBoundsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringBounds(pcSubstr)
		return This.SubStringBoundsCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def BoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def BoundsOfQ(pcSubStr)
				return This.BoundsOfCSQ(pcSubStr, :CaseSensitive = TRUE)

			def BoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#--

		def SubStringFirstAndLastBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndLastBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndLastBoundsQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def SubStringFirstAndSecondBounds(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def SubStringFirstAndSecondBoundsQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def SubStringFirstAndSecondBoundsQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def FirstAndLastBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndLastBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndLastBoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		def FirstAndSecondBoundsOf(pcSubStr)
			return This.SubStringBounds(pcSubStr)

			def FirstAndSecondBoundsOfQ(pcSubStr)
				return This.BoundsOfQ(pcSubStr)

			def FirstAndSecondBoundsOfQR(pcSubStr, pcReturnType)
				return This.BoundsOfQR(pcSubStr, pcReturnType)

		#>

	  #-------------------------------------------------------------#
	 #  GETTING THE FIRST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#-------------------------------------------------------------#

	def SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		def FirstBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

		def FirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringFirstBounds(pcSubStr)
		return This.SubStringFirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def FirstBoundsOf(pcSubStr)
			return This.SubStringFirstBounds(pcSubStr)

		def FirstBounds(pcSubStr)
			return This.FirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

	  #------------------------------------------------------------#
	 #  GETTING THE LAST BOUNDS OF A SUBSTRING INSIDE THE STRING  #
	#------------------------------------------------------------#

	def SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionAlternativeForms

		def LastBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		#--

		def LastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLastBoundsCS(pcSubStr, pCaseSensitive)

		def SecondBoundsCS(pcSubStr, pCaseSensitive)
			return This.LastBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringLastBounds(pcSubStr)
		return This.SubStringLastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LastBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SubStringSecondBounds(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		def SecondBoundsOf(pcSubStr)
			return This.SubStringLastBounds(pcSubStr)

		#--

		def LastBounds(pcSubStr)
			return This.LastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		def SecondBounds(pcSubStr)
			return This.LastBounds(pcSubStr)

		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE LEFT BOUNDS OF A GIVEN SUBSTRING IN THE STRING  #
	#--------------------------------------------------------------#

	def SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def LeftBoundsOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		def LeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringLeftBounds(pcSubStr)
		return This.SubStringLeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeftBoundsOf(pcSubStr)
			return This.SubStringLeftBounds(pcSubStr)

		def LeftBounds(pcSubStr)
			return This.LeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)
 
		#>

	  #------------------------------------------------------------------#
	 #  GETTING THE RIGHT BOUNDS OF A GIVEN SUBSTRIG INSIDE THE STRING  #
	#------------------------------------------------------------------#

	def SubStringRightBoundsCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			return This.LastBoundsOfCS(pcSubStr, pCaseSensitive)

		else # case IsRightToLeft()
			return This.FirstBoundsOfCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionAlternativeForms

		def RightBoundsOfCS(pcsubStr, pCaseSensitive)
			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		def RightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			return This.SubStringRightBoundsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def SubStringRightBounds(pcSubStr)
		return This.SubStringRightBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RightBoundsOf(pcsubStr)
			return This.SubStringRightBounds(pcSubStr)

		def RightBounds(pcSubStr)
			return This.RightBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #------------------------------------#
	 #  REMOVING BOUNDS OF THE SUBSTRING  #
	#====================================#

	def RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)


		#< @FunctionFluentForm

		def RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveBoundsOfCS(pcSubStr, pCaseSensitive)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringFirstAndSecondBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringFirstAndSecondBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsOfCS(pcSubStr, pCaseSensitive)

			def RemoveFirstAndSecondBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstAndSecondBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr,pCaseSensitive)

			def RemoveSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSecondAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSecondAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringLeftAndRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringLeftAndRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftAndRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftAndRightBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringRightAndLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringRightAndLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightAndLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightAndLeftBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndLastBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def FirstAndSecondBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLastAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondAndFirstBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def SecondAndFirstBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringLeftAndRightBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def LeftAndRightBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringRightAndLeftBoundsRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		def RightAndLeftBoundsOfRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringBounds(pcSubStr)
		return This.RemoveSubStringBoundsCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringBoundsQ(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveBoundsOfQ(pcSubStr)
				This.RemoveBoundsOf(pcSubStr)
				return This
	
		#--

		def RemoveSubStringFirstAndLastBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndLastBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		def RemoveSubStringFirstAndSecondBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringFirstAndSecondBoundsQ(pcSubStr)
				This.RemoveSubStringFirstAndLastBounds(pcSubStr)
				return This

		#--

		def RemoveFirstAndLastBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveFirstAndLastBoundsOfQ(pcSubStr)
				This.RemoveFirstAndLastBoundsOf(pcSubStr)
				return This

		def RemoveFirstAndSecondBoundsOf(pcSubStr)
			This.RemoveSubStringBoundsOf(pcSubStr)

			def RemoveFirstAndSecondBoundsOfQ(pcSubStr)
				This.RemoveFirstAndSecondBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLastAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubSt)

			def RemoveSubStringLastAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringLastAndFirstBounds(pcSubStr)
				return This

		def RemoveSubStringSecondAndFirstBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringSecondAndFirstBoundsQ(pcSubStr)
				This.RemoveSubStringSecondAndFirstBounds(pcSubStr)
				return This

		#--

		def RemoveLastAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLastAndFirstBoundsOfQ(pcSubStr)
				This.RemoveLastAndFirstBoundsOf(pcSubStr)
				return This

		def RemoveSecondAndFirstBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSecondAndFirstBoundsOfQ(pcSubStr)
				This.RemoveSecondAndFirstBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringLeftAndRightBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringLeftAndRightBoundsQ(pcSubStr)
				This.RemoveSubStringLeftAndRightBounds(pcSubStr)
				return This

		#--

		def RemoveLeftAndRightBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveLeftAndRightBoundsOfQ(pcSubStr)
				This.RemoveLeftAndRightBoundsOf(pcSubStr)
				return This

		#--

		def RemoveSubStringRightAndLeftBounds(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveSubStringRightAndLeftBoundsQ(pcSubStr)
				This.RemoveSubStringRightAndLeftBounds(pcSubStr)
				return This

		#--

		def RemoveRightAndLeftBoundsOf(pcSubStr)
			This.RemoveSubStringBounds(pcSubStr)

			def RemoveRightAndLeftBoundsOfQ(pcSubStr)
				This.RemoveRightAndLeftBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def BoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndLastBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringFirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def FirstAndSecondBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLastAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LastAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SubStringSecondAndFirstBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def SecondAndFirstBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringLeftAndRightBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def LeftAndRightBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#--

		def SubStringRightAndLeftBoundsRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		def RightAndLeftBoundsOfRemoved(pcSubStr)
			return This.SubStringBoundsRemoved(pcSubStr)

		#>

	  #----------------------------------------#
	 #  REMOVING LEFT BOUND OF THE SUBSTRING  #
	#========================================#

	def RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLeftBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLeftBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		def LeftBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLeftBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBounds()
		This.RemoveSubStringLeftBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundsQ()
			This.RemoveSubStringLeftBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLeftBounds(pcSubStr)
			This.RemoveLeftBoundsCS(pcSubStr, :CaseSensitive = TRUE)

			def RemoveLeftBoundsQ(pcSubStr)
				This.RemoveLeftBounds(pcSubStr)
				return This

		def RemoveLeftBoundsOf(pcSubStr)
			This.RemoveSubStringLeftBounds(pcSubStr)

			def RemoveLeftBoundsOfQ(pcSubStr)
				This.RemoveLeftBoundsOf(pcSubStr)

		#>

	def SubStringLeftBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLeftBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LeftBoundsRemoved()
			return This.SubStringLeftBoundsRemoved()

		def LeftBoundOfsRemoved()
			return This.SubStringLeftBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING RIGHT BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringRightBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringRightBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		def RightBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringRightBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBounds()
		This.RemoveSubStringRightBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundsQ()
			This.RemoveSubStringRightBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveRightBounds(pcSubStr)
			This.RemoveRightBoundsCS(pcSubStr, :CaseSensitive = TRUE)

			def RemoveRightBoundsQ(pcSubStr)
				This.RemoveRightBounds(pcSubStr)
				return This

		def RemoveRightBoundsOf(pcSubStr)
			This.RemoveSubStringRightBounds(pcSubStr)

			def RemoveRightBoundsOfQ(pcSubStr)
				This.RemoveRightBoundsOf(pcSubStr)

		#>

	def SubStringRightBoundsRemoved()
		cResult = This.Copy().RemoveSubStringRightBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def RightBoundsRemoved()
			return This.SubStringRightBoundsRemoved()

		def RightBoundOfsRemoved()
			return This.SubStringRightBoundsRemoved()

		#>

	  #-----------------------------------------#
	 #  REMOVING FIRST BOUND OF THE SUBSTRING  #
	#-----------------------------------------#

	def RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringFirstBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringFirstBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		def FirstBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringFirstBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBounds()
		This.RemoveSubStringFirstBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundsQ()
			This.RemoveSubStringFirstBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveFirstBounds(pcSubStr)
			This.RemoveFirstBoundsCS(pcSubStr, :CaseSensitive = TRUE)

			def RemoveFirstBoundsQ(pcSubStr)
				This.RemoveFirstBounds(pcSubStr)
				return This

		def RemoveFirstBoundsOf(pcSubStr)
			This.RemoveSubStringFirstBounds(pcSubStr)

			def RemoveFirstBoundsOfQ(pcSubStr)
				This.RemoveFirstBoundsOf(pcSubStr)

		#>

	def SubStringFirstBoundsRemoved()
		cResult = This.Copy().RemoveSubStringFirstBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def FirstBoundsRemoved()
			return This.SubStringFirstBoundsRemoved()

		def FirstBoundOfsRemoved()
			return This.SubStringFirstBoundsRemoved()

		#>

	  #----------------------------------------#
	 #  REMOVING LAST BOUND OF THE SUBSTRING  #
	#----------------------------------------#

	def RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
	
		aSections = This.FindSubStringLastBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundsCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundsOfCS(pcSubStr, pCaseSensitive)

		#>

	def SubStringLastBoundsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundsCSQ(pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		def LastBoundOfsRemovedCS(pCaseSensitive)
			return This.SubStringLastBoundsRemovedCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBounds()
		This.RemoveSubStringLastBoundsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundsQ()
			This.RemoveSubStringLastBounds()
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveLastBounds(pcSubStr)
			This.RemoveLastBoundsCS(pcSubStr, :CaseSensitive = TRUE)

			def RemoveLastBoundsQ(pcSubStr)
				This.RemoveLastBounds(pcSubStr)
				return This

		def RemoveLastBoundsOf(pcSubStr)
			This.RemoveSubStringLastBounds(pcSubStr)

			def RemoveLastBoundsOfQ(pcSubStr)
				This.RemoveLastBoundsOf(pcSubStr)

		#>

	def SubStringLastBoundsRemoved()
		cResult = This.Copy().RemoveSubStringLastBoundsQ().Content()
		return cResult

		#< @FunctionAlternativeForms

		def LastBoundsRemoved()
			return This.SubStringLastBoundsRemoved()

		def LastBoundOfsRemoved()
			return This.SubStringLastBoundsRemoved()

		#>

	  #----------------------------------------#
	 #  SWAPPING BOUNDS OF A GIVEN SUBSTRING  #
	#========================================#

	def SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

		aSections = This.FindSubStringBoundsAsSectionsCS(pcSubStr, pCaseSensitive)
		aPairsOfSections = Q(aSections).SplitToListsOfNItems(2)
		nLen = len(aPairsOfSections)

		for i = 1 to nLen
			This.SwapSections(aPairsOfSections[i][1], aPairsOfSections[i][2])
		next

		#< @FunctionFluentForm

		def SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringFirstAndLastBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringFirstAndLastBoundsCS(pcSubStr, pCaseSensitive)
				return This

		def SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapSubStringLastAndFirstBoundsCSQ(pcSubStr, pCaseSensitive)
				This.SwapSubStringLastAndFirstBoundsCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapFirstAndLastBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapFirstAndLastBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		def SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
			This.SwapSubStringBoundsCS(pcSubStr, pCaseSensitive)

			def SwapLastAndFirstBoundsOfCSQ(pcSubStr, pCaseSensitive)
				This.SwapLastAndFirstBoundsOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().SwapSubStringBoundsCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def SubStringFirstAndLastBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def SubStringLastAndFirstBoundsSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#--

		def FirstAndLastBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		def LastAndFirstBoundsOfSwappedCS(pcSubStr, pCaseSensitive)
			return This.SubStringBoundsSwappedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStringBounds(pcSubStr)
		This.SwapSubStringBoundsCS(pcSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionFluentForm

		def SwapSubStringBoundsQ(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapBoundsOfQ(pcSubStr)
				This.SwapBoundsOf(pcSubStr)
				return This

		#--

		def SwapSubStringFirstAndLastBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringFirstAndLastBoundsQ(pcSubStr)
				This.SwapSubStringFirstAndLastBounds(pcSubStr)
				return This

		def SwapSubStringLastAndFirstBounds(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapSubStringLastAndFirstBoundsQ(pcSubStr)
				This.SwapSubStringLastAndFirstBounds(pcSubStr)
				return This

		#--

		def SwapFirstAndLastBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapFirstAndLastBoundsOfQ(pcSubStr)
				This.SwapFirstAndLastBoundsOf(pcSubStr)
				return This

		def SwapLastAndFirstBoundsOf(pcSubStr)
			This.SwapSubStringBounds(pcSubStr)

			def SwapLastAndFirstBoundsOfQ(pcSubStr)
				This.SwapLastAndFirstBoundsOf(pcSubStr)
				return This

		#>

	def SubStringBoundsSwapped(pcSubStr)
		cResult = This.Copy().SwapSubStringBoundsQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def BoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def SubStringFirstAndLastBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def SubStringLastAndFirstBoundsSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#--

		def FirstAndLastBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		def LastAndFirstBoundsOfSwapped(pcSubStr)
			return This.SubStringBoundsSwapped(pcSubStr)

		#>

	  #=======================================================#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#=======================================================#

	def RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetween(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)


	def AnyBetweenRemoved(pcBound1, pcBound2)
		acResult = This.Copy().RemoveAnyBetweenCSQ(pcBound1, pcBound2).Content()
		return acResult

	  #-------------------------------------------------------------------#
	 #  REMOVING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#-------------------------------------------------------------------#
	#--> Bounds are also removed (TODO: Generalise this feature)

	def RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveAnyBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		acResult = This.Copy().RemoveBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive).Content()
		return acResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveAnyBetweenIB(pcBound1, pcBound2)
		return This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, :CaseSensitive = TRUE)

	def AnyBetweenRemovedIB(pcBound1, pcBound2)
		acResult = This.Copy().RemoveBetweenIBQ(pcBound1, pcBound2).Content()
		return acResult

	  #============================================================#
	 #     REMOVING LEFT BOUND OF A SUBSTRING FROM THE STRING     #
	#============================================================#

	def RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.LeftNChars( nLenSubStr ) = pcSubStr
			This.ReplaceFirstOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			return This
		#>


		#< @FunctionAlternativeForms

		def RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLeftBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLeftBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLeftBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLeftBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLeftBound(pcSubStr)
		This.RemoveSubStringLeftBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLeftBoundQ(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def RemoveLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveLeftBoundOfQ(pcSubStr)
				This.RemoveLeftBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLeftBound(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachSubStringLeftBoundQ(pcSubStr)
				This.RemoveEachSubStringLeftBound(pcSubStr)
				return This

		def RemoveEachLeftBoundOf(pcSubStr)
			This.RemoveSubStringLeftBound(pcSubStr)

			def RemoveEachLeftBoundOfQ(pcSubStr)
				This.RemoveEachLeftBoundOf(pcSubStr)
				return This

		#>

	def SubStringLeftBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLeftBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLeftBoundRemoved(pcSubStr)
			return This.SubStringLeftBoundRemoved(pcSubStr)

		#>

	  #--------------------------------------------#
	 #    REMOVING RIGHT BOUND FROM THE STRING    #
	#--------------------------------------------#

	def RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
	
		nLenSubStr = StzStringQ( pcSubStr).NumberOfChars()
	
		if This.RightNChars( nLenSubStr ) = pcSubStr
			This.ReplaceLastOccurrenceCS(pcSubStr, "", pCaseSensitive)
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringrightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringRightBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachRightBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachRightBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringRightBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult


		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringRightBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringRightBound(pcSubStr)
		This.RemoveSubStringRightBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringRightBoundQ(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveRightBoundOf(pcSubStr)
			This.RemoveSubStringrightBound(pcSubStr)

			def RemoveRightBoundOfQ(pcSubStr)
				This.RemoveRightBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringRightBound(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachSubStringRightBoundQ(pcSubStr)
				This.RemoveEachSubStringRightBound(pcSubStr)
				return This

		def RemoveEachRightBoundOf(pcSubStr)
			This.RemoveSubStringRightBound(pcSubStr)

			def RemoveEachRightBoundOfQ(pcSubStr)
				This.RemoveEachRightBoundOf(pcSubStr)
				return This

		#>

	def RightSubStringBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringRightBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringRightBoundRemoved(pcSubStr)
			return This.SubStringRightBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   REMOVING FIRST BOUND FROM THE STRING    #
	#-------------------------------------------#

	def RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringLeftBoundCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() than...
			This.RemoveSubStringRightBoundCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm
	
		def RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringFirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringFirstBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringfirstBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachFirstBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachFirstBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringFirstBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringFirstBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringFirstBound(pcSubStr)
		This.RemoveSubStringFirstBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringFirstBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This

		#< @FunctionAlternativeForms

		def RemoveFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveFirstBoundOfQ(pcSubStr)
				This.RemoveFirstBoundOf(pcSubStr)
				return This

		#--

		def RemoveEachSubStringFirstBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringFirstBoundQ(pcSubStr)
				This.RemoveEachSubStringFirstBound(pcSubStr)
				return This

		def RemoveEachFirstBoundOf(pcSubStr)
			This.RemoveSubStringfirstBound(pcSubStr)

			def RemoveEachFirstBoundOfQ(pcSubStr)
				This.RemoveEachFirstBoundOf(pcSubStr)
				return This

		#>


	def SubStringFirstBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringFirstBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringFirstBoundRemoved(pcSubStr)
			return This.SubStringFirstBoundRemoved(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REMOVING EACH LAST BOUND OF A SUBSTRING FROM THE STRING   #
	#-------------------------------------------------------------#

	def RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
	
		if This.IsLeftToRight()
			This.RemoveSubStringRightBoundsCS(pcSubStr, pCaseSensitive)
	
		else
			# It IsRightToTeft() then...
			This.RemoveSubStringLeftBoundsCS(pcSubStr, pCaseSensitive)
				
		ok
	
		#< @FunctionFluentForm

		def RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#--

		def RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringLastBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringLastBoundCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachLastBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachLastBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSecondBoundOfCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSecondBoundOfCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
			This.RemoveSubStringLastBoundCS(pcSubStr, pCaseSensitive)

			def RemoveEachSubStringSecondBoundCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEachSubStringSecondBoundCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubStringLastBoundCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		def EachSubStringSecondBoundRemovedCS(pcSubStr, pCaseSensitive)
			return This.SubStringLastBoundRemovedCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringLastBound(pcSubStr)
		This.RemoveSubStringLastBoundCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringLastBoundQ(pcSubStr)
			This.RemoveSubStringFirstBound(pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForms

		def RemoveLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveLastBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSecondBoundOfQ(pcSubStr)
				This.RemoveLastBoundOf(pcSubStr)
				return This

		def RemoveSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveSubStringSecondBoundQ(pcSubStr)
				This.RemoveSubStringSecondBound(pcSubStr)
				return This

		#--

		def RemoveEachSubStringLastBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringLastBoundQ(pcSubStr)
				This.RemoveEachSubStringLastBound(pcSubStr)
				return This

		def RemoveEachLastBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachLastBoundOfQ(pcSubStr)
				This.RemoveEachLastBoundOf(pcSubStr)
				return This

		def RemoveEachSecondBoundOf(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSecondBoundOfQ(pcSubStr)
				This.RemoveEachSecondBoundOf(pcSubStr)
				return This

		def RemoveEachSubStringSecondBound(pcSubStr)
			This.RemoveSubStringLastBound(pcSubStr)

			def RemoveEachSubStringSecondBoundQ(pcSubStr)
				This.RemoveEachSubStringSecondBound(pcSubStr)
				return This

		#>

	def SubStringLastBoundRemoved(pcSubStr)
		cResult = This.Copy().RemoveSubStringLastBoundQ(pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def EachSubStringLastBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def SubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		def EachSubStringSecondBoundRemoved(pcSubStr)
			return This.SubStringLastBoundRemoved(pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CHECKING OF THE STRING CONTAINS THE GIVEN BOUNDS   #
	#------------------------------------------------------#

	def ContainsTheseBoundsCS(pacBounds, pCaseSensitive)
		if NOT ( isList(pacBounds) and Q(pacBounds).IsAPairOfStrings() )
			StzRaise("Incorrect param type! pacBounds must be a pair of strings.")
		ok

		if (NOT This.ContainsCS(pacBounds[1])) or
		   (NOT This.ContainsCS(pacBounds[2]))

			return FALSE
		ok

		n1 = This.FindFirstCS(pacBounds[1])
		n2 = This.FindFirstCS(pacBounds[2])

		if n1 < n2
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseBounds(pacBounds)
		return This.ContainsTheseBoundsCS(pacBounds, :CaseSensitive = TRUE)


	  #------------------------------------------------------------------------#
	 #   ADDING BOUNDS TO THE OCCURRENCES OF A SUBSTRING INSIDE THE STRING    #
	#------------------------------------------------------------------------#

	def AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		anSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed()
	
		for aSection in anSections
			n1 = aSection[1]
			n2 = aSection[2]

			nLenBound2 = StzStringQ(pcBound2).NumberOfChars()

			if n2 < This.NumberOfChars() and
			   This.Section(n2 + 1, n2 + nLenBound2) != pcBound2

				This.InsertAfter(n2, pcBound2)
			ok

			nLenBound1 = StzStringQ(pcBound1).NumberOfChars()

			if n1 > 1 and
			   This.Section(n1 - nLenBound1, n1 - 1) != pcBound1

				This.InsertBefore(n1, pcBound1)
			ok
		next

		#< @FunctionFluentForm

		def AddBoundsToSubStringCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddTheseBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			def AddTheseBoundsToSubStringCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.AddTheseBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def AddSubStringBoundsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsToOrToSubStringNamedParam()
				pcSubStr = pcSubStr[2]
			ok

			This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			def AddSubStringBoundsCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.AddSubStringBoundsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		#-- NOTE: The semantics change here, as we use the verbal form "Bound"
		#-- and not the plural form "Bounds" as it is the case above. Hence,
		#-- the user expects to provide either one bound or two, at his will:

		def BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
			if isList(pacBounds) and Q(pacBounds).IsWithOrByOrUsingNamedParam()
				pacBounds = pacBounds[2]
			ok

			cBound1 = ""
			cBound2 = ""

			if isString(pacBounds)
				cBound1 = pacBounds
				cBound2 = pacBounds

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				cBound1 = pacBounds[1]
				cBound2 = pacBounds[2]

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

			This.AddBoundsToSubStringCS(pcSubStr, cBound1, cBound2, pCaseSensitive)


			def BoundSubStringCSQ(pcSubStr, pacBounds, pCaseSensitive)
				This.BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)
				return This

		def BoundSubStringWithCS(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringWithCSQ(pcSubStr, pacBounds, pCaseSensitive)
				This.BoundSubStringWithCS(pcSubStr, pacBounds, pCaseSensitive)
				return This

		def BoundSubStringByCS(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringByCSQ(pcSubStr, pacBounds, pCaseSensitive)
				This.BoundSubStringByCS(pcSubStr, pacBounds, pCaseSensitive)
				return This

		def BoundSubStringUsingCS(pcSubStr, pacBounds, pCaseSensitive)
			This.BoundSubStringCS(pcSubStr, pacBounds, pCaseSensitive)

			def BoundSubStringUsingCSQ(pcSubStr, pacBounds, pCaseSensitive)
				This.BoundSubStringUsingCS(pcSubStr, pacBounds, pCaseSensitive)
				return This
		#>

	#-- WITHOUT CASESENSITIVITY

	def AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)
		This.AddBoundsToSubStringCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AddBoundsToSubStringQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddTheseBoundsToSubString(pcSubStr, pcBound1, pcBound2)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)

			def AddTheseBoundsToSubStringQ(pcSubStr, pcBound1, pcBound2)
				This.AddTheseBoundsToSubString(pcSubStr, pcBound1, pcBound2)
				return This

		def AddSubStringBounds(pcSubStr, pcBound1, pcBound2)
			This.AddBoundsToSubString(pcSubStr, pcBound1, pcBound2)

			def AddSubStringBoundsQ(pcSubStr, pcBound1, pcBound2)
				This.AddSubStringBounds(pcSubStr, pcBound1, pcBound2)
				return This

		#-- NOTE: The semantics change here, as we use the verbal form "Bound"
		#-- and not the plural form "Bounds" as it is the case above. Hence,
		#-- the user expects to provide either one bound or two, at his will:

		def BoundSubString(pcSubStr, pacBounds)
			This.BoundSubStringCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

			def BoundSubStringQ(pcSubStr, pacBounds)
				This.BoundSubString(pcSubStr, pacBounds)
				return This

		def BoundSubStringWith(pcSubStr, pacBounds)
			This.BoundSubString(pcSubStr, pacBounds)

			def BoundSubStringWithQ(pcSubStr, pacBounds)
				This.BoundSubStringWith(pcSubStr, pacBounds)
				return This

		def BoundSubStringBy(pcSubStr, pacBounds)
			This.BoundSubString(pcSubStr, pacBounds)

			def BoundSubStringByQ(pcSubStr, pacBounds)
				This.BoundSubStringBy(pcSubStr, pacBounds)
				return This

		def BoundSubStringUsing(pcSubStr, pacBounds)
			This.BoundSubString(pcSubStr, pacBounds)

			def BoundSubStringUsingQ(pcSubStr, pacBounds)
				This.BoundSubStringUsing(pcSubStr, pacBounds)
				return This

		#>

	  #---------------------------------------------------------#
	 #   ADDING BOUNDS TO MANYS SUBSTRINGS AT THE SAME TIME    #
	#---------------------------------------------------------#

	def AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		nLen = len(pacSubStr)

		for i = 1 to nLen
			This.AddBoundsToSubStringCS(pacSubStr[i], pcBound1, pcBound2, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def AddBoundsToManySubStringsCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddBoundsToSubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def AddBoundsToSubStringsCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.AddBoundsToSubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def BoundManySubStringsWithCS(pacSubStr,  pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def BoundManySubStringsWithCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.BoundManySubStringsWithCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		def BoundSubStringsWithCS(pacSubStr,  pcBound1, pcBound2, pCaseSensitive)
			This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)

			def BoundSubStringsWithCSQ(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				This.BoundSubStringsWithCS(pacSubStr, pcBound1, pcBound2, pCaseSensitive)
				return This

		#>

	#-- WITHOUT CASESENSITIVITY

	def AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)
		This.AddBoundsToManySubStringsCS(pacSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AddBoundsToManySubStringsQ(pacSubStr, pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)
			return This

		#>

		#< @FunctionAlternativeForms

		def AddBoundsToSubStrings(pacSubStr, pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def AddBoundsToSubStringsQ(pacSubStr, pcBound1, pcBound2)
				This.AddBoundsToSubStrings(pacSubStr, pcBound1, pcBound2)
				return This

		def BoundManySubStringsWith(pacSubStr,  pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def BoundManySubStringsWithQ(pacSubStr, pcBound1, pcBound2)
				This.BoundManySubStringsWith(pacSubStr, pcBound1, pcBound2)
				return This

		def BoundSubStringsWith(pacSubStr,  pcBound1, pcBound2)
			This.AddBoundsToManySubStrings(pacSubStr, pcBound1, pcBound2)

			def BoundSubStringsWithQ(pacSubStr, pcBound1, pcBound2)
				This.BoundSubStringsWith(pacSubStr, pcBound1, pcBound2)
				return This

		#>

	  #============================#
	 #   REPEATED LEADING CHARS   #
	#============================#

	def RepeatedLeadingCharsCS(pCaseSensitive)
		/* Example:
			'eeeTUNIS' 	--> 'eee'
			'exeeeeeTUNIS' 	--> ''
		*/

		if This.IsEmpty()
			return ""
		ok

		nLen = This.NumberOfChars()
		# TODO: Check wether the ...CS() extension is needed here!

		cResult = ""
	
		bContinue = TRUE
		cFirstChar = This.FirstChar()
		i = 1

		while bContinue
			i++

			if i > nLen
				bContinue = FALSE
			ok

			cCurrentChar = This.Char(i)

			if NOT Q(cCurrentChar).IsEqualToCS(cFirstChar, pCaseSensitive)
				bContinue = FALSE
			ok

		end

		if i > 2
			return This.NFirstChars(i-1)
		ok

		#< @FunctionFluentForm

		def RepeatedLeadingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedLeadingCharsCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingRepeatedCharsCSQ(pCaseSensitive)
				return new stzList( This.LeadingRepeatedCharsCS(pCaseSensitive) )
	
		def LeadingCharsCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCS(pCaseSensitive)

			def LeadingCharsCSQ(pCaseSensitive)
				return new stzList( This.LeadingCharsCS(pCaseSensitive) )
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChars()
		return This.RepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsQ()
			return new stzList( This.RepeatedLeadingChars() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChars()
			return This.RepeatedLeadingChars()

			def LeadingRepeatedCharsQ()
				return new stzList( This.LeadingRepeatedChars() )
	
		def LeadingChars()
			return This.RepeatedLeadingChars()

			def LeadingCharsQ()
				return new stzList( This.LeadingChars() )
	
		#>

	  #-----------------------------------------------------#
	 #  GETTING THE REPEATED LEADING CHARS AS A SUBSTRING  #
	#-----------------------------------------------------#

	def RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)
		acChars = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = len(acChars)

		cResult = ""
		for i = 1 to nLen
			cResult += acChars[i]
		next

		return cResult


		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def LeadingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingCharsAsSubStringCS(pCaseSensitive) )
	
		#--

		def RepeatedLeadingCharsAsStringCS(pCaseSensitive)
			This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedLeadingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.RepeatedLeadingCharsAsStringCS(pCaseSensitive) )

		def LeadingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def LeadingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedLeadingCharsAsSubStringCS(pCaseSensitive)

			def LeadingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.LeadingCharsAsSubStringCS(pCaseSensitive) )

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingCharsAsSubString()
		return This.RepeatedLeadingCharsAsSubStringCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedLeadingCharsAsSubStringQ()
			return new stzString( This.RepeatedLeadingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsSubStringQ()
				return new stzString( This.LeadingRepeatedCharsAsSubString() )
	
		def LeadingCharsAsSubString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsSubStringQ()
				return new stzString( This.LeadingCharsAsSubString() )

		#--

		def RepeatedLeadingCharsAsString()
			This.RepeatedLeadingCharsAsSubString()

			def RepeatedLeadingCharsAsStringQ()
				return new stzString( This.RepeatedLeadingCharsAsString() )

		def LeadingRepeatedCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingRepeatedCharsAsStringQ()
				return new stzString( This.LeadingRepeatedCharsAsSubString() )
	
		def LeadingCharsAsString()
			return This.RepeatedLeadingCharsAsSubString()

			def LeadingCharsAsStringQ()
				return new stzString( This.LeadingCharsAsSubString() )
	
		#>

	  #-------------------------------------#
	 #  GETTING THE REPEATED LEADING CHAR  #
	#-------------------------------------#

	def RepeatedLeadingCharCS(pCaseSensitive)

		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return This[1]
		ok

		#< @FunctionFleuntForms

		def RepeatedLeadingCharCSQ(pCaseSensitive)
			return This.RepeatedLeadingCharCSQR(pCaseSensitive, :stzChar)

		def RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingCharCS(pCaseSensitive))

			on :stzString
				return new stzString(This.RepeatedLeadingCharCS(pCaseSensitive))
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingRepeatedCharCSQ(pCaseSensitive)
				return This.LeadingRepeatedCharCSQR(pCaseSensitive, :stzChar)
	
		def LeadingCharCS(pCaseSensitive)
			return This.RepeatedLeadingCharCS(pCaseSensitive)

			def LeadingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharCSQR(pCaseSensitive, pcReturnType)

			def LeadingCharCSQ(pCaseSensitive)
				return This.LeadingCharCSQR(pCaseSensitive, :stzChar)
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedLeadingChar()
		return This.RepeatedLeadingCharCS(:CaseSensitive = TRUE)


		#< @FunctionFleuntForms

		def RepeatedLeadingCharQ()
			return This.RepeatedLeadingCharQR(:stzChar)

		def RepeatedLeadingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar(This.RepeatedLeadingChar())

			on :stzString
				return new stzString(This.RepeatedLeadingChar())
			other
				stzRaise("Unsupported returned type!")
			off

		#>

		#< @FunctionAlternativeForms

		def LeadingRepeatedChar()
			return This.RepeatedLeadingChar()

			def LeadingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingRepeatedCharQ()
				return This.LeadingRepeatedCharQR(:stzChar)
				# TODO: Should it be always :stzString by default?
				# check this beghaviour all over the library!
	
		def LeadingChar()
			return This.RepeatedLeadingChar()

			def LeadingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedLeadingCharQR(pcReturnType)

			def LeadingCharQ()
				return This.LeadingCharQR(:stzChar)
	
		#>

	  #--------------------------------------------------------------#
	 #  GETTING THE NUMBER OF REPEATED LEADING CHARS IN THE STRING  #
	#--------------------------------------------------------------#

	def NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0

		if This.ContainsLeadingCharsCS(pCaseSensitive)
			nResult = This.LeadingCharsCSQ(pCaseSensitive).NumberOfChars()
		ok

		return nResult

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def NumberOfLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
	
		def CountLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingRepeatedCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def CountLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		def HowManyLeadingCharCS(pCaseSensitive)
			return This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedLeadingChars()
		return This.NumberOfRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def NumberOfLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def NumberOfLeadingChars()
			return This.NumberOfRepeatedLeadingChars()
	
		def CountLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingRepeatedChar()
			return This.NumberOfRepeatedLeadingChars()

		def CountLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChars()
			return This.NumberOfRepeatedLeadingChars()

		def HowManyLeadingChar()
			return This.NumberOfRepeatedLeadingChars()

		#>

	  #---------------------------------------------------------------------#
	 #  CHECKING IF A GIVEN CHAR IS A REPEATED LEADING CHAR IN THE STRING  #
	#---------------------------------------------------------------------#

	def RepeatedLeadingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)

		def LeadingCharIsCS(c, pCaseSensitive)
			return This.RepeatedLeadingCharIsCS(c, pCaseSensitive)
	
		#>

	#-- WITHOUT CASESENSITIVITY()

	def RepeatedLeadingCharIs(c)
		return This.RepeatedLeadingCharIsCS(c, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def LeadingRepeatedCharIs(c)
			return This.RepeatedLeadingCharIs(c)

		def LeadingCharIs(c)
			return This.RepeatedLeadingCharIs(c)
	
		#>

	  #----------------------------------------------------#
	 #  CHECKING IF THE STRING HAS REPEATED LEADING CHAR  #
	#----------------------------------------------------#

	def HasRepeatedLeadingCharsCS(pCaseSensitive)
		if This.RepeatedLeadingCharsCS(pCaseSensitive) != NULL
			return TRUE
		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def HasLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		def ContainsLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingChars()
		return This.HasRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def HasLeadingChars()
			return This.HasRepeatedLeadingChars()

		#--

		def ContainsRepeatedLeadingChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingRepeatedChars()
			return This.HasRepeatedLeadingChars()

		def ContainsLeadingChars()
			return This.HasRepeatedLeadingChars()

		#>

	  #--------------------------------------------------------#
	 #   CHECKING IF THE STRING HAS REPEATED TRAILING CHARS   #
	#--------------------------------------------------------#

	def HasRepeatedTrailingCharsCS(pCaseSensitive)
		return This.Copy().ReverseCharsQ().HasRepeatedLeadingCharsCS(pCaseSensitive)

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def HasTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedTrailingChars()
		return This.HasRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def HasTrailingChars()
			return This.HasRepeatedTrailingChars()

		#--

		def ContainsRepeatedTrailingChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingRepeatedChars()
			return This.HasRepeatedTrailingChars()

		def ContainsTrailingChars()
			return This.HasRepeatedTrailingChars()

		#>

	  #-----------------------------------------#
	 #   GETTING THE REPEATED TRAILING CHARS   #
	#-----------------------------------------#

	def RepeatedTrailingCharsCS(pCaseSensitive)
		/* Example:
			'TUNISeee' 	--> 'eee'
			'TUNISexeeeee' 	--> ''
		*/

		cResult = This.Copy().ReverseCharsQ().RepeatedLeadingCharsCS(pCaseSensitive)
		return cResult

		def RepeatedTrailingCharsCSQ(pCaseSensitive)
			return new stzList( This.RepeatedTrailingCharsCS(pCaseSensitive) )
	
		def TrailingRepeatedCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingRepeatedCharsCSQ(pCaseSensitive)
				return new stzList( This.TrailingRepeatedCharsCS(pCaseSensitive) )
	
		def TrailingCharsCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCS(pCaseSensitive)

			def TrailingCharsCSQ(pCaseSensitive)
				return new stzList( This.TrailingCharsCS(pCaseSensitive) )
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChars()
		return This.RepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def RepeatedTrailingCharsQ()
			return new stzList( This.RepeatedTrailingChars() )
	
		def TrailingRepeatedChars()
			return This.RepeatedTrailingChars()

			def TrailingRepeatedCharsQ()
				return new stzList( This.TrailingRepeatedChars() )
	
		def TrailingChars()
			return This.RepeatedTrailingChars()

			def TrailingCharsQ()
				return new stzList( This.TrailingChars() )

	  #------------------------------------------------------#
	 #  GETTING THE REPEATED Trailing CHARS AS A SUBSTRING  #
	#------------------------------------------------------#

	def RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)
		acChars = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = len(acChars)

		cResult = ""
		for i = 1 to nLen
			cResult += acChars[i]
		next

		return cResult


		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringCSQ(pCaseSensitive)
			return new stzString( This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def TrailingCharsAsSubStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsSubStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingCharsAsSubStringCS(pCaseSensitive) )
	
		#--

		def RepeatedTrailingCharsAsStringCS(pCaseSensitive)
			This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def RepeatedTrailingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.RepeatedTrailingCharsAsStringCS(pCaseSensitive) )

		def TrailingRepeatedCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingRepeatedCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingRepeatedCharsAsSubStringCS(pCaseSensitive) )
	
		def TrailingCharsAsStringCS(pCaseSensitive)
			return This.RepeatedTrailingCharsAsSubStringCS(pCaseSensitive)

			def TrailingCharsAsStringCSQ(pCaseSensitive)
				return new stzString( This.TrailingCharsAsSubStringCS(pCaseSensitive) )

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharsAsSubString()
		return This.RepeatedTrailingCharsAsSubStringCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RepeatedTrailingCharsAsSubStringQ()
			return new stzString( This.RepeatedTrailingCharsAsSubString() )
	
		#>

		#< @FunctionAlternativeForms

		def TrailingRepeatedCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsSubStringQ()
				return new stzString( This.TrailingRepeatedCharsAsSubString() )
	
		def TrailingCharsAsSubString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsSubStringQ()
				return new stzString( This.TrailingCharsAsSubString() )

		#--

		def RepeatedTrailingCharsAsString()
			This.RepeatedTrailingCharsAsSubString()

			def RepeatedTrailingCharsAsStringQ()
				return new stzString( This.RepeatedTrailingCharsAsString() )

		def TrailingRepeatedCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingRepeatedCharsAsStringQ()
				return new stzString( This.TrailingRepeatedCharsAsSubString() )
	
		def TrailingCharsAsString()
			return This.RepeatedTrailingCharsAsSubString()

			def TrailingCharsAsStringQ()
				return new stzString( This.TrailingCharsAsSubString() )
	
		#>

	  #----------------------------------------#
	 #   GETTING THE REPEATED TRAILING CHAR   #
	#----------------------------------------#

	def RepeatedTrailingCharCS(pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			return This[:LastChar]
		ok

		def RepeatedTrailingCharCSQ(pCaseSensitive)
			return This.RepeatedTrailingCharCSQR(pCaseSensitive, :stzString)

		def RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString(This.RepeatedTrailingChar(pCaseSensitive))

			on :stzChar
				return new stzChar(This.RepeatedTrailingCharCS(pCaseSensitive))

			other
				stzRaise("Unsupported returned type!")
			off
	
		def TrailingRepeatedCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingRepeatedCharCSQ(pCaseSensitive)
				return This.TrailingRepeatedCharQR(pCaseSensitive, :stzString)

			def TrailingRepeatedCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)
	
		def TrailingCharCS(pCaseSensitive)
			return This.RepeatedTrailingCharCS(pCaseSensitive)

			def TrailingCharCSQR(pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharCSQR(pCaseSensitive, pcReturnType)

			def TrailingCharCSQ(pCaseSensitive)
				return This.TrailingCharCSQR(pCaseSensitive, :stzChar)
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingChar()
		return This.RepeatedTrailingCharCS(:CaseSensitive = TRUE)

		def RepeatedTrailingCharQ()
			return This.RepeatedTrailingCharQR(:stzString)

		def RepeatedTrailingCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString(This.RepeatedTrailingChar())

			on :stzChar
				return new stzChar(This.RepeatedTrailingChar())

			other
				stzRaise("Unsupported returned type!")
			off
	
		def TrailingRepeatedChar()
			return This.RepeatedTrailingChar()

			def TrailingRepeatedCharQ()
				return This.TrailingRepeatedCharQR(:stzString)

			def TrailingRepeatedCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

		def TrailingChar()
			return This.RepeatedTrailingChar()


			def TrailingCharQ()
				return This.TrailingCharQR(:stzString)

			def TrailingCharQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.RepeatedTrailingCharQR(pcReturnType)

	  #--------------------------------------------------#
	 #   GETTING THE NUMBER OF REPEATED TRAILING CHARS  #
	#--------------------------------------------------#

	def NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		nResult = This.TrailingCharsCSQ(pCaseSensitive).NumberOfChars()
		return nResult

		def NumberOfTrailingRepeatedCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		def NumberOfTrailingCharsCS(pCaseSensitive)
			return This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def NumberOfRepeatedTrailingChars()
		return This.NumberOfRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def NumberOfTrailingRepeatedChars()
			return This.NumberOfRepeatedTrailingChars()

		def NumberOfTrailingChars()
			return This.NumberOfRepeatedTrailingChars()

	  #------------------------------------------------------------#
	 #   CHECHKING IF A GIVEN CHAR IS THE REPEATED TRAILING CHAR  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharIsCS(c, pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive) and
		   This.LastCharQ().IsEqualToCS(c, pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		def TrailingRepeatedCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)

		def TrailingCharIsCS(c, pCaseSensitive)
			return This.RepeatedTrailingCharIsCS(c, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def RepeatedTrailingCharIs(c)
		return This.RepeatedTrailingCharIsCS(c, :CaseSensitive = TRUE)

		def TrailingRepeatedCharIs(c)
			return This.RepeatedTrailingCharIs(c)

		def TrailingCharIs(c)
			return This.RepeatedTrailingCharIs(c)
	
	  #-----------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS  # 
	#===============================================#

	def FindRepeatedLeadingCharsCS(pCaseSensitive)

		nResult = 0
		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			nResult = 1
		ok
		
		return nResult

		def FindLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingChars()
		return This.FindRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		def FindLeadingChars()
			return This.FindRepeatedLeadingChars()

	  #-----------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING CHARS AND RETURNING THEM AS SECTION  # 
	#-----------------------------------------------------------------------------#

	def FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)
		if n = 0
			return []
		ok

		anResult = [ 1, n ]

		return anResult

		def FindLeadingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingCharsAsSection()
		return This.FindRepeatedLeadingCharsAsSectionCS(:CaseSensitive = TRUE)

		def FindLeadingCharsAsSection()
			return This.FindRepeatedLeadingCharsAsSection()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------#

	def RepeatedLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		def LeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZ()
		return This.RepeatedLeadingCharsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsAndTheirPosition()
			return This.RepeatedLeadingCharsZ()

		def LeadingCharsZ()
			return This.RepeatedLeadingCharsZ()

		#>

	  #-----------------------------------------------------------#
	 #  GETTING REPEATED LEADING CHARS ALONG WITH THEIR SECTION  #
	#-----------------------------------------------------------#

	def RepeatedLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		def LeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingCharsZZ()
		return This.RepeatedLeadingCharsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsAndTheirSection()
			return This.RepeatedLeadingCharsZZ()

		def LeadingCharsZZ()
			return This.RepeatedLeadingCharsZZ()

		#>

	  #-------------------------------------#
	 #   REMOVING REPEATED LEADING CHARS   #
	#=====================================#

	def RemoveRepeatedLeadingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingCharsCSQ()
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)

			def RemoveLeadingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

		def LeadingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingChars()
		This.RemoveRepeatedLeadingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedLeadingCharsQ()
			This.RemoveRepeatedLeadingChars()
			return This

		def RemoveLeadingRepeatedChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingRepeatedCharsQ()
				This.RemoveLeadingRepeatedChars()
				return This
	
		def RemoveLeadingChars()
			This.RemoveRepeatedLeadingChars()

			def RemoveLeadingCharsQ()
				This.RemoveLeadingChars()
				return This
	
	def RepeatedLeadingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingCharsQ().Content()
		return cResult

		def LeadingRepeatedCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

		def LeadingCharsRemoved()
			return This.RepeatedLeadingCharsRemoved()

	  #------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS  # 
	#================================================#

	def FindRepeatedTrailingCharsCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)
		if n = 0
			return 0
		ok

		nLen = This.NumberOfChars()
		nResult = nLen - n + 1

		return nResult

		def FindTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingChars()
		return This.FindRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def FindTrailingChars()
			return This.FindRepeatedTrailingChars()

	  #------------------------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING CHARS AND RETURNING THEM AS SECTION  # 
	#------------------------------------------------------------------------------#

	def FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n = 0
			return []
		ok

		nLen = This.NumberOfChars()
		anResult = [ nLen - n + 1, nLen ]

		return anResult

		def FindTrailingCharsAsSectionCS(pCaseSensitive)
			return This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingCharsAsSection()
		return This.FindRepeatedTrailingCharsAsSectionCS(:CaseSensitive = TRUE)

		def FindTrailingCharsAsSection()
			return This.FindRepeatedTrailingCharsAsSection()

	  #-------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR POSITION  #
	#-------------------------------------------------------------#

	def RepeatedTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsAndTheirPositionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		def TrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZ()
		return This.RepeatedTrailingCharsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsAndTheirPosition()
			return This.RepeatedTrailingCharsZ()

		def TrailingCharsZ()
			return This.RepeatedTrailingCharsZ()

		#>

	  #------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING CHARS ALONG WITH THEIR SECTION  #
	#------------------------------------------------------------#

	def RepeatedTrailingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingCharsAsSectionCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsAndTheirSectionCS(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		def TrailingCharsCSZZ(pCaseSensitive)
			return This.RepeatedTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingCharsZZ()
		return This.RepeatedTrailingCharsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsAndTheirSection()
			return This.RepeatedTrailingCharsZZ()

		def TrailingCharsZZ()
			return This.RepeatedTrailingCharsZZ()

		#>

	  #--------------------------------------#
	 #   REMOVING REPEATED TRAILING CHARS   #
	#======================================#

	def RemoveRepeatedTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedTrailingCharsCS(pCaseSensitive)
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedTrailingCharsCSQ()
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)

			def RemoveTrailingCharsCSQ(pCaseSensitive)
				This.RemoveTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def TrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

		def TrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedTrailingChars()
		This.RemoveRepeatedTrailingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedTrailingCharsQ()
			This.RemoveRepeatedTrailingChars()
			return This

		def RemoveTrailingRepeatedChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingRepeatedCharsQ()
				This.RemoveTrailingRepeatedChars()
				return This
	
		def RemoveTrailingChars()
			This.RemoveRepeatedTrailingChars()

			def RemoveTrailingCharsQ()
				This.RemoveTrailingChars()
				return This
	
	def RepeatedTrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedTrailingCharsQ().Content()
		return cResult

		def TrailingRepeatedCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

		def TrailingCharsRemoved()
			return This.RepeatedTrailingCharsRemoved()

////////////////////////////////////////////////////////////////////////////////	

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED LEADING AND TRAILING CHARS  # 
	#============================================================#

	def FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfChars() - n + 1
		ok
		
		anResult = [ n1, n2 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingChars()
		return This.FindRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingChars()
			return This.FindRepeatedLeadingAndTrailingChars()

		#>

	  #------------------------------------------------------------#
	 #  FINDING POSITIONS OF REPEATED TRAILING AND LEADING CHARS  # 
	#============================================================#

	def FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		# Computing the position of trailing part

		n2 = 0
		n = This.NumberOfTrailingCharsCS(pCaseSensitive)
		if n > 0
			n2 = This.NumberOfCharsCS(pCaseSensitive) - n + 1
		ok

		# Computing the position of leading part (0 if inexistant, 1 otherwise)

		n1 = 0
		if This.containsRepeatedLeadingCharsCS(pCaseSensitive)
			n1 = 1
		ok
		
		anResult = [ n2, n1 ]

		return anResult

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingChars()
		return This.FindRepeatedTrailingAndLeadingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingChars()
			return This.FindRepeatedTrailingAndLeadingChars()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED LEADING AND TRAILING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok
		
		# Composing the result

		aResult = [ [ nLead1, nLead2], [ nTrail1, nTrail2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedLeadingAndTrailingCharsAsSections()
		return This.FindRepeatedLeadingAndTrailingCharsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLeadingAndTrailingCharsAsSections()
			return This.FindRepeatedLeadingAndTrailingCharsAsSections()

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING REPEATED TRAILING AND LEADING CHARS AND RETURNING THEIR POSITIONS AS SECTIONS  # 
	#-----------------------------------------------------------------------------------------#

	def FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		# Computing the position of leading section ([0, 0] if inexistant)

		nTrail1 = 0
		nTrail2 = 0

		n = This.NumberOfTrailingCharsCS(pCaseSensitive)

		if n > 0
			nLen = This.NumberOfCharsCS(pCaseSensitive)
			nTrail1 = nLen - n + 1
			nTrail2 = nLen
		ok

		# Computing the position of leading section ([0, 0] if inexistant)

		nLead1 = 0
		nLead2 = 0
		if This.ContainsRepeatedLeadingCharsCS(pCaseSensitive)
			nLead1 = 1
			nLead1 = This.NumberOfLeadingCharsCS(pCaseSensitive)
		ok
		
		# Composing the result

		aResult = [ [ nTrail1, nTrail2], [ nLead1, nLead2] ]

		return aResult

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
			return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedTrailingAndLeadingCharsAsSections()
		return This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindTrailingAndLeadingCharsAsSections()
			return This.FindRepeatedTrailingAndLeadingCharsAsSections()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED LEADING AND TRAILING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedLeadingAndTrailingCharsCS(pCaseSensitive),
			This.FindRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		def LeadingAndTrailingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedLeadingAndTrailingCharsZ()
		return This.RepeatedLeadingAndTrailingCharsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedLeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsAndTheirPositions()
			return This.RepeatedLeadingAndTrailingCharsZ()

		def LeadingAndTrailingCharsZ()
			return This.RepeatedLeadingAndTrailingCharsZ()

		#>

	  #--------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZ()
		return This.RepeatedTrailingAndLeadingCharsCSZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsAndTheirPositions()
			return This.RepeatedTrailingAndLeadingCharsZ()

		def TrailingAndLeadingCharsZ()
			return This.RepeatedTrailingAndLeadingCharsZ()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING REPEATED TRAILING AND LEADING CHARS ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------------------#

	def RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)
		aResult = [
			This.RepeatedTrailingAndLeadingCharsCS(pCaseSensitive),
			This.FindRepeatedTrailingAndLeadingCharsAsSectionsCS(pCaseSensitive)
		]

		return aResult

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsCSZZ(pCaseSensitive)

		def TrailingAndLeadingCharsCSZZ(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsCSZZ(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RepatedTrailingAndLeadingCharsZZ()
		return This.RepeatedTrailingAndLeadingCharsCSZZ(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RepeatedTrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsAndTheirSections()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		def TrailingAndLeadingCharsZZ()
			return This.RepeatedTrailingAndLeadingCharsZZ()

		#>

	  #--------------------------------------------------#
	 #   REMOVING REPEATED LEADING AND TRAILING CHARS   #
	#==================================================#

	def RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveFirstNChars( This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive) )
			This.RemoveLastNChars( This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive) )
		ok

		def RemoveRepeatedLeadingAndTrailingCharsCSQ()
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This

		def RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingRepeatedCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingRepeatedCharsCS(pCaseSensitive)
				return This
	
		def RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
			This.RemoveRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

			def RemoveLeadingAndTrailingCharsCSQ(pCaseSensitive)
				This.RemoveLeadingAndTrailingCharsCS(pCaseSensitive)
				return This
	
	def RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsCSQ(pCaseSensitive).Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemovedCS(pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsRemovedCS(pCaseSensitive)

		def LeadingAndTrailingCharsRemovedCS(pCaseSensitive)
			return This.RepeatedTrailingCharsRemovedCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedLeadingAndTrailingChars()
		This.RemoveRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedLeadingAndTrailingCharsQ()
			This.RemoveRepeatedLeadingAndTrailingChars()
			return This

		def RemoveLeadingAndTrailingRepeatedChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingRepeatedCharsQ()
				This.RemoveLeadingAndTrailingRepeatedChars()
				return This
	
		def RemoveLeadingAndTrailingChars()
			This.RemoveRepeatedLeadingAndTrailingChars()

			def RemoveLeadingAndTrailingCharsQ()
				This.RemoveLeadingAndTrailingChars()
				return This
	
	def RepeatedLeadingAndrailingCharsRemoved()
		cResult = This.Copy().RemoveRepeatedLeadingAndTrailingCharsQ().Content()
		return cResult

		def LeadingAndTrailingRepeatedCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

		def LeadingAndTrailingCharsRemoved()
			return This.RepeatedLeadingAndTrailingCharsRemoved()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS REPEATED CHARS  #
	#==================================================#

	def HasRepeatedCharsCS(pCaseSensitive) # TODO: Test it!
		nLen = @oQString.count()
		if nLen < 2
			return FALSE
		ok

		nResult = FALSE

		for i = 2 to nLen
			if @oQString.at(i-1) = @oQString.at(i-2)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ContainsRepeatedCharsCS(pCaseSensitive)
			return This.HasRepeatedCharsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedChars()
		return This.HasRepeatedCharsCS(:CaseSensitive = TRUE)

		def ContainsRepeatedChars()
			return This.HasRepeatedChars()

	  #---------------------------------------#
	 #  FINDING POSITIONS OF REPEATED CHARS  # TODO
	#---------------------------------------#

	def FindRepeatedCharsCS(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

	#-- WITHOUT CASESENSITIVITY

	def FindRepeatedChars()
		return This.FindRepeatedCharsCS(:CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  GETTING REPEATED CHARS ALONG WITH THEIR POSITIONS  # TODO
	#-----------------------------------------------------#

	def RepeatedCharsCSZ(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

		def RepeatedCharsAndTheirPositionsCS(pCaseSensitive)
			return This.RepeatedCharsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RepatedCharsZ()
		return This.RepeatedCharsCSZ(:CaseSensitive = TRUE)

		def RepeatedCharsAndTheirPositions()
			return This.RepatedCharsZ()

	  #----------------------------------------------------#
	 #  GETTING REPEATED CHARS ALONG WITH THEIR SECTIONS  # TODO
	#----------------------------------------------------#

	def RepeatedCharsCSZZ(pCaseSensitive)
		StzRaise("Unavailable in this version of the library!")

		def RepeatedCharsAndTheirSectionsCS(pCaseSensitive)
			return This.RepeatedCharsCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RepatedCharsZZ()
		return This.RepeatedCharsCSZZ(:CaseSensitive = TRUE)

		def RepeatedCharsAndTheirSecions()
			return This.RepatedCharsZZ()

	  #-------------------------#
	 #  REMOVE REPEATED CHARS  #
	#-------------------------#

	def RemoveRepeatedCharsCS(pCaseSensitive)
		cResult = This.CharsQ().
			  RemoveDuplicatesQR(:stzListOfStrings).Concatenated()

		This.UpdateWith(cResult)

		def RemoveRepeatedCharsCSQ(pCaseSensitive)
			This.RemoveRepeatedCharsCS(pCaseSensitive)
			return This

	def RepeatedCharsRemovedCS(pCaseSensitive)
		cResult = This.Copy().RemoveRepeatedCharsCSQ(pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveRepeatedChars()
		return This.RemoveRepeatedCharsCS(:CaseSensitive = TRUE)

		def RemoveRepeatedCharsQ()
			This.RemoveRepeatedChars()
			return This

	def RepeatedCharsRemoved()
		return This.RepeatedCharsRemovedCS(:CaseSensitive = TRUE)
		
	  #----------------------------------------------------------#
	 #  CHECHKING IF THE STRING HAS LEADING AND TRAILING CHARS  #
	#----------------------------------------------------------#

	def HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
		if This.HasRepeatedLeadingCharsCS(pCaseSensitive) and
		   This.HasRepeatedTrailingCharsCS(pCaseSensitive)

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def HasTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#--

		def ContainsRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsRepeatedTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsLeadingAndTrailingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		def ContainsTrailingAndLeadingCharsCS(pCaseSensitive)
			return This.HasRepeatedLeadingAndTrailingCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def HasRepeatedLeadingAndTrailingChars()
		return This.HasRepeatedLeadingAndTrailingCharsCS(:CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def HasRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def HasTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#--

		def ContainsRepeatedLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsRepeatedTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsLeadingAndTrailingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		def ContainsTrailingAndLeadingChars()
			return This.HasRepeatedLeadingAndTrailingChars()

		#>

	  #--------------------------------------------#
	 #   REMOVING A GIVEN REPEATED LEADING CHAR   #
	#============================================#

	def RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedLeadingCharsCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveThisLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveThisLeadingCharCS(c, pCaseSensitive)
				return This

		def RemoveRepeatedLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveRepeatedLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveRepeatedLeadingCharCS(c, pCaseSensitive)
				return This

		def RemoveLeadingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedLeadingCharCS(c, pCaseSensitive)

			def RemoveLeadingCharCSQ(c, pCaseSensitive)
				This.RemoveLeadingCharCS(c, pCaseSensitive)
				return This

	def ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisLeadingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def ThisLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

		def RepeatedLeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

			def RepeatedLeadingCharRemovedCSQ(c, pCaseSensitive)
				This.RepeatedLeadingCharRemovedCS(c, pCaseSensitive)
				return This

		def LeadingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedLeadingCharRemovedCS(c, pCaseSensitive)

			def LeadingCharRemovedCSQ(c, pCaseSensitive)
				This.LeadingCharRemovedCSQ(c, pCaseSensitive)
				return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedLeadingChar(c)
		if This.RepeatedLeadingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedLeadingCharCS(c, :CaseSensitive = TRUE)
		ok

		def RemoveThisRepeatedLeadingCharQ(c)
			This.RemoveThisRepeatedLeadingChar(c)
			return This

		def RemoveThisLeadingRepeatedChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingRepeatedCharQ(c)
				This.RemoveThisLeadingRepeatedChar(c)
				return This

		def RemoveThisLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveThisLeadingCharQ(c)
				This.RemoveThisLeadingChar(c)
				return This

		def RemoveRepeatedLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveRepeatedLeadingCharQ(c)
				This.RemoveRepeatedLeadingChar(c)
				return This

		def RemoveLeadingChar(c)
			This.RemoveThisRepeatedLeadingChar(c)

			def RemoveLeadingCharQ(c)
				This.RemoveLeadingChar(c)
				return This

	def ThisRepeatedLeadingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedLeadingCharQ(c).Content()
		return cResult

		def ThisLeadingRepeatedCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def ThisLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def RepeatedLeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

		def LeadingCharRemoved(c)
			return This.ThisRepeatedLeadingCharRemoved(c)

	  #---------------------------------------------#
	 #   REMOVING A GIVEN REPEATED TRAILING CHAR   #
	#---------------------------------------------#

	def RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveRepeatedTrailingCharsCS(pCaseSensitive)
		ok

		def RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)
			return This

		def RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingRepeatedCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingRepeatedCharCS(c, pCaseSensitive)
				return This

		def RemoveThisTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveThisTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveThisTrailingCharCS(c, pCaseSensitive)
				return This

		def RemoveRepeatedTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisTrailingLeadingCharCS(c, pCaseSensitive)

			def RemoveRepeatedTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveRepeatedTrailingCharCS(c, pCaseSensitive)
				return This

		def RemoveTrailingCharCS(c, pCaseSensitive)
			This.RemoveThisRepeatedTrailingCharCS(c, pCaseSensitive)

			def RemoveTrailingCharCSQ(c, pCaseSensitive)
				This.RemoveTrailingCharCS(c, pCaseSensitive)
				return This

	def ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharCSQ(c, pCaseSensitive).Content()
		return cResult

		def ThisTrailingRepeatedCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemoved(c, pCaseSensitive)

		def ThisTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemoved(c, pCaseSensitive)

		def RepeatedTrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

		def TrailingCharRemovedCS(c, pCaseSensitive)
			return This.ThisRepeatedTrailingCharRemovedCS(c, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisRepeatedTrailingChar(c)
		if This.RepeatedTrailingCharQ().IsEqualTo(c)
			This.RemoveThisRepeatedTrailingCharCS(c, :CaseSensitive = TRUE)
		ok

		def RemoveThisRepeatedTrailingCharQ(c)
			This.RemoveThisRepeatedTrailingChar(c)
			return This

		def RemoveThisTrailingRepeatedChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingRepeatedCharQ(c)
				This.RemoveThisTrailingRepeatedChar(c)
				return This

		def RemoveThisTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveThisTrailingCharQ(c)
				This.RemoveThisTrailingChar(c)
				return This

		def RemoveRepeatedTrailingChar(c)
			This.RemoveThisTrailingChar(c)

			def RemoveRepeatedTrailingCharQ(c)
				This.RemoveRepeatedTrailingChar(c)
				return This

		def RemoveTrailingChar(c)
			This.RemoveThisRepeatedTrailingChar(c)

			def RemoveTrailingCharQ(c)
				This.RemoveTrailingChar(c)
				return This

	def ThisRepeatedTrailingCharRemoved(c)
		cResult = This.Copy().RemoveThisRepeatedTrailingCharQ(c).Content()
		return cResult

		def ThisTrailingRepeatedCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def ThisTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def RepeatedTrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

		def TrailingCharRemoved(c)
			return This.ThisRepeatedTrailingCharRemoved(c)

	  #--------------------------------------------------------#
	 #   REMOVING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#--------------------------------------------------------#

	def RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
		This.RemoveThisRepeatedLeadingCharCS(c1, pCaseSensitive)
		This.RemoveThisRepeatedTrailingCharCS(c2, pCaseSensitive)
		
		def RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			return This

		def RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndRepeatedCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndRepeatedCharsCS(c1, c2, pCaseSensitive)
				return This

		def RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
			This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)

			def RemoveTheseLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive)
				This.RemoveTheseLeadingAndTrailingCharsCS(c1, c2, pCaseSensitive)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, pCaseSensitive).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

		def TheseLeadingAndTrailingCharsRemovedCS(c1, c2, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
		This.RemoveTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, :CaseSensitive = TRUE)

		def RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)
			return This

		def RemoveTheseLeadingAndRepeatedChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndRepeatedCharsQ(c1, c2)
				This.RemoveTheseLeadingAndRepeatedChars(c1, c2)
				return This

		def RemoveTheseLeadingAndTrailingChars(c1, c2)
			This.RemoveTheseRepeatedLeadingAndTrailingChars(c1, c2)

			def RemoveTheseLeadingAndTrailingCharsQ(c1, c2)
				This.RemoveTheseLeadingAndTrailingChars(c1, c2)
				return This

	def TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
		cResult = This.Copy().RemoveTheseRepeatedLeadingAndTrailingCharsQ(c1, c2).Content()
		return cResult

		def TheseLeadingAndRepeatedCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)

		def TheseLeadingAndTrailingCharsRemoved(c1, c2)
			return This.TheseRepeatedLeadingAndTrailingCharsRemoved(c1, c2)
	
	  #==========================================#
	 #   REPLACING EACH REPEATED LEADING CHAR   #
	#==========================================#

	def ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("aaaAAAH RING!").
		ReplaceEachLeadingCharCS( :With = "O", :CS = TRUE)
		--> Gives: "OOOAAAH RING!"

		StzStringQ("aaaAVAR").
		ReplaceEachLeadingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "OOOOOOH RING!"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedLeadingCharsCS(pCaseSensitive)

		if n > 0
			This.ReplaceSection(
				1, n,
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.REachepeatedLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingChar(cNewSubStr)

		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingCharQ(cNewSubStr)
				This.ReplaceEachLeadingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingChar(cNewSubStr)

			def ReplaceEachLeadingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachLeadingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedLeadingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedLeadingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachLeadingCharEachReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

		def EachLeadingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingCharReplaced(cNewSubStr)

	  #----------------------------------#
	 #   REPLACING EACH TRAILING CHAR   #
	#----------------------------------#

	def ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		/* Example:

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", :CS = TRUE)
		--> Gives: "RINGaaaOOO"

		StzStringQ("RINGaaaAAA").
		ReplaceEachRepeatedTrailingCharCS( :With = "O", :CS = FALSE)
		--> Gives: "RINGOOOOOO"

		*/

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		n = This.NumberOfRepeatedTrailingCharsCS(pCaseSensitive)

		if n > 0
			nStart = This.NumberOfChars() - n + 1
			This.ReplaceSection(
				nStart, This.NumberOfChars(),
				StzStringQ(cNewSubStr).RepeatedNTimes(n)
			)
		ok

		#< @FunctionFluentForm


		def ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingRepeatedCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingRepeatedCharCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def EachTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingRepeatedCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedTrailingChar(cNewSubStr)

		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedTrailingCharQ(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingCharQ(cNewSubStr)
				This.ReplaceEachTrailingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingRepeatedChar(cNewSubStr)
			This.ReplaceEachRepeatedTrailingChar(cNewSubStr)

			def ReplaceEachTrailingRepeatedCharQ(cNewSubStr)
				This.ReplaceEachTrailingRepeatedChar(cNewSubStr)
				return This
		#>

	def EachRepeatedTrailingCharReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceEachRepeatedTrailingCharQ(cNewSubStr).
			  Content()

		return cResult

		def EachTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

		def EachTrailingRepeatedCharReplaced(cNewSubStr)
			return This.EachRepeatedTrailingCharReplaced(cNewSubStr)

	  #-----------------------------------------------#
	 #   REPLACING EACH LEADING AND TRAILING CHARS   #
	#-----------------------------------------------#

	def ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedLeadingCharCS(cNewSubStr, pCaseSensitive)
		This.ReplaceEachRepeatedTrailingCharCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		#-- Char withous "s"

		def ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingAndTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingAndTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingAndLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingAndLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachLeadingOrTrailingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachLeadingOrTrailingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachRepeatedTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachRepeatedTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
			This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceEachTrailingOrLeadingCharCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceEachTrailingOrLeadingCharCS(cNewSubStr, pCaseSensitive)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceEachRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingAndTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingAndLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingandTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachRepeatedTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachLeadingOrTrailingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def EachTrailingOrLeadingCharReplacedCS(cNewSubStr, pCaseSensitive)
			return This.EachRepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceEachRepeatedLeadingAndTrailingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceEachLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChars(cNewSubStr)
				return This

		#-- Char without "s"

		def ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingAndTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingAndTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingAndTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingAndLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingAndLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingAndLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingAndLeadingChar(cNewSubStr)
				return This

		#-- "Or" instead of "And"

		def ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachLeadingOrTrailingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachLeadingOrTrailingCharQ(cNewSubStr)
				This.ReplaceEachLeadingOrTrailingChar(cNewSubStr)
				return This

		def ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachRepeatedTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachRepeatedTrailingOrLeadingChar(cNewSubStr)
				return This

		def ReplaceEachTrailingOrLeadingChar(cNewSubStr)
			This.ReplaceEachRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceEachTrailingOrLeadingCharQ(cNewSubStr)
				This.ReplaceEachTrailingOrLeadingChar(cNewSubStr)
				return This

		#>

	def EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		return This.ReplaceEachRepeatedLeadingAndTrailingCharsQ(cNewSubStr).Content()

		#< @FunctionAlternativeForms

		def EachRepeatedTrailingAndLeadingCharsReplace(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplace(cNewSubStr)

		def EachLeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharsReplaced()
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- Char without "s"

		def EachRepeatedLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingAndTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingAndLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#-- "Or" instead of "And"

		def EachRepeatedLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachRepeatedTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachLeadingOrTrailingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def EachTrailingOrLeadingCharReplaced(cNewSubStr)
			return This.EachRepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		#>

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedLeadingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceFirstNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
			This. ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		def ReplaceRepeatedLeadingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)
			return This

		def ReplaceLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingChars(cNewSubStr)

			def ReplaceLeadingCharsQ(cNewSubStr)
				This.ReplaceLeadingChars(cNewSubStr)
				return This

	def RepeatedLeadingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedLeadingCharsQ(cNewSubStr).Content()

		def LeadingCharsReplaced(cNewSubStr
			return This.RepeatedLeadingCharReplaced(wNewSubStr)

	  #--------------------------------------#
	 #   REPLACING REPEATED LEADING CHARS   #
	#--------------------------------------#

	def ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
		cRepeated = This.RepeatedTrailingCharsCS(pCaseSensitive)
		nLen = Q(cRepeated).NumberOfChars()
		if nLen > 0
			This.ReplaceLastNChars( nLen, cNewSubStr)
		ok

		def ReplaceRepeatedTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This. ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		def ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

	def RepeatedTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedTrailingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, :CaseSensitive = TRUE)

		def ReplaceRepeatedTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)
			return This

		def ReplaceTrailingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingChars(cNewSubStr)

			def ReplaceTrailingCharsQ(cNewSubStr)
				This.ReplaceTrailingChars(cNewSubStr)
				return This

	def RepeatedTrailingCharsReplaced(wNewSubStr)
		return This.Copy().ReplaceRepeatedTrailingCharsQ(cNewSubStr).Content()

		def TrailingCharsReplaced(cNewSubStr
			return This.RepeatedTrailingCharReplaced(wNewSubStr)

	  #---------------------------------------------------#
	 #   REPLACING REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------#
	
	def ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedLeadingCharsCS(cNewSubStr, pCaseSensitive)
		This.ReplaceRepeatedTrailingCharsCS(cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedLeadingAndTrailingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceLeadingAndTrailingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingAndTrailingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
			This.ReplaceRepeatedTrailingAndLeadingCharsCS(cNewSubStr, pCaseSensitive)

			def ReplaceTrailingAndLeadingRepeatedCharsCSQ(cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingAndLeadingRepeatedCharsCS(cNewSubStr, pCaseSensitive)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsCSQ(cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def LeadingAndTrailingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedLeadingAndTrailingCharsReplacedCS(cNewSubStr, pCaseSensitive)

		def TrailingAndLeadingRepeatedCharsReplacedCS(cNewSubStr, pCaseSensitive)
			return This.RepeatedTrailingAndLeadingCharsReplacedCS(cNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
		This.ReplaceRepeatedLeadingChars(cNewSubStr)
		This.ReplaceRepeatedTrailingChars(cNewSubStr)

		#< @FunctionFluentForm

		def ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceRepeatedTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingChars(cNewSubStr)
				return This

		def ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedLeadingAndTrailingChars(cNewSubStr)

			def ReplaceLeadingAndTrailingRepeatedCharsQ(cNewSubStr)
				This.ReplaceLeadingAndTrailingRepeatedChars(cNewSubStr)
				return This

		def ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
			This.ReplaceRepeatedTrailingAndLeadingChars(cNewSubStr)

			def ReplaceTrailingAndLeadingRepeatedCharsQ(cNewSubStr)
				This.ReplaceTrailingAndLeadingRepeatedChars(cNewSubStr)
				return This
		#>

	def RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceRepeatedLeadingAndTrailingCharsQ(cNewSubStr).
			  Content()

		return cResult

		def RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

		def LeadingAndTrailingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedLeadingAndTrailingCharsReplaced(cNewSubStr)

		def TrailingAndLeadingRepeatedCharsReplaced(cNewSubStr)
			return This.RepeatedTrailingAndLeadingCharsReplaced(cNewSubStr)

	  #---------------------------------------------#
	 #   REPLACING A GIVEN REPEATED LEADING CHAR   #
	#---------------------------------------------#

	def ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if NOT This.HasRepeatedLeadingCharsCS(pCaseSensitive)
			return
		ok

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedLeadingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfLeadingChars()
			This.ReplaceFirstNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceLeadingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceLeadingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisLeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def LeadingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedLeadingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedLeadingCharCS(c, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingChar(c, cNewSubStr)
				return This

		def ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceThisLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisLeadingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceRepeatedLeadingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingCharQ(c, cNewSubStr)
				This.ReplaceLeadingChar(c, cNewSubStr)
				return This

		def ReplaceLeadingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedLeadingChar(c, cNewSubStr)

			def ReplaceLeadingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceLeadingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedLeadingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedLeadingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def ThisLeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedLeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		def LeadingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedLeadingCharReplaced(c, cNewSubStr)

		#>

	  #----------------------------------------------#
	 #   REPLACING A GIVEN REPEATED TRAILING CHAR   #
	#----------------------------------------------#

	def ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(cNewSubStr) and StzListQ(cNewSubStr).IsWithOrByNamedParam()
			cNewSubStr = cNewSubStr[2]
		ok

		if This.RepeatedTrailingCharQ().IsEqualToCS(c, pCaseSensitive)
			n = This.NumberOfTrailingChars()
			This.ReplaceLastNChars(n, :With = cNewSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceThisTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceThisTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		#--

		def ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingCharCS(c, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
			This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, pCaseSensitive)

			def ReplaceTrailingRepeatedCharCSQ(c, cNewSubStr, pCaseSensitive)
				This.ReplaceTrailingRepeatedCharCS(c, cNewSubStr, pCaseSensitive)
				return This
		#>

	def ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharCSQ(c, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def ThisTrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#--

		def RepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		def TrailingRepeatedCharReplacedCS(c, cNewSubStr, pCaseSensitive)
			return This.ThisRepeatedTrailingCharReplacedCS(c, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

		This.ReplaceThisRepeatedTrailingCharCS(c, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceThisTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingChar(c, cNewSubStr)
				return This

		def ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceThisTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceThisTrailingRepeatedChar(c, cNewSubStr)
				return This

		#--

		def ReplaceRepeatedTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceRepeatedTrailingCharQ(c, cNewSubStr)
				This.ReplaceRepeatedTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingCharQ(c, cNewSubStr)
				This.ReplaceTrailingChar(c, cNewSubStr)
				return This

		def ReplaceTrailingRepeatedChar(c, cNewSubStr)
			This.ReplaceThisRepeatedTrailingChar(c, cNewSubStr)

			def ReplaceTrailingRepeatedCharQ(c, cNewSubStr)
				This.ReplaceTrailingRepeatedChar(c, cNewSubStr)
				return This

		#>

	def ThisRepeatedTrailingCharReplaced(c, cNewSubStr)
		cResult = This.
			  Copy().
			  ReplaceThisRepeatedTrailingCharQ(c, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def ThisTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def ThisTrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#--

		def RepeatedTrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		def TrailingRepeatedCharReplaced(c, cNewSubStr)
			return This.ThisRepeatedTrailingCharReplaced(c, cNewSubStr)

		#>

	  #---------------------------------------------------------#
	 #   REPLACING GIVEN REPEATED LEADING AND TRAILING CHARS   #
	#---------------------------------------------------------#

	def ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
	
		This.ReplaceThisRepeatedLeadingCharCS(c1, cNewSubStr, pCaseSensitive)
		This.ReplaceThisRepeatedTrailingCharCS(c2, cNewSubStr, pCaseSensitive)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
			This.ReplaceTheseRepeatedTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

				These.ReplaceTheseRepeatedTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseLeadingAndTrailingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
			These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, pCaseSensitive)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive)
				These.ReplaceTheseTrailingAndLeadingRepeatedCharsCS(c1, c2, cNewSubStr, pCaseSensitive)
				return This
		
		#>

	def TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr, pCaseSensitive).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseLeadingAndTrailingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		def TheseTrailingAndLeadingRepeatedCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)
			return This.TheseRepeatedLeadingAndTrailingCharsReplacedCS(c1, c2, cNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

		These.ReplaceTheseRepeatedLeadingAndTrailingCharsCS(c1, c2, cNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceTheseRepeatedLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

				These.ReplaceTheseRepeatedTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseLeadingAndTrailingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseLeadingAndTrailingRepeatedChars(c1, c2, cNewSubStr)
				return This

		def ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
			These.ReplaceTheseRepeatedLeadingAndTrailingChars(c1, c2, cNewSubStr)

			def ReplaceTheseTrailingAndLeadingRepeatedCharsQ(c1, c2, cNewSubStr)
				These.ReplaceTheseTrailingAndLeadingRepeatedChars(c1, c2, cNewSubStr)
				return This

		#>

	def TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
		cResult = These.
			  Copy().
			  ReplaceTheseRepeatedLeadingAndTrailingCharsCSQ(c1, c2, cNewSubStr).
			  Content()

		return cResult

		#< @FunctionAlternativeForms

		def TheseRepeatedTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseLeadingAndTrailingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		def TheseTrailingAndLeadingRepeatedCharsReplaced(c1, c2, cNewSubStr)
			return This.TheseRepeatedLeadingAndTrailingCharsReplaced(c1, c2, cNewSubStr)

		#>

	  #===============================#
	 #     FORWARD TO END OF LINE    #
        #===============================#

	def ForwardToEndOfLine(nStart)

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		bInside = TRUE
		cResult = ""
		i = nStart - 1

		while bInside
			i++
						 
			if i = This.NumberOfChars() or
			   This.CharAtQ(i).IsLineSeparator()
			   
				bInside = FALSE

			else
				cResult += This.NthChar(i)
			ok	
		end

		return cResult

		#< @FunctionFluentForm
	
		def ForwardToEndOfLineQ(nStart)
			return new stzString( This.ForwardToEndOfLine(nStart) )
	
		#>

	  #----------------------------------#
	 #     BACKWARD TO START OF LINE    #
        #----------------------------------#

	def BackwardToStartOfLine( nStart )

		/* Example:
	
			o1 = new stzString( "Mohammed Ali
				Ben Salah" )
			? o1.BackwardToStartOfLine( :StartingAt = 16 ) #--> Ben
			
		*/

		# Enabling the :StartingAt syntax

		if isList(nStart) and len(nStart) = 2 and
		   nStart[1] = :StartingAt and isNumber(nStart[2])

			nStart = nStart[2]

		ok

		# Checking the range of possible values for nStart param

		if nStart < 1 or nStart > This.NumberOfChars()
			return NULL
		ok

		# Computing the rest of the line

		bInside = TRUE
		cResult = ""
		i = nStart + 1

		while bInside
			i--
					 
			if i = 0 or This.CharAtQ(i).IsLineSeparator()

				bInside = FALSE
			
			else
				cResult += This.NthChar(i)
			ok
				
		end

		return StringReverse(cResult)

		#< @FunctionFluentForm

		def BackwardToStartOfLineQ( nStart )
			return new stzString( This.BackToStartOfLine( nStart ) )
	
		#>

	  #------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING   #
	#------------------------------------------------#

	// Returns a subset of the string between n1 and n2 positions
	def Section(n1, n2)

		# Managing the use of :From and :To named params

		if isList(n1) and
		   StzListQ(n1).IsOneOfTheseNamedParams([
				:From, :FromPosition,
				:StartingAt, :StartingAtPosition
				])

			n1 = n1[2]
		ok

		if isList(n2) and
		   StzListQ(n2).IsOneOfTheseNamedParams([
				:To, :ToPosition,
				:Until, :UntilPosition,
				:UpTo, :UpToPosition
				])

			n2 = n2[2]
		ok

		# Managing the use of :NthToFirst named param

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
					:NthToFirst, :NthToFirstChar ])

			n1 = n1[2] + 1
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
					:NthToFirst, :NthToFirstChar ])

			n2 = n2[2] + 1
		ok

		# Managing the use of :NthToLast named param

		if isList(n1) and Q(n1).IsOneOfTheseNamedParams([
					:NthToLast, :NthToLastChar ])

			n1 = This.NumberOfChars() - n1[2]
		ok

		if isList(n2) and Q(n2).IsOneOfTheseNamedParams([
					:NthToLast, :NthToLastChar ])

			n2 = This.NumberOfChars() - n2[2]

		but isList(n2) and Q(n2).IsStoppingAtNamedParam()

			n2 = n2[2]
		ok

		# Managing the case of :First and :Last keywords

		if isString(n1)
			if Q(n1).IsOneOfThese([ :First, :FirstChar ])
				n1 = 1

			but Q(n1).IsOneOfThese([ :Last, :LastChar ])
				n1 = This.NumberOfChars()

			but n1 = :@
				n1 = n2
			ok
		ok
	
		if isString(n2)
			if Q(n2).IsOneOfThese([ :Last, :LastChar, :EndOfString ])
				n2 = This.NumberOfChars()

			but Q(n2).IsOneOfThese([ :First, :FirstChar ])
				n2 = 1

			but n2 = :@
				n2 = n1
			ok
		ok

		if n1 = :@ and n2 = :@
			n1 = 1
			n2 = This.NumberOfChars()
		ok

		if n1 < 0
			n1 = This.NumberOfItems() + n1 + 1
		ok

		if n2 < 0
			n2 = This.NumberOfItems() + n2 + 1
		ok

		# If the params are not numbers, so find them and take their positions
		# EXAMPLE: ? Q("SOFTANZA").Section(:From = "F", :To = "A") #--> "FTA"

		if isString(n1)
			n1 = This.FindFirst(n1)
		ok

		if NOT isNumber(n1)
			n1 = This.FindFirst(n1)
		ok

		# Managing the case of :EndOfSentence, :EndOfLine, and :EndOfWord keywords

		if n1 > 0 and n2 = :EndOfSentence
			return This.ToStzText().ForwardToEndOfSentence( :StartingAt = n1 )
		ok

		if n1 > 0 and n2 = :EndOfLine
			return This.ForwardToEndOfLine( :StartingAt = n1 )
		ok

		if n1 > 0 and n2 = :EndOfWord # TODO: should move to stzText?
			return This.ToStzText().ForwardToEndOfWord( :StartingAt = n1 )
		ok

		if isString(n2)
			n2 = This.FindFirst(n2)
		ok

		if NOT isNumber(n2)
			n2 = This.FindFirst(n2)
		ok

		# Params must be numbers

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect params! n1 and n2 must be numbers.")
		ok

		# Managing out of range params

		if NOT 	( Q(n1).IsBetween(1, this.NumberOfChars()) and
			  Q(n2).IsBetween(1, this.NumberOfChars())
			)
			
			return NULL
		ok

		# Finally, we're ready to extract the section...
		# NOTE: when positions are given in inversed order
		#--> Revert them!

		if n1 = n2
			cResult = This.Char(n1)

		but n1 < n2
			cResult = This.QStringObject().mid( (n1 - 1) , (n2 - n1 + 1) )

		else // n2 < n1
			cResult = This.Section(n2, n1)

		ok

		return cResult

		#< @FunctionFluentForm

		def SectionQ(n1, n2)
			return new stzString( This.Section(n1, n2) )

		#>

		#< @FunctionAlternativeForm

		def Slice(n1, n2)
			return This.Section(n1, n2)

			#< @FunctionFluentForm

			def SliceQ(n1, n2)
				return This.SectionQ(n1, n2)

			#>
		#>	

	  #----------------------------------------------------------#
	 #   GETTING A SECTION (OR SLICE) OF THE STRING -- EXTENDED  #
	#----------------------------------------------------------#

	def SectionXT(n1, n2)
		aResult = [ This.Section(n1, n2), [n1, n2] ]
		return aResult

		def SliceXT(n1, n2)
			return This.Secrion(n1, n2)

	  #-----------------------------------#
	 #   GETTING A RANGE OF THE STRING   #
	#-----------------------------------#

	// Returns a subset of the string starting from nStart and ranging over nRange Chars
	def Range(nStartPos, nRange)
		
		# Chacking params

		if isString(nStartPos)
			if nStartPos = :First or nStartPos = :FirstChar
				nStartPos = 1

			but nStartPos = :Last or nStartPos = :LastChar
				nStartPos = This.NumberOfChars()
			ok
		ok

		if NOT BothAreNumbers(nStartPos, nRange)
			StzRaise("Incorrect param type! nStartPos and nRange must be both numbers.")
		ok

		# Doing the job

		if nStartPos < 0
			nStartPos = This.NumberOfChars() + nStartPos + 1
		ok

		if nStartPos = 0 or nRange = 0
			return NULL
		ok

		cResult = ""

		if nRange > 0
			cResult = This.Section( nStartPos, nStartPos + nRange -1 )

		else
			n1 = nStartPos + nRange + 1

			if n1 > 0
				cResult = This.Section( n1, nStartPos )
			ok	
		ok

		return cResult

		#< @FunctionFluentForm

		def RangeQ(nStartPos, nRange)
			return new stzString( This.Range(nStartPos, nRange) )
	
		#>

		#< @FunctionNamedParamForm

		def nmdRange(paParams)
			
			// Default values
			nStartPos = 1
			nRange = This.NumberOfChars()

			// Reading the params
			if StzListQ(paParams).IsRangeNamedParam()
				if isNumber(paParams[ :Start ])
					nStartPos = paParams[ :Start ]
				ok

				if isNumber(paParams[ :Range ])
					nRange = paParams[ :Range ]
				ok

				return This.Range(nStartPos, nRange)
			else
				stzRaise("Incorrect params!")
			ok

		#>

		#< @FunctionInfoForm

		def infRange()
			return [
				:Syntax = "Range(pnstart, pnRange)",
				:Description = "Returns pnRange chars starting at pnStart position",
				:ReturnType = "STRING",
				:NumberOfParams = 2,
				:Params = [
					[
						:Param = "pnStart",
						:Type = "NUMBER",
						:Description = "Start position",
						:Default = 1
					],
					[
						:Param = "pnRange",
						:Type = "NUMBER",
						:Description = "Number of chars of the range",
						:Default = This.NumberOfChars()
					]
				]
			]
		#>

		#< @FunctionDefaultForm

		def dftRange()
			return This.nmdRange([ :Start = 1, :Range = This.NumberOfChars() ])

		#>

		#< @FunctionExampleForm

		def expRange()
			return 	'StzStringQ("Ring programming language").Range(6, 11)' + NL +
				'--> "programming"'

		#>

		#< @FunctionRandomForm

		def rndRange()
			nStart = random( This.NumberOfChars() )
			nRange = random( This.NumberOfChars() - nStart )

			return 	'This.Range(' + nStart + ', ' + nRange + ')' + NL +
				'--> ' + This.Range(nStart, nRange)

		#>

		#< @FunctionTestForm

		def tstRange()
			nCases = This.tstRangeXT()[ :NumberOfTestCases ]
			nSucceeded = This.tstRangeXT()[ :NumberOfSuccessfulCases ]
			nFailed = This.tstRangeXT()[ :NumberOfFailedCases ]


			if nCases = 0
				return "Failed! (" + nFailed + "/" + nCases + ")"

			but nFailed = 0
				return "SUCCESS! (" + nSucceeded + "/" + nCases + ")"
			ok

			if nSucceeded != 0
				return "FAILED! (" + nFailed + "/" + nCases + ")"
			ok

		def tstRangeXT()
			aTestCases = [
			['StzStringQ("Ringorialand").Range(9, 4)' , 'land'],
			['StzStringQ("Ringorialand").Range(1, 4)' , 'Ring'],
			['StzStringQ("Ringorialand").Range(4, 6)' , 'gorial']
			]

			aSucceeded = []
			aFailed = []
			i = 0

			for aTest in aTestCases
				i++
				cCode = "cResult = " + aTest[1]

				try
					 eval(cCode)

					if cResult = aTest[2]
						aSucceeded + i
					else
						aFailed + i
					ok
				catch
					aFailed + i
				done
			next
			
			aResult = [
				:NumberOfTestCases = len(aTestCases),
				:NumberOfSuccessfulCases = len(aSucceeded),
				:NumberOfFailedCases = len(aFailed),

				:SuccessfulCases = aSucceeded,
				:FailedCases = aFailed,

				:TestCases = aTestCases
			]

			return aResult

		#>

	  #--------------------------------------------#
	 #  GETTING A RANGEOF THE STRING -- EXTENDED  #
	#--------------------------------------------#

	def RangeXT(nStartPos, nRange)
		aResult = [ This.Range(nStartPos, nRange), [nStartPos, nRange] ]
		return aResult

	  #---------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES)   #
	#---------------------------------------#

	def Sections(paSections)

		if isString(paSections) or
			(isList(paSections) and
				(Q(paSections).IsOfNamedParam() or
					Q(paSections).IsOfSubStringNamedParam()
				)
			)

			return This.FindAsSections(paSections)
		ok

		if NOT 	( isList(paSections) and
				Q(paSections).IsListOfPairsOfNumbers()
			)

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		for aSection in paSections
			aResult + This.Section( aSection[1], aSection[2] )
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsQ(paSections)
			return This.SectionsQR(paSections, :stzList)

		def SectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Sections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.Sections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySections(paSections)
			return This.Sections(paSections)

			def ManySectionsQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySectionsQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def Slices(paSections)
			return This.Sections(paSections)

			def SlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def SlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		def ManySlices(paSections)
			return This.Sections(paSections)

			def ManySlicesQ(paSections)
				return This.SectionsQ(paSections)
	
			def ManySlicesQR(paSections, pcReturnType)
				return This.SectionsQR(paSections, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #   GETIING MANY SECTIONS (OR SLICES) -- EXTENDED  #
	#--------------------------------------------------#

	def SectionsXT(paSections)

		aResult = []

		for aSection in paSections
			cSection = This.Section( aSection[1], aSection[2] )
			aResult + [ cSection, aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsXTQ(paSections)
			return This.SectionsXTQR(paSections, pcReturnType)

		def SectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def ManySectionsXT(paSections)
			return This.SectionsXT(paSections)

			def ManySectionsXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySectionsXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def SlicesXT(paSections)
			return This.SectionsXT(paSections)

			def SlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def SlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		def ManySlicesXT(paSections)
			return This.SectionsXT(paSections)

			def ManySlicesXTQ(paSections)
				return This.SectionsXTQ(paSections)
	
			def ManySlicesXTQR(paSections, pcReturnType)
				return This.SectionsXTQR(paSections, pcReturnType)

		#>

	  #----------------------------------------------------------#
	 #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def NumberOfAntiSections(paSections)
		nResult = len( StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content() )

		return nResult

		#< @FunctionAlternativeForms

		def CountAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSections(paSections)
			return This.NumberOfAntiSections(paSections)

		def HowManyAntiSection(paSections)
			return This.NumberOfAntiSections(paSections)

		#>

	   #-------------------------------------------------------------#
	  #   FINDING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS AND  #
	 #  RETURNING THEM AS PAIRS OF NUMBERS                         #
	#-------------------------------------------------------------#

	def FindAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
			  FindAntiSectionsQ(paSections).
			  Content()

		return aResult

		def FindAntiSectionsQ(paSections)
			return new stzList( This.FindAntiSections(paSections) )

		def AntiSectionsAsPairsOfNumbers(paSections)
			return This.FindAntiSections(paSections)

			def AntiSectionsAsPairsOfNumbersQ(paSections)
				return This.AntiSectionsAsPairsOfNumbers(paSections)

	  #----------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#----------------------------------------------------------#

	def AntiSections(paSections)
		/* EXAMPLE
		o1 = new stzList("ABCDEFGHIJ")
		? o1.AntiSections( :Of = [ [3,5], [7,8] ])
		#--> [ "AB", "F", "IJ" ]
		*/

		aResult = This.Sections( This.AntiSectionsAsPairsOfNumbers(paSections) )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsQ(paSections)
			return This.AntiSectionsQR(paSections, pcReturnType)

		def AntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThan(paSections)
			return This.AntiSections(paSections)

			def SectionsOtherThanQ(paSections)
				return This.AntiSectionsQ(paSections)
	
			def SectionsOtherThanQR(paSections, pcReturnType)
				return This.AntiSectionsQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------------------#
	 #   GETIING THE ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#---------------------------------------------------------------------#

	def AntiSectionsXT(paSections)

		aAntiSections = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(paSections).
				Content()

		aResult = This.SectionsXT( aAntiSections )

		return aResult

		#< @FunctionFluentForm

		def AntiSectionsXTQ(paSections)
			return This.AntiSectionsXTQR(paSections, pcReturnType)

		def AntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.AntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.AntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SectionsOtherThanXT(paSections)
			return This.AntiSectionsXT(paSections)

			def SectionsOtherThanXTQ(paSections)
				return This.AntiSectionsXTQ(paSections)
	
			def SectionsOtherThanXTQR(paSections, pcReturnType)
				return This.AntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #---------------------------------------------------------#
	 #   GETIING NTH ANTI-SECTION OF A GIVEN SET OF SECTIONS   #
	#---------------------------------------------------------#

	def NthAntiSection(n, paSections)
		if n = :First or n = :FirstAntiSection
			n = 1
		but n = :Last or n = :LastAntiSection
			n = This.NumberOfAntiSections(paSections)
		ok

		return This.AntiSections(paSections)[n]

	def FirstAntiSection(paSections)
		return This.NthAntiSections(1, paSections)

	def LastAntiSection(paSections)
		return This.NthAntiSection(:Last, paSections)

	  #-------------------------------------------------------------------#
	 #   FINDING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#

	def FindAsSectionsAndAntiSections(paSections)

		aResult = StzListQ( 1 : This.NumberOfChars() ).
				FindAsSectionsAndAntiSectionsQ(paSections).
				Content()

		return aResult

		#< @FunctionFluentForm

		def FindAsSectionsAndAntiSectionsQ(paSections)
			return This.FindAsSectionsAndAntiSectionsQR(paSections, :stzList)

		def FindAsSectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsAndAntiSections(paSections) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsAndAntiSections(paSections) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #-------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS   #
	#-------------------------------------------------------------------#
		
	def SectionsAndAntiSections(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		aResult = This.Sections( aSectionsAntiSections )

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsQ(paSections)
			return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSections(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncluding(paSections)
			return This.SectionsAndAntiSections(paSections)

			def AllSectionsIncludingQ(paSections)
				return This.SectionsAndAntiSectionsQ(paSections)
	
			def AllSectionsIncludingQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------------------------#
	 #   GETTING SECTIONS AND ANTI-SECTIONS OF A GIVEN SET OF SECTIONS -- EXTENDED  #
	#------------------------------------------------------------------------------#
		
	def SectionsAndAntiSectionsXT(paSections)

		aSectionsAntiSections = This.FindAsSectionsAndAntiSections(paSections)
		nLen = len(aSectionsAntiSections)

		aResult = []

		for i = 1 to nLen
			aSection = aSectionsAntiSections[i]
			aResult + [ This.Section(aSection[1], aSection[2]), aSection ]
		next

		return aResult

		#< @FunctionFluentForm

		def SectionsAndAntiSectionsXTQ(paSections)
			return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		def SectionsAndAntiSectionsXTQR(paSections, pcReturnType)
			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SectionsAndAntiSectionsXT(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SectionsAndAntiSectionsXT(paSections) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def AllSectionsIncludingXT(paSections)
			return This.SectionsAndAntiSectionsXT(paSections)

			def AllSectionsIncludingXTQ(paSections)
				return This.SectionsAndAntiSectionsXTQ(paSections)
	
			def AllSectionsIncludingXTQR(paSections, pcReturnType)
				return This.SectionsAndAntiSectionsXTQR(paSections, pcReturnType)

		#>

	  #------------------------------------------------------------#
	 #   GENERATING ALL POSSIBLE SECTIONS BETWEEN TOW SUBSTRINGS  #
	#------------------------------------------------------------#

	def SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TAYOUBTA")
		? o1.SectionsFromTo( :From = "T", :To = "A" )
		#--> [ "TA", "TAYOUBTA", "TA" ]

		*/

		if isList(pcSubStr1) and Q(pcSubStr1).IsFromNamedParam()
			pcSubStr1 = pcSubStr1[2]
		ok

		if isList(pcSubStr2) and Q(pcSubStr2).IsToNamedParam()
			pcSubStr2 = pcSubStr2[2]
		ok

		anSections = []

		anPos1 = This.FindAllCS(pcSubStr1, pCaseSensitive) #--> [ 1, 7 ]
		anPos2 = This.FindAllCS(pcSubStr2, pCaseSensitive) #--> [ 2, 8 ]

		for n1 in anPos1
			for n2 in anPos2
				if n1 < n2
					anSections + [ n1, n2 ]
				ok
			next
		next

		#--> [ [ 1, 2 ], [ 1, 8 ], [ 7, 8 ] ]

		acResult = This.Sections(anSections)
		return acResult

		def AllPossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AllPossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def PossibleSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SectionsFromTo(pcSubStr1, pcSubStr2)
		return This.SectionsFromToCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def AllPossibleSectionsFromTo(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def AllPossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSectionsFromTo(pcSubStr1, pcSubStr2)
			return This.SectionsFromTo(pcSubStr1, pcSubStr2)

		def PossibleSections(pcSubStr1, pcSubStr2)
			return This.SectionsFromToCS(pcSubStr1, pcSubStr2)

	  #--------------------------------------#
	 #   GETTING MANY RANGES OF THE STRING  #
	#--------------------------------------#

	def Ranges(paRanges)
		aResult = []

		for aRange in paRanges
			aResult + This.Range( aRange[1], aRange[2] )
		next

		return aResult

		def ManyRanges(paSections)
			return This.Ranges(paRanges)

	  #--------------------------------------------------------#
	 #   GETIING THE ANTI-RANGES OF A GIVEN SET OF SECTIONS   #
	#--------------------------------------------------------#

	def AntiRanges(paRanges)
		aSections = RangesToSections(paRanges)
		aResult = This.AntiSections(aSections)

		return aResult

		def RangesOtherThan(paRanges)
			return This.AntiRanges()

	  #====================================#
	 #  INSERTING SUBSTRINGS -- EXTENDED  # TODO / ADD OTHER FORMS
	#====================================#

	def InsertXT(pcSubStr, paOptions)
		/*
		o1 = new stzString("99999999999")
		o1.InsertXT("_", [ :After, :EachNChars = 3, :Going = :Forward ])

		? o1.Content()
		#--> 99_999_999_999

		#--

		o1 = new stzString("99999999999")
		o1.InsertXT([".", "_"], [ :Repeat, :After, :EachNChars = 2, :Going = :Forward ])

		? o1.Content()
		#--> 9_99.99_99.99_99

		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(paOptions)

			oOptions = new stzList(paOptions)

			# Case : Q("999999").InsertXT("-", :EachNChars = 2) --> 99-99-99
			if oOptions.IsOneOfTheseNamedParams([ :Step, :EachNChars ])

				This.SpacifyXT(
					:Using = pcSubStr,
					:EachNChars = paOptions[2],
					:Going = :Forward)

			# Add other cases here

				/* ... */
			ok
		ok


		#< @FunctionFluentForm

		def InsertXTQ(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubStringXT(pcSubStr, paOptions)
			This.InsertXT(pcSubStr, paOptions)

			def InsertSubStringXTQ(pcSubStr, paOptions)
				This.InsertSubStringXT(pcSubStr, paOptions)
				return This

		#>

	def SubStringInsertedXT(pcSubStr, paOptions)
		cResult = This.Copy().InsertXTQ(pcSubStr, paOptions).Content()
		return cResult

	  #------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS   #
	#------------------------------------------------#

	def InsertBeforeEachNChars(n, pcSubStr)
		This.InsertBeforeEachNCharsXT(n, pcSubStr, :FromEndToStart)

		def InsertBeforeEachNCharsQ(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)
			return This

		def InsertSubStringBeforeEachNChars(n, pcSubStr)
			This.InsertBeforeEachNChars(n, pcSubStr)

			def InsertSubStringBeforeEachNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEachNChars(n, pcSubStr)
				return This

	def SubStringInsertedBeforeEachNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEachNCharsQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE EACH N CHARS -- EXTENDED  #
	#-----------------------------------------------------------#

	def InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		This.InsertXT( pcSubStr, [ :After, :EachNChars = 3, :Going = :Forward ])

		def InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			return This

		def InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
			This.InsertBeforeEachNCharsXT(n, pcSubStr, pcDirection)

			def InsertSubStringBeforeEachNCharsXTQ(n, pcSubStr, pcDirection)
				This.InsertSubStringBeforeEachNCharsXT(n, pcSubStr, pcDirection)
				return This

	def SubStringInsertedBeforeEachNCharsXT(n, pcSubStr, pcDirection)
		cResult = This.Copy().InsertBeforeEachNCharsXTQ(n, pcSubStr, pcDirection).Content()
		return cResult

	  #-------------------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE OR AFTER A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def Insert(pcSubStr, pWhere)
		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pWhere)
			if Q(pWhere).IsOneOfTheseNamedParams([
				:At, :AtPosition, :Before, :BeforePosition ])

				This.InsertBefore(pWhere[2], pcSubStr)
				return

			but Q(pWhere).IsOneOfTheseNamedParams([ :After, :AfterPosition ])

				This.InsertAfter(pWhere[2], pcSubStr)
				return
			ok
		else
			This.InsertBefore(pWhere, pcSubStr)
		ok

		#< @FunctionFluentForm

		def InsertQ(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertSubString(pcSubStr, pWhere)
			This.Insert(pcSubStr, pWhere)

			def InserSubStringQ(pcsubStr, pWhere)
				This.InsertSubString(pcSubStr, pWhere)
				return This
		
		#>

	def SubStringInserted(pcSubStr, pWhere)
		cResult = This.Copy().InsetSubStringQ(pcSubStr, pWhere).Content()
		return cResult


	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING BEFORE A GIVEN POSITION   #
	#----------------------------------------------------#

	/* Inserts a substring:

	 	- in a given position inside the string
	 	  Note: in this case, if nPos > NumberOfChars()
		  --> string is extended with white spaces

		- or, before the occurrence of a given substring
	*/
	 
	def InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)
		if isString(nPos)
			This.InsertSubstringBeforeSubStringCS(nPos, pcSubStr, pCaseSensitive)
			return

		but isList(nPos) and Q(nPos).IsListOfStrings()
			This.InsertSubStringsBeforeSubStringCS(nPos, pCSubStr, pCaseSensitive)
			return

		but isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertSubStringBeforePositions(nPos, pcSubStr)
			return
		ok

		# else

		if isList(nPos) and Q(nPos).IsPositionNamedParam()
			nPos = nPos[2]
		ok

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertBeforeThesePositions(nPos, pcSubStr)
			return
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		@oQString.insert(nPos-1, pcSubStr)

		# The string has changed, check constraints...
		//This.VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforePosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertBeforePositionQ(nPos, pcSubStr)
				This.InsertBeforePosition(nPos, pcSubStr)
				return This

		def InsertAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)
				return This

		def InsertAtPosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertAtPosiitonQ(nPos, pcSubStr)
				This.InsertAt(nPos, pcSubStr)
				return This

		#--

		def InsertSubStringBeforeCS(nPos, pcSubStr, pCaseSensitive)
			This.InsertBeforeCS(nPos, pcSubStr, pCaseSensitive)

			def InsertSubStringBeforeCSQ(nPos, pcSubStr, pCaseSensitive)
				return This

		def InserSubStringtBeforePosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringBeforePositionQ(nPos, pcSubStr)
				This.InsertBeforePosition(nPos, pcSubStr)
				return This

		def InsertSubStringAt(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringAtQ(nPos, pcSubStr)
				This.InsertSubStringAt(nPos, pcSubStr)
				return This

		def InsertSubStringAtPosition(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)

			def InsertSubStringAtPosiitonQ(nPos, pcSubStr)
				This.InsertSubStringAt(nPos, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeCS(nPos, pcSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeCSQ(nPos, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforePosition(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		def SubStringInsertedAt(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		def SubStringInsertedAtPosition(nPos, pcSubStr)
			This.SubStringInsertedBefore(nPos, pcSubStr)

		#>

	#-- WITHOUT CASESENSITIVITY

	def InsertBefore(nPos, pcSubStr)
		This.InsertBeforeCS(nPos, pcSubStr, :CaseSensitive = TRUE)

		def InsertBeforeQ(nPos, pcSubStr)
			This.InsertBefore(nPos, pcSubStr)
			return This

		def InsertSubStringBefore(nPos, pcSubStr)
			This.InsertSubStringBeforeCS(nPos, pcSubStr, :CaseSensitive = TRUE)

			def InsertSubStringBeforeQ(nPos, pcSubStr)
				This.InsertSubStringBefore(nPos, pcSubStr)
				return This

	def SubStringInsertedBefore(nPos, pcSubStr)
		cResult = This.Copy().InsertBeforeQ(nPos, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING BEFORE A POSITION DEFINED     #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#--------------------------------------------------------#

	def InsertBeforeW(pcCondition, pcSubStr)
		anPositions = This.FindW(pcCondition)
		This.InsertBeforePositions( anPositions, pcSubStr )

		#< @FunctionFluentForm

		def InsertBeforeWQ(pcCondition, pcSubStr)
			This.InsertBeforeW(pcCondition, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringBeforeW(pcCondition, pcSubStr)
			This.InsertBefore(pcCondition, pcSubStr)

			def InsertSubStringBeforeWQ(pcCondition, pcSubStr)
				This.InsertSubStringBeforeW(pcCondition, pcSubStr)
				return This

		def InsertAtW(pcCondition, pcSubStr)
			This.InsertBefore(pcCondition, pcSubStr)

			def InsertAtWQ(pcCondition, pcSubStr)
				This.InsertAtW(pcCondition, pcSubStr)
				return This

		def InsertSubstringAtW(pcCondition, pcSubStr)
			This.InsertBefore(pcCondition, pcSubStr)

			def InsertSubstringAtWQ(pcCondition, pcSubStr)
				This.InsertSubStringAtW(pcCondition, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertBeforeWQ(pcCondition, pcSubStr).Content()
		return cResult

		def SubStringInsertedAtW(pcCondition, pcSubStr)
			return This.SubStringInsertedBeforeW(pcCondition, pcSubStr)

	  #----------------------------------------------------#
	 #    INSERTING A SUBSTRING AFTER A GIVEN POSITION    #
	#====================================================#

	def InsertAfter(nPos, pcSubStr)
		#< QtBased | Uses QString.insert() >

		if isList(nPos) and Q(nPos).IsListOfNumbers()
			This.InsertAtPositons(anPos, pcSubStr)
		ok

		@oQString.insert(nPos, pcSubStr)

		//VerifyConstraints()

		#< @FunctionFluentForm
		
		def InsertAfterQ(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAfterPosition(nPos, pcSubStr)
			This.InsertAfer(nPos, pcSubStr)

			def InsertAfterePositionQ(nPos, pcSubStr)
				This.InsertAfterPosition(nPos, pcSubStr)
				return This

		def InsertSubStringAfter(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertSubStringAfterQ(nPos, pcSubStr)
				This.InsertSubStringAfter(nPos, pcSubStr)
				return This

		def InsertSubStringAfterPosition(nPos, pcSubStr)
			This.InsertAfter(nPos, pcSubStr)

			def InsertSubStringAfterPositionQ(nPos, pcSubStr)
				This.InsertSubStringAfterPosition(nPos, pcSubStr)
				return This

		#>

	def SubStringInsertedAfter(nPos, pcSubStr)
		cResult = This.Copy().InsertAfterQ(nPos, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterPosition(nPos, pcSubStr)
			return This.SubStringInsertedAfter(nPos, pcSubStr)

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (BEFORE) EVERY N CHARS   #
	#---------------------------------------------------#

	def InsertBeforeEveryNChars(n, pcSubStr)

		if NOT isNumber(n)
			stzRaise("Incorrect param! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPositions = []

		if n = 1
			anPositions = [ 1 ]

		else
		
			for i = 2 to This.NumberOfChars() step n
				anPositions + [ i - 1 ]
			next
		ok

		This.InsertBeforeThesePositions(anPositions, " ")

		#< @FunctionFluentForm

		def InsertBeforeEveryNCharsQ(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertEveryNChars(n, pcSubStr)
			This.InsertBeforeEveryNChars(n, pcSubStr)

			def InsertEveryNCharsQ(n, pcSubStr)
				This.InsertAfterEveryNChars(n, pcSubStr)
				return This
	
		def InsertSubStringBeforeEveryNChars(n, pcSubStr)
			This.InsertEveryNChars(n, pcSubStr)

			def InsertSubStringBeforeEveryNCharsQ(n, pcSubStr)
				This.InsertSubStringBeforeEveryNChars(n, pcSubStr)
				return This

		def InsertSubStringEveryNChars(n, pcSubStr)
			This.InsertEveryNChars(n, pcSubStr)

			def InsertSubStringEveryNCharsQ(n, pcSubStr)
				This.InsertEveryNChars(n, pcSubStr)
				return This

		#>

	def SubStringInsertedBeforeEveryNChars(n, pcSubStr)
		cResult = This.Copy().InsertBeforeEveryNCharsQ(n, pcSubStr).Content()
		return cResult

		def SubStringInsertedEveryNChars(n, pcSubStr)
			return This.SubStringInsertedBeforeEveryNChars(n, pcSubStr)

	  #---------------------------------------------------#
	 #    INSERTING A SUBSTRING (AFTER) EVERY N CHARS    #
	#---------------------------------------------------#

	def InsertAfterEveryNChars(n, pcSubStr)

		if NOT isNumber(n)
			stzRaise("Incorrect param! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPositions = []

		if n > 1
			for i = 1 to This.NumberOfChars() - 1 step n
				anPositions + ( i + 1 )
			next
		ok

		This.InsertAfterThesePositions(anPositions, " ")

		#< @FunctionFluentForm

		def InsertAfterEveryNCharsQ(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterEveryNChars(n, pcSubStr)
			This.InsertAfterEveryNChars(n, pcSubStr)

			def InsertSubStringAfterEveryNCharsQ(n, pcSubStr)
				This.InsertSubStringAfterEveryNChars(n, pcSubStr)
				return This

		#>

	def SubStringInsertedAfterEachNCHars(n, pcSubStr)
		cResult = This.Copy().InsertAfterEveryNCharsQ(n, pcSubStr).Content()
		return cResult

	   #--------------------------------------------------------#
	  #    INSERTING A SUBSTRING AFTER A POSITION DEFINED      #
	 #    BY A GIVEN CONDITION APPLIED ON THE STRING CHARS    #
	#--------------------------------------------------------#

	def InsertAfterW( pcCondition, pcSubStr )
		anPositions = This.FindW(pcCondition)
		This.InsertAfterPositions( anPositions, pcSubStr )

		#< @FunctionFluentForm

		def InsertAfterWQ( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )
			return This

		#>

		#< @FunctionAlternativeForm

		def InsertAfterWhere( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )

			def InsertAfterWhereQ( pcCondition, pcSubStr )
				This.InsertAfterWhere( pcCondition, pcSubStr )
				return This

		def InsertSubStringAfterW( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )

			def InsertSubStringAfterWQ(pcCondition, pcSubStr)
				This.InsertSubStringAfterW( pcCondition, pcSubStr )
				return This

		def InsertSubStringAfterWhere( pcCondition, pcSubStr )
			This.InsertAfterW( pcCondition, pcSubStr )

			def InsertSubStringAfterWhereQ(pcCondition, pcSubStr)
				This.InsertSubStringAfterWhere( pcCondition, pcSubStr )
				return This

		#>

	def SubStringInsertedAfterW(pcCondition, pcSubStr)
		cResult = This.Copy().InsertAfterWQ(pcCondition, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterWhere(pcCondition, pcSubStr)
			return This.SubStringInsertedAfterW(pcCondition, pcSubStr)

	  #------------------------------------------------#
	 #   INSERTING A SUBSTRING AFTER MANY POSITIONS   #
	#------------------------------------------------#

	 def InsertAfterPositions(panPositions, pcSubStr)
		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! paPositions must be a list of numbers.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		anPos = ring_sort(panPositions)
		nLen = len(anPos)

		for i = nLen to 1 step -1
			This.InsertAfter(anPos[i], pcSubStr)
		next

		#< @FunctionFluentForm

		def InsertAfterPositionsQ(panPositions, pcSubStr)
			This.InsertAfterPositions(panPositions, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterManyPositions(panPositions, pcSubstr)
			This.InsertAfterPositions(panPositions, pcSubStr)

			def InsertAfterManyPositionsQ(panPositions, pcSubstr)
				This.InsertAfterManyPositions(panPositions, pcSubstr)
				return This

		def InsertAfterThesePositions(panPositions, pcSubstr)
			This.InsertAfterPositions(panPositions, pcSubStr)

			def InsertAfterThesePositionsQ(panPositions, pcSubstr)
				This.InsertAfterThesePositions(panPositions, pcSubstr)
				return This

		#--

		def InsertSubStringAfterPositions(panPositions, pcSubStr)
			This.InsertAfterPositions(panPositions, pcSubStr)

			def InsertSubStringAfterPositionsQ(panPositions, pcSubStr)
				This.InsertSubStringAfterPositions(panPositions, pcSubStr)
				return This

		def InsertSubStringAfterManyPositions(panPositions, pcSubstr)
			This.InsertAfterPositions(panPositions, pcSubStr)

			def InsertSubStringAfterManyPositionsQ(panPositions, pcSubstr)
				This.InsertSubStringAfterManyPositions(panPositions, pcSubstr)
				return This

		def InsertSubStringAfterThesePositions(panPositions, pcSubstr)
			This.InsertAfterPositions(panPositions, pcSubStr)

			def InsertSubStringAfterThesePositionsQ(panPositions, pcSubstr)
				This.InsertSubStringAfterThesePositions(panPositions, pcSubstr)
				return This

		#>

	def SubStringInsertedAfterThesePositions(anPositions, pcSubStr)
		cResult = This.Copy().InsertAfterThesePositionsQ(panPositions, pcSubStr).Content()
		return cResult

		def SubStringInsertedAfterManyPositions(anPositions, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPositions, pcSubStr)

		def SubStringInsertedAfterPositions(anPositions, pcSubStr)
			return This.SubStringInsertedAfterThesePositions(anPositions, pcSubStr)

	  #-------------------------------------------------#
	 #   INSERTING A SUBSTRING BEFORE MANY POSITIONS   #
	#-------------------------------------------------#

	 def InsertBeforePositions(panPositions, pcSubStr)

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsStringOrSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		anPositions = StzListOfNumbersQ(panPositions).SubstractFromEachQ(1).Content()
		This.InsertAfterThesePositions(anPositions, pcSubStr)

		#< @FunctionFluentForm

		def InsertBeforePositionsQ(panPositions, pcSubStr)
			This.InsertBeforePositions(panPositions, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeManyPositions(panPositions, pcSubStr)
			This.InsertBeforePositions(panPositions, pcSubStr)

		def InsertBeforeThesePositions(panPositions, pcSubStr)
			This.InsertBeforePositions(panPositions, pcSubStr)
			
		#--

		def InsertSubStringBeforePositions(panPositions, pcSubStr)
			This.InsertBeforePositions(panPositions, pcSubStr)

			def InsertSubStringBeforePositionsQ(panPositions, pcSubStr)
				This.InsertSubStringBeforePositions(panPositions, pcSubStr)
				return This

		def InsertSubStringBeforeManyPositions(panPositions, pcSubstr)
			This.InsertBeforePositions(panPositions, pcSubStr)

			def InsertSubStringBeforeManyPositionsQ(panPositions, pcSubstr)
				This.InsertSubStringBeforeManyPositions(panPositions, pcSubstr)
				return This

		def InsertSubStringBeforeThesePositions(panPositions, pcSubstr)
			This.InsertBeforePositions(panPositions, pcSubStr)

			def InsertSubStringBeforeThesePositionsQ(panPositions, pcSubstr)
				This.InsertSubStringBeforeThesePositions(panPositions, pcSubstr)
				return This

		#>

	def SubStringInsertedBeforeThesePositions(anPositions, pcSubStr)
		cResult = This.Copy().InsertBeforeThesePositionsQ(panPositions, pcSubStr).Content()
		return cResult

		def SubStringInsertedBeforeManyPositions(anPositions, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPositions, pcSubStr)

		def SubStringInsertedBeforePositions(anPositions, pcSubStr)
			return This.SubStringInsertedBeforeThesePositions(anPositions, pcSubStr)


	  #-----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING BEFORE EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#=============================================================================#

	def InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(cSubStr, pCaseSensitive)

		if len(anPos) > 0
			anPos = StzListOfNumbersQ( anPos ).AddToEachQ(nLenSubStr).Content()
			aParts = This.SplitBeforePositions(anPos)
	
			cResult = StzPairOfListsQ( aParts, ListOfNTimes(len(aParts)-1, pcNewSubStr) ).AlternateQ().ToStzListOfStrings().Concatenate()
		
			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
					return This

		#--

		def InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedBeforeEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeSubstring(pcSubStr, pcNewSubStr)
		This.InsertBeforeSubstringCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertBeforeSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertBeforeEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		def InsertBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedBeforeEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedBeforeEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeSubString(pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE NTH       #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringBeforeNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertBeforeNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertBeforeNthOccurrenceCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeNthOccurrence(n, pcSubStr, pcNewSubStr)

		#>

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeFirstOccurrenceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeFirstOccurrence(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING BEFORE LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertBeforePosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )


		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertBeforeLastOccurrenceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @functionAlternativeForms

		def InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertBeforeLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringBeforeLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertBeforeLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInsertedBeforeLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedBeforeLastOccurrence(pcSubStr, pcNewSubStr)

		#>

	  #----------------------------------------------------------------------------#
	 #  INSERTING A NEW SUBSTRING AFTER EACH OCCURRENCE OF AN EXISTANT SUBSTRING  #
	#============================================================================#

	def InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		acParts = This.SplitCS(pcSubStr, pCaseSensitive)
		cResult = ""

		for i = 1 to len(acParts)-1
			cResult += (acParts[i] + pcSubStr + pcNewSubStr)
		next

		This.Update( cResult + acParts[ len(acParts) ] )

		#< @FunctionFluentForm

		def InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This	
	
		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def InsertAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		#--

		def InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterEachOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def SubStringInsertedAfterEachOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#>

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterSubstring(pcSubStr, pcNewSubStr)
		This.InsertAfterSubstringCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertAfterSubstringQ(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertAfterEachOccurrenceOfSubstring(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		def InsertAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

		#--

		def InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterSubstring(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterEachOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterEachOccurrence(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterSubstringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		def SubStringInsertedAfterEachOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		def SubStringInsertedAfterEachOccurrence(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterSubString(pcSubStr, pcNewSubStr)

		#>

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER THE NTH   #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterNthOccurrenceOfSubStringCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubStringCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.InsertAfterNthOccurrenceCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			This.InsertAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

			def InsertSubStringAfterNthOccurrenceOfSubStringQ(n, pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterNthOccurrenceQ(n, pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterNthOccurrenceOfSubString(n, pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterNthOccurrence(n, pcSubStr, pcNewSubStr)

	   #-----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER FIRST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING        #
	#-----------------------------------------------#

	def InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterFirstOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterFirstOccurrenceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterFirstOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterFirstOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterFirstOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterFirstOccurrence(pcSubStr, pcNewSubStr)

	   #----------------------------------------------#
	  #    INSERTING A NEW SUBSTRING AFTER LAST     #
	 #    OCCURRENCE OF AN EXISTANT SUBSTRING       #
	#----------------------------------------------#

	def InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.InsertAfterPosition( This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive), pcNewSubStr )

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def InsertSubStringAfterLastOccurrenceOfSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.InsertSubStringAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().InsertAfterLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubStringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringInsertedAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
		This.InsertAfterLastOccurrenceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrence(pcSubStr, pcNewSubStr)
				return This

		def InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			This.InsertAfterLastOccurrence(pcSubStr, pcNewSubStr)

			def InsertSubStringAfterLastOccurrenceOfSubStringQ(pcSubStr, pcNewSubStr)
				This.InsertSubStringAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
				return This

		#>

	def SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)
		cResult = This.Copy().InsertAfterLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()
		return cResult

		def SubStringInsertedAfterLastOccurrenceOfSubString(pcSubStr, pcNewSubStr)
			return This.SubStringInsertedAfterLastOccurrence(pcSubStr, pcNewSubStr)

	   #-----------------------------------------------------#
	  #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION      #
	 #  BY CONCATNEATING THEM ACCORDING TO A GIVEN FORMAT  #
	#====================================================#

	def InsertSubstringsXT( nPos, aSubStr, paOptions)
		/*
		Example:
	
		o1 = new stzString("All our software versions must be updated!")
		# Defining the position of insertion
		nPosition = o1.PositionAfterSubstring("versions") + 1
			
		# Inserting the list of string using extended configuration
		? o1.InsertListOfSubstringsXT(
			nPosition, [ "V1", "V2", "V3", "V4", "V5" ],
			
			[
			:cInsertBeforOrAfter = :Before,
			:OpeningChar = "(",
			:ClosingChar = ")", 
		
			:MainSeparator = ",",
			:AddSpaceAfterSeparator = TRUE,
			
			:LastSeparator = "and",
			:AddLastToMainSeparator = TRUE,
			
			:SpaceOption = :optEnsureLeadingSpace + :optEnsureTrailingSpace
			])
	
		Gives :
		All our software versions (V1, V2, V3, V4, and V5) must be updated!
		*/
	
		# Setting the default options
			
		cInsertBeforeOrAfter = :Before
		cOpeningChar = "("
		cClosingChar = ")"
			
		cMainSeparator = ","
		bAddSpaceAfterSeparator = TRUE
					
		cLastSeparator = NULL
		bAddLastToMainSeparator = FALSE
			
		cSpaceOption = :AddLeadingSpace + :AddTrailingSpace
	
		# Verifying the syntax of the options provided
		if NOT ( len(paOptions) = 0 or
			 ( len(paOptions) = 1 and paOptions[1] = :Default) )
	
			aPossibleOptions = [ :InsertBeforeOrAfter, :OpeningChar, :ClosingChar, :MainSeparator,
				  :AddSpaceAfterSeparator, :LastSeparator, :AddLastToMainSeparator,
				  :SpaceOption ]
		
			oHash = new stzHashList(paOptions)
			aListOfProvidedOptions = oHash.Keys()
		
			oListOfProvidedOptions = new stzList(aListOfProvidedOptions)
		
			if NOT oListOfProvidedOptions.IsMadeOfSome(aPossibleOptions)
				stzRaise(stzStringError(:UnsupportedOptionsWhileInsertingListOfStrings))
			ok
		
			# If some options are provided then we take them
			# Note : if len(paOptions) = 0 or paOptions = [ :Default ] then we preserve
			# the default options already defined
				
			cInsertBeforeOrAfter = paOptions[ :InsertBeforeOrAfter ]	
			cOpeningChar = paOptions[ :OpeningChar ]
			cClosingChar = paOptions[ :ClosingChar ]
					
			cMainSeparator = paOptions[ :MainSeparator ]
			bAddSpaceAfterSeparator = paOptions[ :AddSpaceAfterSeparator ]
		
			cLastSeparator = paOptions[ :LastSeparator ]
			bAddLastToMainSeparator = paOptions[ :AddLastToMainSeparator ]
		
			cSpaceOption = paOptions[ :SpaceOption ]
		ok
	
		# At this level, all the options are defined
		# Beginning the substring construction but the opening char
	
		cSubStr = cOpeningChar
			
		# Checking the behavior of the first inserted substring in regard of adjacent left space

		if NOT cSpaceOption = :DoNothing
			if cSpaceOption = :AddLeadingSpace or
			   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
			   cSpaceOption = :AddTrailingSpace + :AddLeadingSpace
	
				if nPos > 1 and This.NthChar(nPos - 1) != " "
					cSubStr = " " + cOpeningChar
				ok
			ok
		ok
	
		# Looping over the list of strings to concatenate them
		# depending on the logic defined by the options
	
		for i = 1 to len(aSubStr)
			# we add the string itslef
			cSubStr += aSubStr[i]
	
			# while we are not on the last item, or
			# we are on the last item but we are not asked
			# to use an alternative separator at the end
	
			if i < len(aSubStr) - 1 OR
			   (i = len(aSubStr)-1 and cLastSeparator = NULL)
	
				# Add the main separator after each string
				cSubStr += cMainSeparator
	
				# Add space after separator if required
				if bAddSpaceAfterSeparator = TRUE
						cSubstr += " "
				ok	
	
			# When reaching the last string, and an alternative
			# separator must be used (it's not null), we check
			# if we should use this last separator alone or
			# in addition to the main separator
	
			but i = len(aSubStr) - 1
	
				if bAddLastToMainSeparator = TRUE
					cSubStr += cMainSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
	
				if cLastSeparator != NULL
					cSubStr += cLastSeparator
				ok
	
				if bAddSpaceAfterSeparator = TRUE
					cSubstr += " "
				ok
			ok		
		next
	
		# Add the closing char to get the final substring
	
		cSubStr += cClosingChar
	
		# Checking the option of leaving the trailing space
	
		if cSpaceOption = :AddTrailingSpace or
		   cSpaceOption = :AddLeadingSpace + :AddTrailingSpace or
		   cSpaceOption = :AddTrailiningSpace + :AddLeadingSpace
	
			cSubStr += " "
		ok
	
		if cInsertBeforeOrAfter = :After
			nPos++
		ok

		# Doing the job!

		This.InsertBefore(nPos, cSubStr)
	
		#< @FunctionFluentForm
		
		def InsertSubstringsXTQ( nPos, aSubStr, paOptions)
			This.InsertSubstringsXT( nPos, aSubStr, paOptions)
			return This
		
		#>

		#< @FunctionAlternativeForms

		def InsertManyXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManyXTQ(nPos, aSubStr, paOptions)
				This.InsertManyXT(nPos, aSubStr, paOptions)
				return This

		def InsertManySubStringsXT(nPos, aSubStr, paOptions)
			This.InsertListOfSubstringsXT( nPos, aSubStr, paOptions)

			def InsertManySubStringsXTQ(nPos, aSubStr, paOptions)
				This.InsertManySubStringsXT(nPos, aSubStr, paOptions)
				return This

		#>

	def SubstringsInsertedXT(nPos, aSubStr, paOptions)
		cResult = This.Copy().InsertSubstringsXTQ( nPos, aSubStr, paOptions).Content()
		return cResult

		def ManySubStringsInsertedXT(nPos, aSubStr, paOptions)
			return This.SubstringsInsertedXT(nPos, aSubStr, paOptions)

	  #-----------------------------------------------------------------------#
	 #  INSERTING MANY SUBSTRINGS AT A GIVEN POSITION BY CONCATNEATING THEM  #
	#=======================================================================#

	def InsertSubstrings(nPos, aSubStr)
		This.InsertSubstringsXT( nPos, aSubStr, [:Default] )
	
		#< @FunctionFluentForm
		
		def InsertSubstringsQ( nPos, aSubStr)
			This.InsertSubstrings(nPos, aSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		def InsertMany(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManyQ(nPos, aSubStr)
				This.InsertMany(nPos, aSubStr)
				return This

		def InsertManySubStrings(nPos, aSubStr)
			This.InsertListOfSubstrings(nPos, aSubStr)

			def InsertManySubStringsQ(nPos, aSubStr)
				This.InsertManySubStrings(nPos, aSubStr)
				return This

		#>

	def SubstringsInserted(nPos, aSubStr)
		cResult = This.Copy().InsertSubstringsQ(nPos, aSubStr).Content()
		return cResult

		def ManySubStringsInserted(nPos, aSubStr)
			return This.SubstringsInserted(nPos, aSubStr)

	  #=================================================#
	 #     REPLACING ALL OCCURRENCES OF A SUBSTRING    #
	#=================================================#
	
	def ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = YES | @QtBased #>

		/* Example:
	
		StzStringQ("Tunis is the town of my memories.") {
			ReplaceAll("Tunis", "Niamey" )
			? Content()
		}
		#--> Niamey is the town of my memories.
	
		*/

		# Checking the correctness of pcSubStr param

		if isList(pcSubStr) and Q(pcSubStr).IsEachNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubstr)
			stzRaise("Incorrect param typs! pcSubstr must be a string.")
		ok

		# Checking the correctness of pcNewSubStr param

		bWellFormed = FALSE

		if isString(pcNewSubStr)
			bWellFormed = TRUE

		but isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithOrByNamedParam()
			
			if isString(pcNewSubStr[2])
				bWellFormed = TRUE
				# Detecting the case where a conditonal value is provided
				# via the :With@ or :By@ keywords

				if Q(pcNewSubStr[1]).IsOneOfThese([ :With@, :By@ ])
					pcNewSubStr = pcNewSubStr[2]
	
					This.ReplaceSubStringCS@(pcSubStr, pcNewSubStr, pCaseSensitive)
					return
	
				else
					pcNewSubStr = pcNewSubStr[2]
				ok

			ok

		ok

		# Checking the correctness of pCaseSensitive param

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSe).")
		ok

		# Doing the job

		@oQString.replace_2(pcSubStr, pcNewSubStr, pCaseSensitive)

	
		#< @FunctionFluentForm
		
		def ReplaceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceSubStringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	#-- WITHOUT CASESENSITIVITY

	def Replace(pcSubStr, pcNewSubStr)
		This.ReplaceCS(pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm
		
		def ReplaceQ(pcSubStr, pcNewSubStr)
			This.Replace(pcSubStr, pcNewSubStr)
			return This
		
		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	def SubStringReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceSubStringQ(pcSubStr, pcNewSubStr).Content()

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

		#< @FunctionAlternativeForms

		#--> See bottom of file!

		#>

	  #---------------------------------#
	 #     REPLACING FIRST N CHARS     #
	#---------------------------------#

	def ReplaceFirstNChars(n, pcNewSubStr)
		This.ReplaceSection(1, n, pcNewSubStr)

		def ReplaceFirstNCharsQ(n, pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)
			return This

		def ReplaceNFirstChars(pcNewSubStr)
			This.ReplaceFirstNChars(n, pcNewSubStr)

			def ReplaceNFirstCharsQ(pcNewSubStr)
				This.ReplaceNFirstChars(pcNewSubStr)
				return This

	def FirstNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceFirstNCharsQ(n, pcNewSubStr).Content()

		def NFirstCharsReplaced(pcNewSubStr)
			return This.FirstNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LAST N CHARS     #
	#--------------------------------#

	def ReplaceLastNChars(n, pcNewSubStr)
		This.ReplaceSection(This.NumberOfChars() - n + 1, :LastChar, pcNewSubStr)

		def ReplaceLastNCharsQ(n, pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)
			return This

		def ReplaceNLastChars(pcNewSubStr)
			This.ReplaceLastNChars(n, pcNewSubStr)

			def ReplaceNLastCharsQ(pcNewSubStr)
				This.ReplaceNLastChars(pcNewSubStr)
				return This

	def LastNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLastNCharsQ(n, pcNewSubStr).Content()

		def NLastCharsReplaced(pcNewSubStr)
			return This.LastNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING LEFT N CHARS     #
	#--------------------------------#

	def ReplaceLeftNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceFirstNChars(n, pcNewSubStr)

		else
			This.ReplaceLastNChars(n, pcNewSubStr)
		ok

		def ReplaceLeftNCharsQ(n, pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)
			return This

		def ReplaceNLeftChars(pcNewSubStr)
			This.ReplaceLeftNChars(n, pcNewSubStr)

			def ReplaceNLeftCharsQ(pcNewSubStr)
				This.ReplaceNLeftChars(pcNewSubStr)
				return This

	def LeftNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceLeftNCharsQ(n, pcNewSubStr).Content()

		def NLeftCharsReplaced(pcNewSubStr)
			return This.LeftNCharsReplaced(pcNewSubStr)

	  #--------------------------------#
	 #     REPLACING RIGHT N CHARS    #
	#--------------------------------#

	def ReplaceRightNChars(n, pcNewSubStr)
		if This.IsLeftToRight()
			This.ReplaceLastNChars(n, pcNewSubStr)

		else
			This.ReplaceFirstNChars(n, pcNewSubStr)
		ok

		def ReplaceRightNCharsQ(n, pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)
			return This

		def ReplaceNRightChars(pcNewSubStr)
			This.ReplaceRightNChars(n, pcNewSubStr)

			def ReplaceNRightCharsQ(pcNewSubStr)
				This.ReplaceNRightChars(pcNewSubStr)
				return This

	def RightNCharsReplaced(pcNewSubStr)
		return This.Copy().ReplaceRightNCharsQ(n, pcNewSubStr).Content()

		def NRightCharsReplaced(pcNewSubStr)
			return This.RightNCharsReplaced(pcNewSubStr)

	  #-------------------------------#
	 #     REPLACING MIDDLE CHAR     #
	#-------------------------------#

	def ReplaceMiddleChar(pcNewSubStr)
		nPos = This.FindMiddleChar()
		This.ReplaceSection(nPos, nPos, pcNewSubStr)

		def ReplaceMiddleCharQ(pcNewSubStr)
			This.ReplaceMiddleChar(pcNewSubStr)
			return This

	def MiddleCharReplaced(pcNewSubStr)
		cResult = This.Copy().ReplaceMiddleCharQ(pcNewSubStr).Content()
		return cResult

	  #-------------------------------------------#
	 #     REPLACING MANY SUBSTRINGS AT ONCE     #
	#-------------------------------------------#

	def ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
		/* Example 1:
	
		o1 = new stzString( "a + b - c / d = 0")
		 o1.ReplaceManyCS( ["+", "-", "=", "/" ], "*", :CaseSensitive = FALSE )
		 ? o1.Content()
	
		--> Gives: "a * b * c * d = 0"
	
		Example 2:
	
		o1 = new stzString( "Tunis is my town. Tunisa is my nation!")
		o1.ReplaceManyCS( [ "Tunis", "Tunisia" ], :EachChar = "*" )
		? o1.Content()
	
		*/

		if NOT ( isList(pacSubStr) and
			 Q(pacSubStr).IsListOfStrings() )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if isList(pNewSubStr) and Q(pNewSubStr).IsWithOrByNamedParam()
			pNewSubStr = pNewSubStr[2]
		ok

		if isList(pNewSubStr)
			return This.ReplaceManyByManyCS(pacSubStr, pNewSubStr, pCaseSensitive)
		ok

		if NOT isString(pNewSubStr)
			stzRaise("Incorrect param type! pNewSubStr must be a string.")
		ok

		for str in pacSubstr
			This.ReplaceCS( str, pNewSubStr, pCaseSensitive )
		next
	
		#< @FunctionFluentForm
	
		def ReplaceManyCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This
		
		#>

		def ReplaceAllOfTheseCS(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)

			def ReplaceAllOfTheseCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
				This.ReplaceAllOfTheseCS(pacSubstr, pNewSubstr, pCaseSensitive)
				return This

		def ReplaceManySubstringsCS(pacSubstr, pNewSubstr, pCaseSensitive)
			This.ReplaceManyCS(pacSubstr, pNewSubstr, pCaseSensitive)

			def ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive)
				This.ReplaceManySubstringsCS(pacSubstr, pNewSubstr, pCaseSensitive)
				return This
		#>

	def ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
		acResult = This.Copy().ReplaceManySubstringsCSQ(pacSubstr, pNewSubstr, pCaseSensitive).Content()
		return acResult

		def ManyReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

		def SubStringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)
			return This.ManySubstringsReplacedCS(pacSubstr, pNewSubstr, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceMany(pacSubstr, pcNewSubstr)
		This.ReplaceManyCS( pacSubstr, pcNewSubstr, :CaseSensitive = TRUE )

		#< @FunctionFluentFormn

		def ReplaceManyQ(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)
			return This
		#>

		#< @FunctionAlternativeForm
	
		def ReplaceAllOfThese(pacSubStr, pcNewSubStr)
			This.ReplaceMany(pacSubstr, pcNewSubstr)

			def ReplaceAllOfTheseQ(pacSubStr, pcNewSubStr)
				This.ReplaceAllOfThese(pacSubStr, pcNewSubStr)
				return This

		def ReplaceManySubstrings(pacSubstr, pNewSubstr)
			This.ReplaceMany(pacSubstr, pNewSubstr)

			def ReplaceManySubstringsQ(pacSubstr, pNewSubstr)
				This.ReplaceManySubstrings(pacSubstr, pNewSubstr)
				return This

		#>

	def ManySubstringsReplaced(pacSubstr, pNewSubstr)
		acResult = This.Copy().ReplaceManySubstringsQ(pacSubstr, pNewSubstr).Content()
		return acResult

		def ManyReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

		def SubStringsReplaced(pacSubstr, pNewSubstr)
			return This.ManySubstringsReplaced(pacSubstr, pNewSubstr)

	  #--------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS  #
	#--------------------------------------------#

	def ReplaceByManyCS(pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ruby ring python ring")
		o1.ReplaceByMany("ring", :By = [ "", "", "" ])
	
		? o1.Content() #--> " php ruby  python "

		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok

		anPositions = This.FindCS(pcSubStr, pCaseSensitive)
		nMin = Min([ len(anPositions), len(pacNewSubStrings) ])
	
		for i = nMin to 1 step -1
			n = anPositions[i]
			cNewSubStr = pacNewSubStrings[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByMany(pcSubStr, pacNewSubStrings)
		This.ReplaceByManyCS(pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------#
	 #  REPLACING A SUBSTRING BY MANY SUBSTRINGS -- EXTENDED (RETURN TO FIRST)  #
	#--------------------------------------------------------------------------#

	def ReplaceByManyCSXT(pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplaceByManyXT("ring", :By = [ "#1", "#2" ])

		? o1.Content() #--> "#1 php #2 ruby #1 python #2"

		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok

		anPositions = This.FindCSQ(pcSubStr, pCaseSensitive).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SortedInDescending()
		
		i = 0
		for n in anPositions
			i++
			if i > len(acNewSubStrings)
				i = 1
			ok

			cNewSubStr = acNewSubStrings[i]
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceByManyXT(pcSubStr, pacNewSubStrings)
		This.ReplaceByManyCSXT(pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

	  #------------------------------------------------------#
	 #  REPLACING MANY SUBSTRINGS BY MANY OTHER SUBSTRINGS  #
	#------------------------------------------------------#

	def ReplaceManyByManyCS(pacSubStrings, pacNewSubStrings, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring qt softanza pyhton kandaji csharp ring")
		o1.ReplaceManyByMany([ "ring", "softanza", "kandaji" ], :By = [ "", "", "" ])

		? o1.Content() #--> " qt  pyhton  csharp "
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		i = 0
		for cSubStr in pacSubStrings
			cNewSubStr = NULL
			i++
			if i <= len(pacNewSubStrings)
				cNewSubStr = pacNewSubStrings[i]
			ok

			if cNewSubStr != NULL
				This.ReplaceCS(cSubStr, cNewSubStr, pCaseSensitive)
			ok

		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceManyByMany(pacSubStrings, pacNewSubStrings)
		This.ReplaceManyByManyCS(pacSubStrings, pacNewSubStrings, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #  REPLACING SOME OCCURRENCES OF A SUBSTRING BY AN OTHER SUBSTRING  #
	#-------------------------------------------------------------------#

	def ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrences([ 1, 5], "ring", :By = "")
	
		? o1.Content() #--> " php ring ruby ring python ring csharp "
		*/

		anAllPositions = This.FindAllCS(pcSubStr, pCaseSensitive)

		anPositions = []

		for n in panOccurrences
			anPositions + anAllPositions[n]
		next

		anPositions = StzListQ(anPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		next

		#< @FuntionFluentForm

		def ReplaceOccurrencesCSQ(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceOccurrrencesOfSubStringCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSomeOccurrencesOfSubStringCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSomeCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceOccurrencesCS(panOccurrences, pcSubStr, pcNewSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceOccurrences(panOccurrencess, pcSubStr, pcNewSubStr)
		This.ReplaceSomeOccurrencesCS(panOccurrencess, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def ReplaceOccurrencesQ(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrences(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceOccurrrencesOfSubString(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceSomeOccurrencesOfSubString(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		def ReplaceSome(panOccurrences, pcSubStr, pcNewSubStr)
			This.ReplaceOccurrences(panOccurrences, pcSubStr, pcNewSubStr)

		#>

	  #----------------------------------------------------------------------#
	 #  REPLACING SOME OCCURRENCES OF A SUBSTRING BY MANY OTHER SUBSTRINGS  #
	#----------------------------------------------------------------------#

	def ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceOccurrencesByMany([ 1, 3, 5], "ring", :By = [ "#1", "#3", "#5" ])
	
		? o1.Content() #--> "#1 php ring ruby #3 python ring csharp #5"
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT Q(pacNewSubStrings).IsListOfStrings()
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		nMin = Min([ len(panOccurrences), len(pacNewSubStrings) ])
		anOccurrences = StzListQ(panOccurrences).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SortedInDescending()

		for i = 1 to nMin
			n = anOccurrences[i]
			cNewSubStr = acNewSubStrings[i]

			This.ReplaceNthOccurrenceCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
			
		next

		#< @FuntionFluentForm

		def ReplaceOccurrencesByManyCSQ(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesByMznyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceOccurrrencesOfSubStringByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceSomeOccurrencesOfSubStringByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		def ReplaceSomeByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceOccurrencesByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, pCaseSensitive)

		#>
			
	#-- WITHOUT CASESENSITIVITY

	def ReplaceOcuurencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)
		This.ReplaceOccurrencedByManyCS(panOccurrences, pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

		#< @FuntionFluentForm

		def ReplaceOccurrencesByManyQ(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceSomeOccurrencesByMzny(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceOccurrrencesOfSubStringByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceSomeOccurrencesOfSubStringByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		def ReplaceSomeByMany(panOccurrences, pcSubStr, pacNewSubStrings)
			This.ReplaceOccurrencesByMany(panOccurrences, pcSubStr, pacNewSubStrings)

		#>

	  #------------------------------------------#
	 #     REPLACING SUBSTRING AT POSITION N    #
	#------------------------------------------#

	def ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()

		if This.RangeQ(n, nLen ).IsEqualToCS(pcSubStr, pCaseSensitive)
			This.ReplaceRange(n, nLen, pcNewSubStr)
		ok

		def ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringAtPositionCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringAtPositionCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionNCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return cResult

		def SubStringAtPositionReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.SubStringAtPositionNReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceSubStringAtPositionNQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
			This.ReplaceSubStringAtPositionN(n, pcSubStr, pcNewSubStr)

			def ReplaceSubStringAtPositionQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceSubStringAtPosition(n, pcSubStr, pcNewSubStr)
				return This

	def SubStringAtPositionNReplaced(n, pcSubStr, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringAtPositionNQ(n, pcSubStr, pcNewSubStr)
		return cResult

	  #----------------------------------------------------------------------------#
	 #   REPALCING A SUBSTRING AT A SOME GIVEN POSITIONS BY AN OTHER SUBSTRING    #
	#----------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsCS(panPositions, pcSubStr, pcNewSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring ruby ring php ring")
		o1.ReplaceSubstringAtPositions([ 1, 20], "ring", :By = "")

		? o1.Content() #--> " ruby ring php "
		*/

		anPositions = StzListQ(panPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		next

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositions(panPositions, pcSubStr, pcNewSubStr)
		This.ReplaceSubStringAtPositionsCS(panPositions, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #   REPALCING A SUBSTRING AT A SOME GIVEN POSITIONS BY MANY OTHER SUBSTRINGS    #
	#-------------------------------------------------------------------------------#

	def ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python ring csharp ring")
		o1.ReplaceSubstringAtPositionsByMany([ 10, 20, 32], "ring", :By = [ "", "", "" ])

		? o1.Content() #--> "ring php  ruby  python  csharp ring"
		*/

		if isList(pacNewSubStrings) and Q(pacNewSubStrings).IsWithOrByNamedParam()
			pacNewSubStrings = pacNewSubStrings[2]
		ok

		if NOT (isList(pacNewSubStrings) and Q(pacNewSubStrings).IsListOfStrings() )
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		# Keeping only the adequate number of positsions and new substrings
		#--> Avoids incorrect results when the number of provided positions is
		#     different from the number of provided new substrings

		nMin = Min([ len(panPositions), len(pacNewSubStrings) ])

		anPositions 	= Q(panPositions).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings	= Q(pacNewSubStrings).SectionQ(1, nMin).SortedInDescending()

		# Doing the job

		for i = 1 to nMin
			n = anPositions[i]
			cNewSubStr = acNewSubStrings[i]

			This.ReplaceSubStringAtPositionNCS(n, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringAtPositionsByManyCSQ(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
			This.ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
			return This

	def SubStringAtThesePositionsReplacedByManyCS(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyCSQ(panPositions, pcSubStr, pacNewSubStrings, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringAtPositionsByMany(panPositions, pcSubStr, pacNewSubStrings)
		This.ReplaceSubStringAtPositionsByManyCS(panPositions, pcSubStr, pacNewSubStrings, :CaseSensitive = TRUE)

		def ReplaceSubStringAtPositionsByManyQ(panPositions, pcSubStr, pacNewSubStrings)
			This.ReplaceSubStringAtPositionsByMany(panPositions, pcSubStr, pacNewSubStrings)
			return This

	def SubStringAtThesePositionsReplacedByMany(panPositions, pcSubStr, pacNewSubStrings)
		cResult = This.Copy().ReplaceSubStringAtPositionsByManyQ(panPositions, pcSubStr, pacNewSubStrings).Content()
		return cResult

	  #----------------------------------------------------------------------#
	 #   REPLACING A SUBSTRING WITH A DYNAMIC VALUE (using With@ or :By@)   #
	#----------------------------------------------------------------------#

	def ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubString@( "ring", :By@ = '{ "#" + @Occurrence }' )

		? o1.Content() #--> "#1 php #2 ruby #3 pyhton #4"

		*/

		if isList(pcDynamicStr) and Q(pcDynamicStr).IsWithOrByNamedParam()
			pcDynamicStr = pcDynamicStr[2]
		ok

		if NOT isString(pcDynamicStr)
			stzRaise("Incorrect param! pacNewSubStrings must be a list of strings.")
		ok	

		anPositions = This.FindAllCSQ(pcSubStr, pCaseSensitive).SortedInDescending()


		@SubString = pcSubStr

		@NumberOfOccurrences = len(anPositions)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		acNewSubStr = []

		for @Position in anPositions

			@CurrentPosition = @Position

			i++
			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPositions[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPositions[i + 1]
				@NextOccurrence = i + 1
			ok
			
			cDynamicStr = StzStringQ(pcDynamicStr).
					SimplifyQ().
					RemoveTheseBoundsQ(["{","}"]).
					Content()

			cCode = 'cTempStr = ( ' + cDynamicStr + ' )'
			eval(cCode)

			acNewSubStr + cTempStr

		next

		acNewSubStr = StzListQ(acNewSubStr).SortedInDescending()
	
		i = 0
		for @Position in anPositions
			i++
			cNewSubStr = acNewSubStr[i]
			This.ReplaceSubStringAtPositionNCS(@Position, pcSubStr, cNewSubStr, pCaseSensitive)
		next

		def ReplaceSubStringCS@Q(pcSubStr, pcDynamicStr, pCaseSensitive)
			This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubString@(pcSubStr, pcDynamicStr)
		This.ReplaceSubStringCS@(pcSubStr, pcDynamicStr, :CaseSensitive = TRUE)

		def ReplaceSubString@Q(pcSubStr, pcDynamicStr)
			This.ReplaceSubString@(pcSubStr, pcDynamicStr)
			return This

	  #---------------------------------------------------#
	 #   REPLACING A SUBSTRING UNDER A GIVEN CONDITION   #
	#---------------------------------------------------#

	def ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring pyhton ring")
		o1.ReplaceSubStringW("ring", :Where = '{ Q(@Position).IsMultipleOf(10) }', :With = "")

		? o1.Content() #--> "ring php  ruby  pyhton ring"

		*/

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param! pcCondition must be a string.")
		ok

		anPositions = This.FindAllCS(pcSubStr, pCaseSensitive)

		@SubString = pcSubStr

		@NumberOfOccurrences = ringlen(anPositions)
		@NumberOfOccurrence  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrences
		@NumberOfSubStrings  = @NumberOfOccurrence

		i = 0
		@CurrentPosition = 0
		@PreviousPosition = 0
		@NextPosition = 0

		cCondition = StzStringQ(pcCondition).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				Content()

		anPositionsW = []

		
		i = 0
		for @Position in anPositions # TODO: replace for/in with for loop

			i++
			@CurrentPosition = @Position

			@Occurrence = i
			@CurrentOccurrence = i

			if i > 1
				@PreviousPosition = anPositions[i - 1]
				@PreviousOccurrence = i - 1
			ok

			if i < @NumberOfOccurrence
				@NextPosition = anPositions[i + 1]
				@NextOccurrence = i + 1
			ok

			cCode = "bOk = ( " + cCondition + " )"
			eval(cCode)

			if bOk
				anPositionsW + @Position
			ok

		next

		This.ReplaceSubStringAtPositionsCS(anPositionsW, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringWCSQ(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
		This.ReplaceSubStringWCS(pcSubStr, pcCondition, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceSubStringWQ(pcSubStr, pcCondition, pcNewSubStr)
			This.ReplaceSubStringW(pcSubStr, pcCondition, pcNewSubStr)
			return This
		
	  #-------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------#

	def ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm # (look to other in bottom of file)

		def ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

			def ReplaceSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			aSections = This.FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			This.ReplaceSections(aSections, pcNewSubStr)

			def ReplaceBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubstringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)

			def ReplaceSubstringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubstringBoundedByCSCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This
	
		#>

	def SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		cResult = This.ReplaceBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive).Content()
		return cResult

		def InBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This.SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def SubstringBoundedByReplacedCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This.SubStringInBetweenReplacedCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)

	#--- WITHOUT CASESENSITIVITY

	def ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm # (look to other in bottom of file)

		def ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

			def ReplaceSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				This.ReplaceSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubStr)

		def ReplaceBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			aSections = This.FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			This.ReplaceSections(aSections, pcNewSubStr)

			def ReplaceBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
				return This

		def ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceSubstringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

			def ReplaceSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
				return This


		#>

	def SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		return This.SubStringInBetweenReplacedCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, :CaseSensitive = TRUE)

		def InBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This.SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def SubstringBoundedByReplaced(pcSubStr, pacBounds, pcNewSubstr)
			return This.SubStringInBetweenReplaced(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

	  #-------------------------------------------------------------------------#
	 #  REPLACING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#-------------------------------------------------------------------------#

"todo"

def ReplaceBetweenS()
def ReplaceIBS()
	
	def ReplaceBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		aSections = This.FindSubStringBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

			def ReplaceSubStringBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			aSections = This.FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
			This.ReplaceSections(aSections, pcNewSubStr)
	
			def ReplaceBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		def ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
	
			def ReplaceSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				This.ReplaceSubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def SubStringBetweenReplacedCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		cResult = This.Copy().ReplaceBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
			cResult = This.Copy().SubStringBoundedByCSIBQ(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive).Content()
			return cResult
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceBetweenCSIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceSubStringBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)

			def ReplaceSubStringBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				This.ReplaceSubStringBetweenIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
				return This

		def ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

			def ReplaceBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
				return This

		def ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			This.ReplaceBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
	
			def ReplaceSubStringBoundedByIBQ(pcSubStr, pacBounds, pcNewSubStr)
				This.ReplaceSubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
				return This

		#>

	def SubStringBetweenReplacedIB(pcSubStr, pcBound1, pcBound2, pcNewSubStr)
		cResult = This.Copy().ReplaceBetweenIBQ(pcSubStr, pcBound1, pcBound2, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringBoundedByIB(pcSubStr, pacBounds, pcNewSubStr)
			return This.SubStringBoundedByCSIB(pcSubStr, pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

		#>	

	  #==============================================================#
	 #  REPLACING A SUBSTRING -- EXTENDED (NNC : NEAR-NATURAL CODE  #
	#==============================================================#

	def ReplaceCSXT(p1, p2, p3, pCaseSensitive)

		# Q("/\__/\/\__/\__").ReplaceXT("", [], :With = "*")
		if ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		   ( ( (isList(p2)   and len(p2) = 0) or
		     ( isString(p2) and p2 = "") or
		     (isNumber(p2) and p2 = 0) ) ) AND

		   ( isString(p3) or (isList(p3)   and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCS(p1, p3, pCaseSensitive)
			return

		#  Q("*** rin* ***").ReplaceXT("*", :In = "rin*", :With = "g")
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and
		    ( isList(p2) and Q(p2).IsInOrInSideNamedParam() )
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1)
				p1 = p1[2] // "*"
			ok

		 	p2 = p2[2] // "rin*"

			if isList(p3)
				p3 = p3[2] // "g"
			ok

			cNewSubStr = Q(p2).ReplaceCSQ(p1, p3, pCaseSensitive).Content() // "ring"

			aSections = This.FindAsSectionsCS(p2, pCaseSensitive)
			This.ReplaceSections(aSections, cNewsubStr)


		# Q("/\__/\/\__/\__").ReplaceXT("", :With = "*", [])
		but ( isString(p1) or ( isList(p1) and Q(p1).IsEachNamedParam()) ) and

		    ( isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam() ) ) AND

		    ( ( (isList(p3)   and len(p3) = 0) or
		      (isString(p3) and p3 = "") or
		      (isNumber(p3) and p3 = 0) ) )

			This.ReplaceCS(p1, p2, pCaseSensitive)
			return

		# Q("_/\__/\__/__/\_").ReplaceXT(:Nth = 4, "", :With = "\")
		but ( isNumber(p1) or
		    ( isList(p1) and Q(p1).IsNthNamedParam() ) ) and

		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and

		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			if isList(p1) and Q(p1).IsNthNamedParam()
				p1 = p1[2]
			ok

			This.ReplaceNthCS(p1, p2, p3, pCaseSensitive)

		# Q("_/\__/\__/__/\_").ReplaceXT(:First, "", :With = "\")
		but ( isString(p1) and p1 = :First) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			This.ReplaceCSXT(1, p2, p3, pCaseSensitive)

		# Q("_/\__/\__/__/\_").ReplaceXT(:Last, "", :With = "\")
		but ( isString(p1) and p1 = :Last) and
		    ( isString(p2) or ( isList(p2) and Q(p2).IsEachNamedParam()) ) and
		    ( isString(p3) or ( isList(p3) and Q(p3).IsWithOrByNamedParam() ) )

			n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
			This.ReplaceCSXT(n, p2, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :AtPosition = 2, :With = "_")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtPositionNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionNamedParam()
				p2 = p2[2]
			ok
			
			This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :AtPositions = [2, 7], :With = "~")
		but ( isString(p1) ) and

		    ( (isList(p2) and Q(p2).IsListOfNumbers() ) or
		      (isList(p2) and Q(p2).IsAtPositionsNamedParam()) ) and

		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtPositionsNamedParam()
				p2 = p2[2]
			ok

			This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)

		# Q("_/\__").ReplaceXT("", :At = [2, 7], :With = "~")
		but ( isString(p1) ) and
		    ( isNumber(p2) or (isList(p2) and Q(p2).IsAtNamedParam()) ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			if isList(p2) and Q(p2).IsAtNamedParam()
				p2 = p2[2]
			ok

			if isNumber(p2)
				This.ReplaceSubStringAtPositionCS(p2, p1, p3, pCaseSensitive)

			but isList(p2) and Q(p2).isListOfNumbers()
				This.ReplaceSubStringAtPositionsCS(p2, p1, p3, pCaseSensitive)
			ok

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :Between = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok
			
		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedBy = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCS(p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCSIB(p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings or numbers.")
			ok

		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceAnyBoundedByCSIB(p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT("", :Between = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCS(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok
			
		# Q("Bla bla //, and bla!").ReplaceXT("", :BoundedBy = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCS(p1, p2, p3, pCaseSensitive)

		# Q("Bla bla <<>>, and bla!").ReplaceXT([], :BetweenIB = ["<<",">>"], :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBetweenIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceSubstringBetweenCSIB(p1, p2[1], p2[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a pair of strings.")
			ok

		# Q("Bla bla //, and bla!").ReplaceXT([], :BoundedByIB = "/", :With = "bla")
		but isString(p1) and
		    ( isList(p2) and Q(p2).IsBoundedByIBNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			This.ReplaceSubStringBoundedByCSIB(p1, p2, p3, pCaseSensitive)

		#--
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBetweenNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a pair of strings or numbers.")
			ok
	
		#-- Allowing :BoundedBy along with :Between

		but ( (isList(p1) and len(p1) = 0) or (isString(p1) and p1 = "") or (isNumber(p1) and p1 = 0) ) and
		    ( isList(p2) and Q(p2).IsBoundedByNamedParam() ) and
		    ( isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p2 = p2[2]
			
			if isList(p2) and Q(p2).IsPairOfNumbers()
				This.ReplaceSection(p2[1], p2[2], p3)

			but isList(p2) and Q(p2).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p2[1], p2[2], p3, pCaseSensitive)

			but isString(p2)

				This.ReplaceAnyBetweenCS(p2, p2, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p2 must be a string, or a pair of strings or numbers.")
			ok
			
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam() ) and
		      (isString(p2) or (isList(p2) and Q(p2).IsWithOrByNamedParam())) and
		      ((isList(p3) and len(p3) = 0) or (isString(p3) and p3 = "") or (isNumber(p3) and p3 = 0)) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p2)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p2, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p2, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok
	
		but ( (isList(p1) and Q(p1).IsBoundedByNamedParam()) and
		      ((isList(p2) and len(p2) = 0) or (isString(p2) and p2 = "") or (isNumber(p2) and p2 = 0))) and
		      (isString(p3) or (isList(p3) and Q(p3).IsWithOrByNamedParam()) )

			p1 = p1[2]

			if isList(p1) and Q(p1).IsPairOfNumbers()
				This.ReplaceSection(p1[1], p1[2], p3)

			but isList(p1) and Q(p1).IsPairOfStrings()
				This.ReplaceAnyBetweenCS(p1[1], p1[2], p3, pCaseSensitive)

			but isString(p1)
				This.ReplaceAnyBetweenCS(p1, p1, p3, pCaseSensitive)

			else
				StzRaise("Incorrect param type! p1 must be a string, or a pair of strings or numbers.")
			ok

		ok

	#-- WITHOUT CASESENSITIVITY

	def ReplaceXT(p1, p2, p3)
		This.ReplaceCSXT(p1, p2, p3, :CaseSensitive = TRUE)

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
	
		o1 = new stzString("...12...1212...121212...")
		? o1.SubStringsMadeOf("12")
		#--> [ "12", "1212", "121212" ]
	
		*/
	
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		acResult = This.Sections(aSections)
		
		return acResult
		
		def MadeOfCS(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOf(pcSubStr)
		return This.SubStringsMadeOfCS(pcSubStr, :CaseSensitive = TRUE)
	
		def MadeOf(pcSubStr)
			return This.SubStringsMadeOf(pcSubStr)

	  #==============================================#
	 #  SUBSTRINGS MADE OF A GIVEN OTHER SUBSTRING  #
	#==============================================#
	
	def SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)
		aSections = This.FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = This.SectionsXT(aSections)
		return aResult

		def MadeOfCSXT(pcSubStr, pCaseSensitive)
			return This.SubStringsMadeOfCSXT(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsMadeOfXT(pcSubStr)
		return This.SubStringsMadeOfCSXT(pcSubStr, :CaseSensitive = TRUE)
	
		def MadeOfXT(pcSubStr)
			return This.SubStringsMadeOfXT(pcSubStr)

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		anResult = [ anPos[1] ]
		for i = 2 to nLen
			if anPos[i] - anPos[i-1] = nLenSubStr
				loop
			ok

			anResult + anPos[i]
		next

		return anResult


		def FindSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def FindAllOccurrencesOfSubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

		def PositionsOfubStringsMadeOfCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindMadeOf(pcSubStr)
		return This.FindMadeOfCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def FindAllOccurrencesOfSubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

		def PositionsOfubStringsMadeOf(pcSubStr)
			return This.FindMadeOf(pcSubStr)

	  #------------------------------------------------#
	 #  FINDING SUBSTRINGS MADE OF A GIVEN SUBSTRING  #
	#------------------------------------------------#

	def FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		#                      4   8 1   4 6 8   2
		o1 = new stzString("...12..1212..121212..12.")
		? @@( o1.FindMadeOf("12") )
		#--> [ 4, 8, 10, 14, 16, 18 ]

		*/

		# Preparing some values we need

		nLenStr = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		cFirstChar = Q(pcSubStr).FirstChar()

		# Finding the positions of pcSubStr in the string

		anPos = This.FindMadeOfCS(pcSubStr, pCaseSensitive)
		nLenPos = len(anPos)

		aResult = []
		
		# For each postion
		for i = 1 to nLenPos

			# we start parsing the string from that position
			n = anPos[i]
			nNext = 0
			if i < nLenPos
				nNext = anPos[i+1]
			ok

			# if the char we are parsing does not belong to
			# pcSubStr, then we stop the parsing and return
			# the section (done for each position)

			while TRUE
				n += nLenSubStr
				if n > nLenStr or
				   (nNext != 0 and n >= nNext)
					exit
				ok
		
				if NOT This.CharQ(n).IsEqualToCS(cFirstChar, pCaseSensitive)
					aTempSection = [ anPos[i], (n-1) ]

					if len(aResult) > 0 and
					   anPos[i] = aResult[len(aResult)][1]

						aResult[len(aResult)][2] = (n-1)

					else
						aResult + [ anPos[i], (n-1) ]
					ok
				ok

				
			end
		next
		
		return aResult

		def FindSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

		def PositionsOfSubStringsMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindMadeOfAsSectionsCS(pcSubStr, pCaseSensitive)

	#--  WITHOUT CASESENSITIVITY

	def FindMadeOfAsSections(pcSubStr)
		return This.FindMadeOfAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

		def PositionsOfSubStringsMadeOfAsSections(pcSubStr)
			return This.FindMadeOfAsSections(pcSubStr)

	  #=============================================================================#
	 #  YIELDING CHARS STARTING AT A GIVEN POSITION UNTIL A CONDITION IS VERIFIED  #
	#=============================================================================#

	def YieldXT(pcAction, pnStartingAt, pUptoOrUntil)
		/* EXAMPLE
	
		See examples in the same function in stzList
	
		*/
	
		if NOT isString(pcAction)
			StzRaise("Incorrect param type! pcAction must be a string.")
		ok

		if isString(pnStartingAt)
			pnStartingAt =  Q(pnStartingAt).
					SubStringsReplacedCS( [ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsAPairOfStrings()
			pnStartingAt[2] = Q(pnStartingAt[2]).
					  SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isString(pUptoOrUntil)
			pUptoOrUntil =  Q(pUptoOrUntil).
					SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		if isList(pUptoOrUntil) and Q(pUptoOrUntil).IsAPairOfStrings()
			pUptoOrUntil[2] = Q(pUptoOrUntil[2]).
					  SubStringsReplacedCS(
						[ "char", "substring", "string" ],
						:With = "item", :CS = FALSE)
		ok

		cAction  = StzCCodeQ(pcAction).Transpiled()
		acResult = This.CharsQ().YieldXT(cAction, pnStartingAt, pUpToOrUntil)
		return acResult

		#< @FunctionFluentForm

		def YieldXTQ(pcAction, pnStartingAt, pUptoOrUntil)
			return This.YieldXTQR(pcAction, pnStartingAt, pUptoOrUntil, :stzList)

		def YieldXTQR(pcAction, pnStartingAt, pUptoOrUntil, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isSting(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfStrings
				return new stzListOfStrings( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfChars
				return new stzListOfChars( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			on :stzListOfPairs
				return new stzListOfPairs( This.YieldXT(pcAction, pnStartingAt, pUptoOrUntil) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	  #========================================================#
	 #  REPLACING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================#

	def ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceanyBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm: SeeBottomOfFile >

	def SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		acResult = This.Copy().ReplaceBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive).Content()
		return acResult

		def SubStringsBoundedByReplacedCS(pacBounds, pcNewSubStr, pCaseSensitive)
			acResult = This.Copy().ReplaceBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			return acResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)
		return This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceAnyBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		acResult = This.Copy().ReplaceAnyBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

	  #--------------------------------------------------------------------#
	 #  REPLACING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- EXTENDED  #
	#--------------------------------------------------------------------#
	#--> Bounds are also replaced (TODO: Generalise this feature)

	def ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		This.ReplaceSections(aSections, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceAnyBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		acResult = This.Copy().ReplaceBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	#-- WITHOUT CASESENSITIVITY

	def ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		return This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	def SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		acResult = This.Copy().ReplaceBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, :CS = TRUE).Content()
		return acResult

		#< @FunctionAlternativeForms: SeeBottomOfFile >

	  #==========================================#
	 #   REPLACING A CHAR AT A GIVEN POSITION   #
	#==========================================#

	def ReplaceCharAtPosition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		This.ReplaceSection(n, n, pcNewSubStr)

		def ReplaceCharAtPositionQ(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)
			return This

		#< @FunctionAlternativeForms

		def ReplaceCharAt(n, pcNewSubStr)
			if isList(n) and Q(n).IsPositionNamedParam()
				n = n[2]
			ok

			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtQ(n, pcNewSubStr)
				This.ReplaceCharAt(n, pcNewSubStr)
				return This

		def ReplaceCharAtPositionN(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtPositionNQ(n, pcNewSubStr)
				This.ReplaceCharAtPositionN(n, pcNewSubStr)
				return This

		def ReplaceCharAtThisPosition(n, pcNewSubStr)
			This.ReplaceCharAtPosition(n, pcNewSubStr)

			def ReplaceCharAtThisPositionQ(n, pcNewSubStr)
				This.ReplaceCharAtThisPosition(n, pcNewSubStr)
				return This

		#>

	def CharReplacedAtPsoition(n, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		cResult = This.Copy().ReplaceCharAtPositionQ(n, pcNewSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def CharReplacedAtThisPsoition(n, pcNewSubStr)
			return This.CharReplacedAtPsoition(n, pcNewSubStr)

		def CharAtPositionNReplaced(n, pcNewSubStr)
			return This.CharReplacedAtPsoition(n, pcNewSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def ReplaceCharsAtPositions(panPositions, pcNewSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if isList(panPositions) and len(panPositions) = 0
			return
		ok

		# Checking the correctness of panPositions param

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param! panPositions must be list of numbers.")
		ok

		anPositions = Q(panPositions).SortedInDescending()

		for n in anPositions
			This.ReplaceCharAtPositionN(n, pcNewSubStr)
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsQ(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAt(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)

		def ReplaceCharsAtThesePositions(panPositions, pcNewSubStr)
			This.ReplaceCharsAtPositions(panPositions, pcNewSubStr)

		#>

	def CharsReplacedAtPsoitions(panPositions, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsAtPositionsQ(panPositions, pcNewSubStr).Content()
		return cResult

		def CharsReplacedAtThesePsoitions(panPositions, pcNewSubStr)
			return This.CharsReplacedAtPsoitions(panPositions, pcNewSubStr)

		def CharsAtThesePositionsReplaced(panPositions, pcNewSubStr)
			return This.CharsReplacedAtPsoitions(panPositions, pcNewSubStr)

	  #-----------------------------------------------------------#
	 #   REPLACING CHARS AT GIVEN POSITIONS BY MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)
		/* EXAMPLE
		o1 = new stzString("ab3de6gh9")
		o1.ReplaceCharsAtPositionsByMany([3, 6, 9], [ "c", "f", "i" ])

		? o1.Content() #--> "abcdefghi"
		*/

		anPositions = StzListOfNumbersQ(panPositions).SortedInDescending()

		nMin = Min([ len(anPositions), len(pacNewSubStrings) ])
		anPositions = StzListQ(anPositions).SectionQ(1, nMin).SortedInDescending()
		acNewSubStrings = StzListQ(pacNewSubStrings).SectionQ(1, nMin).SortedInDescending()

		i = 0
		for n in anPositions
			i++
			This.ReplaceCharAtPosition(n, acNewSubStrings[i])
		next

		#< @FunctionFluentForm

		def ReplaceCharsAtPositionsByManyQ(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)
			return This
		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsAtByMany(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)

		def ReplaceCharsAtThesePositionsByMany(panPositions, pacNewSubStrings)
			This.ReplaceCharsAtPositionsByMany(panPositions, pacNewSubStrings)

		#>

	def CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)
		cResult = This.Copy().ReplaceCharsAtPositionsByManyQ(panPositions, pacNewSubStrings).Content()
		return cResult

		def CharsReplacedAtThesePsoitionsByMany(panPositions, pacNewSubStrings)
			return This.CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)

		def CharsAtThesePositionsReplacedByMany(panPositions, pacNewSubStrings)
			return This.CharsReplacedAtPsoitionsByMany(panPositions, pacNewSubStrings)

	  #-------------------------------------------------------------------------#
	 #   REPLACING CHARS/SUBSTRINGS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#-------------------------------------------------------------------------#

	def ReplaceW(pcCondition, pcCharOrSubStr)
	
		# Checking params

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		if isList(pcCharOrSubStr) and Q(pcCharOrSubStr).IsWithOrByNamedParam()
			pcCharOrSubStr = pcCharOrSubStr[2]
		ok

		if NOT isString(pcCharOrSubStr)
			StzRaise("Incorrect param type! pcCharOrSubStr must be a string.")
		ok

		# Doing the job

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsNeitherCS("@char", :Nor = "@substring", :CS = FALSE) or
		   oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Incorrect syntax ! pcCondition must contains either @char or @substring keywords (but not both).")
		ok

		if oCondition.ContainsCS("@char", pCaseSensitive)
			anPos = FindCharsW(pcCondition)
			This.ReplaceCharsAtPositions(anPos, pcCharOrSubStr)

		else # contains @substring
			anPos = Thid.FindSubStringsW(pcCondition)
			This.ReplaceSubStringsAtPositions(anPos, pcCharOrSubStr)
		ok

	  #--------------------------------------------------------------------#
	 #     REPLACING ALL CHARS WITH A SUBSTRING UNDER A GIVEN CONDITION   #
	#--------------------------------------------------------------------#

	def ReplaceCharsW(pcCondition, pcNewSubStr)
		#< @MotherFunctions:
		#	This.FindCharsW()  > @RingBased
		#	This.ReplaceSection() > @QtBased
		#>

		/*
		Example:

		StzStringQ( "Text processing with Ring" ) {

			ReplaceAllCharsW(
				:Where = '{ @char = "i" }',
				:With = "*"
			)

			? Content()
		}

		--> Returns: "Text process*ng w*th R*ng"
		*/

		# Checking the correctness of the pcCondition param
			#--> Not necessary! It will be done by the
			# mother function FindAllCharsW()

		# Checking the correctness of the pcNewSubStr param
			#--> Not necceary! It will be done by the
			# called function ReplaceCharsAtPositions()

		# Doing the job

		anPositions = This.FindCharsW(pcCondition)
		This.ReplaceCharsAtPositions(anPositions, pcNewSubStr)


		#< @FunctionFluentForm

		def ReplaceCharsWQ(pCondition, pcNewSubStr)
			This.ReplaceCharsWhere(pCondition, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def ReplaceCharsWhere(pCondition, pcNewSubStr)
			This.ReplaceCharsW(pCondition, pcNewSubStr)

			def ReplaceCharsWhereQ(pCondition, pcNewSubStr)
				This.ReplaceCharsWhere(pCondition, pcNewSubStr)
				return This

		#>

	def CharsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceCharsWQ(pcCondition, pcSubStr).Content()
		return cResult

	  #-------------------------------------------------------------------------------#
	 #  REPLACING ALL SUSBSTRINGS OBEYING TO A GIVEN CONDITION BY A GIVEN SUBSTRING  #
	#-------------------------------------------------------------------------------#

	def ReplaceSubStringsW(pcCondition, pcNewSubStr)
		aSections = This.FindSubStringsAsSectionsW(pcCondition)
		This.ReplaceSections(aSections, pcNewSubStr)

		def ReplaceSubStringsWQ(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsW(pcCondition, pcNewSubStr)
			return This

		def ReplaceSubStringsWhere(pcCondition, pcNewSubStr)
			This.ReplaceSubStringsW(pcCondition, pcNewSubStr)

			def ReplaceSubStringsWhereQ(pcCondition, pcNewSubStr)
				This.ReplaceSubStringsWhere(pcCondition, pcNewSubStr)
				return This

	def SubStringsReplacedW(pcCondition, pcNewSubStr)
		cResult = This.Copy().ReplaceSubStringsWQ(pcCondition, pcNewSubStr).Content()
		return cResult

	  #----------------------------------------------------#
	 #     REPLACING THE NTH OCCURRENCE OF A SUBSTRING    #
	#----------------------------------------------------#

	def ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok
	
		if n = :First
			n = 1
	
		but n = :Last
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
		ok
	
		n = This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
	
		if n > 0
			oSubStr = new stzString(pcSubStr)
			This.ReplaceSection( n, n + oSubStr.NumberOfChars()-1, pcNewSubStr)
		ok
	
		#< @FunctionFluentForm
	
		def ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		def ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNthCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def NthOccurrenceReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()


	#-- WITHOUT CASESENSITIVITY

	def ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
		This.ReplaceNthOccurrenceCS(n, pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceNthOccurrenceQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)
			return This
	
		#>

		def ReplaceNth(n, pcSubStr, pcNewSubStr)
			This.ReplaceNthOccurrence(n, pcSubStr, pcNewSubStr)

			def ReplaceNthQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNth(n, pcSubStr, pcNewSubStr)
				return This

	def NthOccurrenceReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr).Content()

	  #-------------------------------------------------#
	 #    REPLACING FIRST OCCURRENCE OF A SUBSTRING    #
	#-------------------------------------------------#

	def ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceFirstCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceFirstCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def FirtOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceFirstOccurrenceCS(pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternative

		def ReplaceFirst(pcSubStr, pcNewSubStr)
			This.ReplaceFirstOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceFirstQ(pcSubStr, pcNewSubStr)
				This.ReplaceFirst(pcSubStr, pcNewSubStr)
				return This

		#>

	def FirtOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	  #--------------------------------------------------#
	 #     REPLACING LAST OCCURRENCE OF A SUBSTRING     #
	#--------------------------------------------------#

	def ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, pcNewSubStr, pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceLastCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceLastCS(pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceReplacedCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceLastOccurrenceCSQ(pcSubStr, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
		This.ReplaceLastOccurrenceCS(pcSubStr, pcNewSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def ReplaceLast(pcSubStr, pcNewSubStr)
			This.ReplaceLastOccurrence(pcSubStr, pcNewSubStr)

			def ReplaceLastQ(pcSubStr, pcNewSubStr)
				This.ReplaceLast()
				return This

		#>

	def LastOccurrenceReplaced(pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceLastOccurrenceQ(pcSubStr, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		
		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2] + 1, pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :First or :FirstOccurrence
				nStart = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			on :FirstPosition or :FirstChar
				nStart = 1

			off
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthNextOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthNextOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def NextNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.ReplaceNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

	def NextNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #------------------------------------------------#
	  #    REPLACING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplaceNextOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def NextOccurenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceNextOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplaceNextNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplaceNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplaceNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	   #--------------------------------------------------------#
	  #    REPLACING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                        #
	#--------------------------------------------------------#

	def ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("ring php ring ruby ring python ring")
		o1.ReplacePreviousNthOccurrence(2, :Of = "ring", :StartingAtOccurrence = 3, :By = "")
		
		? o1.Content() #-->  php ring ruby ring python ring
		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param! pcSubStr must be a string.")
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			if Q(nStart[1]).IsOneOfThese([ :StartingAt, :StartingAtPosition ])
				nStart = nStart[2]

			but nStart[1] = :StartingAtOccurrence

				nStart = This.FindNthOccurrenceCS(nStart[2], pcSubStr, pCaseSensitive)
			ok
			
		ok

		if isString(nStart)
			switch nStart
			on :Last or :LastOccurrence
				nStart = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

			on :LastPosition or :LastChar
				nStart = This.NumberOfChars()

			off
		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.ReplaceNthOccurrenceCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		def ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

			def ReplaceNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				This.ReplaceNthPreviousOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
				return This

	def PreviousNthOccurrenceReplacedCS(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(n, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def ReplaceNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.ReplaceNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

	def PreviousNthOccurrenceReplaced(n, pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr).Content()

	   #----------------------------------------------------#
	  #    REPLACING PREVIOUS OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, pCaseSensitive)

		def ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			This.ReplacePreviousOccurrenceCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
			return This

	def PreviousOccurrenceReplacedCS(pcSubStr, nStart, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplacePreviousOccurrenceCSQ(pcSubStr, nStart, pcNewSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.ReplacePreviousNthOccurrenceCS(1, pcSubStr, nStart, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.ReplacePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceReplaced(pcSubStr, nStart, pcNewSubStr)
		return This.Copy().ReplacePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr).Content()

	  #----------------------------------------------------#
	 #  REPLACING THE FIRST N OCCURRENCES OF A SUBSTRING  #
	#----------------------------------------------------#

	def ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		anPos = This.FindFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.ReplaceSubStringAtPositionsCS(anPos, pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceFirstNOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

		def ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceNFirstOccurrencesCSQ(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				This.ReplaceNFirstOccurrencesCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
				return This

	def FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
		return This.Copy().ReplaceFirstNOccurrencesCSQ(n, pcNewSubStr, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)
			return This.FirstNOccurrencesReplacedCS(n, pcSubStr, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
		This.ReplaceFirstNOccurrencesCS(n, pcSubStr, pcNewSubStr, :CaseSensitive = TRUE)

		def ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)
			return This

		def ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
			This.ReplaceFirstNOccurrences(n, pcSubStr, pcNewSubStr)

			def ReplaceNFirstOccurrencesQ(n, pcSubStr, pcNewSubStr)
				This.ReplaceNFirstOccurrences(n, pcSubStr, pcNewSubStr)
				return This

	def FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
		return This.Copy().ReplaceFirstNOccurrencesQ(n, pcSubStr, pcNewSubStr).Content()

		def NFirstOccurrencesReplaced(n, pcSubStr, pcNewSubStr)
			return This.FirstNOccurrencesReplaced(n, pcSubStr, pcNewSubStr)

	  #========================#
	 #   REPLACING NTH CHAR   # 
	#========================#

	def ReplaceNthChar(n, pSubStr)
		#< @MotherFunction = This.ReplaceSection() > @QtBased = TRUE #>

		if n = :LastChar or n = :EndOfString or n = :Last
			n = This.NumberOfChars()

		but n = :FirstChar or n = :StartOfString or n = :First
			n = 1
		ok

		if isList(pSubStr) and
		   len(pSubStr) = 2 and
		   StzListQ(pSubStr).IsPairOfStrings()

			if pSubStr[1] = :With
				pSubStr = pSubStr[2]

			but pSubStr[1] = :With@

				cCode = 'pSubStr = ' +
				StzStringQ(pSubStr[2]).
				TrimQ().RemoveTheseBoundsQ(["{","}"]).Content()

				eval(cCode)
			ok
		ok

		This.ReplaceSection(n, n , pSubStr)

		#< @FunctionFluentForm

		def ReplaceNthCharQ(n, pcSubStr)
			This.ReplaceNthChar(n, pcSubStr)
			return This

		#>

	def NthCharReplaced(n, pValue)
		cResult = This.Copy().ReplaceNthCharQ(n, pValue).Content()
		return cResult

	  #-----------------------------------------------#
	 #  REPLACING FIRST CHAR WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def ReplaceFirstChar(pcSubStr)
		This.ReplaceNthChar(1, pcSubStr)

		def ReplaceFirstCharQ(pcSubStr)
			This.ReplaceFirstChar(pcSubStr)
			return This

	def FirstCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Content()

	  #----------------------------------------------#
	 #  REPLACING LAST CHAR WITH A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def ReplaceLastChar(pcSubStr)
		This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)

		def ReplaceLastCharQ(pcSubStr)
			This.ReplaceLastChar(pcSubStr)
			return This

	def LastCharReplaced(pcSubStr)
		return This.Copy().ReplaceFirstCharQ(pcSubStr).Contenr()

	  #------------------------------------------------------------#
	 #  REPLACING NTH GIVEN CHAR (IF ANY) WITH A GIVEN SUBSTRING  #
	#------------------------------------------------------------#

	def ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)

		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.ReplaceNthChar(n, pcSubStr)
		ok

		def ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive)
			This.ReplaceThisNthCharCS(n, cChar, pcSubStr, pCaseSensitive)
			return This

	def ThisNthCharReplacedCS(n, cChar, pcSubStr, pCaseSensitive)
		return This.Copy().ReplaceThisNthCharCSQ(n, cChar, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisNthChar(n, cChar, pcSubStr)
		This.ReplaceThisNthCharCS(n, cChar, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisNthCharQ(n, cChar, pcSubStr)
			This.ReplaceThisNthChar(n, cChar, pcSubStr)
			return This

	def ThisNthCharReplaced(n, cChar, pcSubStr)
		return This.Copy().ReplaceThisNthCharQ(n, cChar, pcSubStr).Content()

	  #-----------------------------------------------------------------#
	 #  REPLACING A GIVEN FIRST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#-----------------------------------------------------------------#

	def ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.FirstCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(1, pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisFirstCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisFirstCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisFirstCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisFirstChar(c, pcSubStr)
		This.ReplaceThisFirstCharCSQ(c, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisFirstCharQ(c, pcSubStr)
			This.ReplaceThisFirstChar(c, pcSubStr)
			return This

	def ThisFirstCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisFirstCharQ(c, pcSubStr).Content()

	  #----------------------------------------------------------------#
	 #  REPLACING A GIVEN LAST CHAR (IF ANY) WITH A GIVEN SUBSTRING   # 
	#----------------------------------------------------------------#

	def ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
		if isString(c) and This.LastCharQ().IsEqualToCS(c)
			This.ReplaceNthChar(This.NumberOfChars(), pcSubStr)
		ok

		#< @FunctionFluentForm

		def ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive)
			This.ReplaceThisLastCharCS(c, pcSubStr, pCaseSensitive)
			return This

		#>

	def ThisLastCharReplacedCS(c, pcSubStr, pCaseSensitive)

		cResult = This.Copy().
				ReplaceThisLastCharCSQ(c, pcSubStr, pCaseSensitive).
				Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisLastChar(c, pcSubStr)
		This.ReplaceThisLastCharCSQ(c, pcSubStr, :CaseSensitive = TRUE)

		def ReplaceThisLastCharQ(c, pcSubStr)
			This.ReplaceThisLastChar(c, pcSubStr)
			return This

	def ThisLastCharReplaced(c, pcSubStr)
		return This.Copy().ReplaceThisLastCharQ(c, pcSubStr).Content()

	  #--------------------------#
	 #    REPLACING ALL CHARS   # 
	#--------------------------#

	def ReplaceAllChars(pcSubStr)

		if isList(pcSubStr) and Q(pcSubStr).IsWithNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		cResult = ""
		for i = 1 to This.NumberOfChars()
			cResult += pcSubStr
		next

		This.Update( cResult )

		#< @FunctionFluentForm

		def ReplaceAllCharsQ(pcSubStr)
			This.ReplaceAllChars(pcSubStr)
			return This

		#>

	def AllCharsReplaced(pcSubStr)
		cResult = This.Copy().ReplaceAllCharsQ(pcSubStr).Content()
		return cResult

	  #================================#
	 #    INTERPOLATING THE STRING    # 
	#================================#

	def Interpolate()
		/* EXAMPLE

		max = RingMaxIntegerXT()
		min = RingMinIntegerXT()

		? Q("The range of integers is {min} to {max}").Interpolated();
		
		#--> The range of integers is '-999_999_999_999_999' to
		     '999_999_999_999_999'

		NOTE the use of the XT() extension to return the number
		spacified by "_"

		*/

		aSectionsXT = This.SubStringsBetweenZZ("{", "}")
		#--> [ [ "min", [ 27, 29 ] ], [ "max", [ 36, 38 ] ] ]

		nLen = len(aSectionsXT)

		for i = nLen to 1 step -1
		
			cVar	 = aSectionsXT[i][1]
			cCode	 = 'cValue	 = (' + cVar + ' )'
			eval(cCode)
		
			n1 = aSectionsXT[i][2][1] - 1
			n2 = aSectionsXT[i][2][2] + 1
			
			This.ReplaceSection(n1, n2, cValue)

		next

		#< @FunctionFluentForm

		def InterpolateQ()
			This.Interpolate()
			return This

		#>

		#< @FunctionMisspelledForms

		def Interpoltate()
			return This.Interpolate()

			def InterpoltateQ()
				This.Interpoltate()
				return This

		def Intrepolate()
			return This.Interpolate()

			def IntrepolateQ()
				This.Interpoltate()
				return This
		#>
			
	def Interpolated()
		return This.Copy().InterpolateQ().Content()

		#< @FunctionMisspelledForm

		def Interpoltated()
			return This.Interpolated()

		def Intrepolatef()
			return This.Interpolated()

		#>
		
	  #===========================================#
	 #  CHECKING IF THE STRING CONTAINS MARKERS  #
	#===========================================#

	def ContainsMarkers()
		/*
		? StzString('My kids are #1, #2, and #3!').ContainsMarkers() --> TRUE
		*/

		if This.NumberOfMarkers() > 0
			return TRUE
		else
			return FALSE
		ok

	  #=============================================#
	 #    CHECKING IF THE STRING IS A RING CODE    # 
	#=============================================#

	def IsValidRingCode()

		try
			eval(This.Copy().Content())
			return TRUE
		catch
			return FALSE
		done

		def IsEvaluableRingCode()
			return This.IsValidRingCode()

		def IsRingCode()
			return This.IsValidRingCode()

	  #------------------------------------------------#
	 #    EXECUTING RING CODE HOSTED IN THE STRING    # 
	#------------------------------------------------#

	def Execute()
		if This.IsValidRingCode()
			eval(This.String())
		ok

		def Run()
			This.Execute()

	def ExecuteAndReturn()
		if This.StartsWithCS("return ", :CS = FALSE)
			eval(This.String())
		else
			cCode = "return " + This.String()
			eval(cCode)
		ok

		def RunAndReturn()
			This.ExecuteAndReturn()

	  #----------------------------#
	 #     CLEARING THE STRING    #
	#----------------------------#

	def Clear()
		This.UpdateWith("")

		#< @FunctionFluentForm

		// Clears the string and return it as a StzObject
		// to take other actions on it
		def ClearQ()
			This.Clear()
			return This

		#>

	  #---------------------------------------------------------#
	 #  VERIFYING IF THE STRING IS EMPTY (NULL IN RING TERMS)  #
	#---------------------------------------------------------#

	def IsEmpty()
		return This.Content() = ""

	  #-----------------------------------------------------------#
	 #  FILLING THE STRING WITH N COPIES OF THE GIVEN SUBSTRING  #
	#-----------------------------------------------------------#

	def FillWith(n, cSubStr)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(cSubStr)
			StzRaise("Incorrect param type! cSubStr must be a string.")
		ok

		cStr = Q(cSubStr).RepeatedNTimes(n)
		This.UpdateWith(cStr)

		#< @FunctionFluentForm

		def FillWillQ(n, cChar)
			This.FillWith(n, cChar)
			return This

		#>
		
	  #-----------------------#
	 #  RESIZING THE STRING  #
	#-----------------------#

	def Resize(n)
		cResult = NULL

		if n <= NumberOfChars()
			cResult = This.FirstNChars(n)
		else
			cResult = This.ExtendToNChars(n, :Using = " ")
		ok

		This.Update(cResult)
		
		#< @FunctionFluentForm

		def ResizeQ(n)
			This.Resize(n)
			return This
	
		#>

	  #-----------------------------------------------#
	 #  ADDING A SUBSTRING AT THE END OF THE STRING  #
	#-----------------------------------------------#

	def AddSubString(pcSubStr)
		This.Update( :With = This.Content() + pcSubStr )

	  #------------------------------------------#
	 #  ADDING A CHAR AT THE END OF THE STRING  #
	#------------------------------------------#

	def AddChar(c)
		if isString(c) and Q(c).IsChar()
			This.AddSubString(c)
		else
			stzRaise("Incorrect param type! c must be a char.")
		ok


	  #-----------------------#
	 #  UPDATING THE STRING  #
	#-----------------------#

	def Update(pcNewStr)
		#< QtBased | Uses QString.clear() and QString.append() >

		if isList(pcNewStr) and Q(pcNewStr).IsWithOrByOrUsingNamedParam()
			pcNewStr = pcNewStr[2]
		ok
	
		@oQString.clear()
		@oQString.append(pcNewStr)

		//This.VerifyConstraints()

		#< @FunctionFluentForm

		def UpdateQ(pcNewStr)
			This.Update(pcNewStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def UpdateWith(pcNewStr)
			This.Update(pcNewStr)

			def UpdateWithQ(pcNewStr)
				return This.UpdateQ(pcNewStr)
	
		def UpdateBy(pcNewStr)
			This.Update(pcNewStr)

			def UpdateByQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		def UpdateUsing(pcNewStr)
			This.Update(pcNewStr)

			def UpdateUsingQ(pcNewStr)
				return This.UpdateQ(pcNewStr)

		#>

	def Updated(pcNewStr)
		return pcNewStr

		#< @FunctionAlternativeForms

		def UpdatedWith(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedBy(pcNewStr)
			return This.Updated(pcNewStr)

		def UpdatedUsing(pcNewStr)
			return This.Updated(pcNewStr)

		#>

	  #----------------------------------------#
	 #     CONTAINING ONLY SPACES & LETTERS   #
	#----------------------------------------#

	// Verifies if the string contains only spaces
	def ContainsOnlySpaces()
		if This.content() = ""
			return FALSE
		ok

		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if c != " "
				bResult = FALSE
				exit
			ok
		next

		return bResult

	def ContainsOnlyLetters()
		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			if NOT This.CharAtQ(i).IsLetter()
				bResult = FALSE
				exit
			ok
		next

		return bResult

	  #---------------------------------------------------------#
	 #  CHEHCKING IF THE STRING STARTS WITH A GIVEN SUBSTRING  #
	#---------------------------------------------------------#

	def StartsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.startsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.startsWith(pcSubStr, pCaseSensitive)
		return bResult


		def BeginsWithCS(pcSubStr, pCaseSensitive)
			return This.StartsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWith(pcSubStr)
		return This.StartsWithCS(pcSubStr, :CaseSensitive = TRUE)

		def BeginsWith(pcSubStr)
			return This.StartsWith(pcSubStr)

	  #----------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.BeginsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def StartsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.BeginsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESNESITIVITY

	def BeginsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, :CaseSensitive = TRUE)

		def StartsWithOneOfThese(paSubStr)
			return This.BeginsWithOneOfThese(paSubStr)

	  #--------------------------------------------------------------------#
	 #  CHECKS IF THE STRING STARTS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#--------------------------------------------------------------------#

	def StartsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		if NOT BothAreStrings(pSubStr1, pSubStr2)
			stzRaise("Incorrect params types! Both pSubStr1 and pSubStr2 must be strings.")
		ok

		return This.StartsWithOneOfTheseCS([pSubStr1, pSubStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def StartsWithEither(pSubStr1, pSubStr2)
		return This.StartsWithEitherCS(pSubStr1, pSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH A GIVEN GIVEN SUBSTRING  #
	#----------------------------------------------------------#

	def EndsWithCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses oQString.endsWith() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		bResult = @oQString.endsWith(pcSubStr, pCaseSensitive)
		return bResult


		def FinishsWithCS(pcSubStr, pCaseSensitive)
				return This.EndsWithCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWith(pcSubStr)
		return @oQString.endsWith(pcSubStr, 0)

		def FinishsWith(pcSubStr)
			return This.EndsWith()

	  #--------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OF THE GIVEN SUBSTRINGS  #
	#--------------------------------------------------------------#

	def EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE

		for cSubStr in paSubStr
			if This.EndsWithCS(cSubStr, pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def FinishsWithOneOfTheseCS(paSubStr, pCaseSensitive)
			return This.EndsWithOneOfTheseCS(paSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def EndsWithOneOfThese(paSubStr)
		return This.BeginsWithOneOfTheseCS(paSubStr, :CaseSensitive = TRUE)

		def FinsihsWithOneOfThese(paSubStr)
			return This.EndsWithOneOfThese(paSubStr)

	  #------------------------------------------------------------------#
	 #  CHECKS IF THE STRING ENDS WITH ONE OR AN OTHER GIVEN SUBSTRING  #
	#------------------------------------------------------------------#

	def EndsWithEitherCS(pSubStr1, pSubStr2, pCaseSensitive)
		if isList(pSubStr2) and Q(pSubStr2).IsOrNamedParam()
			pSubStr2 = pSubStr2[2]
		ok

		return This.EndsWithOneOfTheseCS([ pSubStr1, pSubStr2], pCaseSenitive)

	#-- WTHOUT CASESENSITIVITY

	def EndsWithEither(pSubStr1, pSubStr2)
		return This.EndsWithEitherCS(pSubStr1, pSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  GETTING THE SUBSTRING OCCURRENCE BY ITS POSITION  #
	#----------------------------------------------------#

	def SubStringOccurrenceByPositionCS(nPos, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.SubStringOccurrenceByPosition(9, "ring") #--> 2
		*/

		nResult = 0

		anPositions = This.FindSubStringCS(pcSubStr, pCaseSensitive)
		i = 0
		for n in anPositions
			i++
			if n = nPos
				nResult = i
				exit
			ok
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def SubStringOccurrenceByPosition(nPos, pcSubStr)
		return This.SubStringOccurrenceByPositionCS(nPos, pcSubStr, :CaseSensitive = TRUE)

	  #---------------------------------------------#
	 #   FINDING THE NTH OCCURRENCE OF SUBSTRING   #
	#---------------------------------------------#

	def FindNthCS(n, pcSubstr, pCaseSensitive) #--> Returns 0 if nothing found

		# Resolving the pcSubStr param

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be as a string.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		# Early-checking for better performance (in case of!)

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		# Resolving the n param

		if isString(n)
			cNLowercased = Q(n).Lowercased()
			if cNLowercased = :First or cNLowercased = :FirstOccurrence
				n = 1

			but cNLowercased = :Last or cNLowercased = :LastOccurrence
				n = This.NumberOfOccurrenceCs(pcSubStr, pCaseSensitive)

			else
				n = 0
			ok
		ok

		# Doing the job

		nResult = 0

		nPos = 1
		for i = 1 to n

			nResult = This.QStringObject().indexOf(pcSubStr, nPos - 1, pCaseSensitive) + 1

			if nResult = 0
				exit
			ok

			nPos = nResult + 1
		next

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNth(n, pcSubstr)
		return This.FindNthCS(n, pcSubstr, :CaseSensitive = TRUE)

	  #===============================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING AND RETURNING THE POSITION AS SECTION  #
	#===============================================================================#

	def FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)

		nPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)

		anResult = [ nPos, (nPos + Q(pcSubStr).NumberOfChars() - 1) ]
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSection(n, pcSubStr)
		return This.FindNthAsSectionCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#-------------------------------------------------------------------------------#

	def FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		def FindSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSection(pcSubStr)
		return This.FindFirstAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		def FindSubStringAsSection(pcSubStr)
			return This.FindFirstAsSection(pcSubStr)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING AND RETURNING THE RESULT AS SECTION  #
	#------------------------------------------------------------------------------#

	def FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		anResult = []

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nPos = This.FindLastOccurrenceCS(pcSubStr, pCaseSensitive)

		if nPos != 0
			anResult = [ nPos, (nPos + nLenSubStr - 1) ]
		ok

		return anResult

		#< @FunctionMisspelledForm

		def FindLasteAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSection(pcSubStr)
		return This.FindLasteAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionMisspelledForm

		def FindLasteAsSection(pcSubStr)
			return This.FindLastAsSection(pcSubStr)

		#>

	  #============================================#
	 #  FINDING THE ANTI-SECTIONS OF A SUBSTRING  #
	#============================================#

	def AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		return Q(1:This.NumberOfChars()).
			FindAntiSections( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSections(pcSubStr)
		return This.AntiFindAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

	  #---------------------------------------------------------#
	 #  FINDING THE ONLY ANTI-SECTION (IF ANY) OF A SUBSTRING  #
	#---------------------------------------------------------#

	def AntiFindAsSectionCS(pcSubStr, pCaseSensitive)
		aSections = This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult = []
		if len(aSections) > 0
			aResult = aSections[1]
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def AntiFindAsSection(pcSubStr)
		return This.AntiFindAsSectionCS(pcSubStr, :CaseSensitive = TRUE)

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- D/Extented  #
	#===================================================#

	def FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		# Checking prams

		if isString(n)
			if n = :Default or n = :First or n = :FirstOccurrence
				n = 1

			but n = :Last or n = :LastOccurrence
				n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Default, :Forward, and :Backward.")
		ok

		# Doing the job

		nPos = This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)

		if nPos = 0
			return []

		else
			aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionD(n, pcSubStr, pcDirection)
		return This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- D/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionDCS(1, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionD(pcSubStr, pcDirection)
		return This.FindFirstAsSectionDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- D/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionDCS(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionDCS(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionD(pcSubStr, pcDirection)
		return This.FindLastAsSectionDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #====================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- SD/Extented  #
	#====================================================#

	def FindNthAsSectionSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])

			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, :Backward.")
		ok

		# Doing the job

		aResult = This.FindNthAsSectionSCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionSD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- SD/Extented  #
	#------------------------------------------------------#

	def FindFirstAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionSDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- SD/Extented  #
	#-----------------------------------------------------#

	def FindLastAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthAsSectionSDCS(:LastOccurrence, pnStartingAt, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastAsSectionSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #===================================================#
	 #  FINDING NTH OCCURRENCE AS SECTION -- S/Extented  #
	#===================================================#

	def FindNthAsSectionSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		nPos = This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = [ nPos, nPos + Q(pcSubStr).NumberOfChars() - 1 ]

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthAsSectionS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE AS SECTION -- S/Extented  #
	#-----------------------------------------------------#

	def FindFirstAsSectionSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(1, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstAsSectionS(pcSubStr, pnStartingAt)
		return This.FindFirstAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------#
	 #  FINDING LAST OCCURRENCE AS SECTION -- S/Extented  #
	#----------------------------------------------------#

	def FindLastAsSectionSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthAsSectionSCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastAsSectionS(pcSubStr, pnStartingAt)
		return This.FindLastAsSectionSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #=======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#=======================================================#

	def FindNthCSZ(n, pcSubStr, pCaseSensitive)
		anPos = This.FindNthCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def NthCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCSZ(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthZ(n, pcSubStr)
		return This.FindNthCSZ(n, pcSubStr, :CaseSensitive = TRUE)

		def NthZ(n, pcSubStr)
			return This.FindNthZ(n, pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#

	def FindNthCSZZ(n, pcSubStr, pCaseSensitive)
		aSection = This.FindNthAsSectionCS(n, pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		def NthCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthCSZZ(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthZZ(n, pcSubStr)
		return This.FindNthCSZZ(n, pcSubStr, :CaseSensitive = TRUE)

		def NthZZ(n, pcSubStr)
			return This.FindNthZZ(n, pcSubStr)

	  #=======================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION   #
	#=======================================================================#

	def FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("124578")
		? o1.FindNthS(2, "", :StartingAt = 3)
		#--> 6

		*/

		return This.FindNthSDCS(n, pcSubStr, pnstartingAt, :Forward, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def FindNthS(n, pcsubStr, pnStartingAt)
		return This.FindNthSCS(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def FindFirstSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		# Resolving params

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok
		
		# Doing the job
		
		nResult = This.QStringObject().indexOf(pcSubStr, pnStartingAt - 1, pCaseSensitive) + 1
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstS(pcSubStr, pnStartingAt)
		return This.FindFirstSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION  #
	#-----------------------------------------------------------------------#

	def FindLastSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCS(:LastOccurrence, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastS(pcSubStr, pnStartingAt)
		return This.FindLastSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #==========================================================================#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                           #
	#==========================================================================#

	def FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			else
				n = 0
			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsOneOfThese([ :Forward, :Default, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " + NL +
				 "Allowed values are :Forward, :Backward, and :Default.")

		ok

		if NOT ( isString(pcDirection) and
			 Q(pcDirection).IsEither(:Forward, :Or = :Backward) )

			StzRaise("Incorrect param! pcDirection must be a string. Allowed values are :Forward and :Backward.")

		ok

		if isString(n)

			if NOT ( isNumber(n) or
				 isString(n) and Q(n).IsOneOfThese([
					:First, :FirstOccurrence, :Last, :LastOccurrence ]) )

				StzRaise("Incorrect param! n must be a number or one of these " +
					 "two strings (:First or :Last).")
			ok

			if pcDirection = :Forward or pcDirection = :Default

				if n = :First or n = :FirstOccurrence
					n = 1
	
				but n = :Last or n = :LastOccurrence
	
					n = This.SectionQ(pnStartingAt, :LastChar).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

				ok

			else // Backward

				if n = :First or n = :FirstOccurrence

					n = This.SectionQ(pnStartingAt, :LastChar).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
	
				but n = :Last or n = :LastOccurrence
					n = This.SectionQ(1, pnStartingAt).
						NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)

				ok		

			ok
	
	
		ok

		# doing the job

		nResult = 0

		if pcDirection = :Forward

			nPos  = This.SectionQ(pnStartingAt, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

			if nPos > 0
				nResult = nPos + pnStartingAt - 1
			ok

		else // :Backward

			nResult  = This.FindNthPreviousCS(n, pcSubStr, pnStartingAt, pCaseSensitive)

		ok

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindNthSD(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

	   #----------------------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                             #
	#----------------------------------------------------------------------------#

	def FindFirstSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCS(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #---------------------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	 #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION                            #
	#---------------------------------------------------------------------------#

	def FindLastSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCS(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #===================================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#===================================================================================#

	def FindNthSCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("124578")
		? o1.FindNthSZ(2, "", :StartingAt = 3)
		#--> [ "", 6 ]
		*/

		aResult = [ pcSubStr, This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult

		def NthSCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSCSZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSZ(n, pcsubStr, pnStartingAt)
		return This.FindNthSCSZ(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def NthSZ(n, pcsubStr, pnStartingAt)
			return This.FindNthSZ(n, pcsubStr, pnStartingAt)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FindFirstSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCSZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSZ(pcSubStr, pnStartingAt)
		return This.FindFirstSCSZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def FirstSZ(pcSubStr, pnStartingAt)
			return This.FindFirstSZ(pcSubStr, pnStartingAt)

	  #------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#------------------------------------------------------------------------------------#

	def FindLastSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCSZ(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSZ(pcSubStr, pnStartingAt)
		return This.FindLastSCSZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def LastSZ(pcSubStr, pnStartingAt)
			return This.FindLastSZ(pcSubStr, pnStartingAt)

	  #====================================================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZEXTENDED  #
	#====================================================================================#

	def FindNthSCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
		/* EXAMPLE
		#                     3  6  9
		o1 = new stzString("124578")
		? o1.FindNthSZ(2, "", :StartingAt = 3)
		#--> [ "", 6 ]
		*/
		nPos = This.FindNthSCS(n, pcSubStr, pnStartingAt, pCaseSensitive)
		nLen = StzStringQ(pcSubStr).NumberOfChars()
		aSection = [ nPos, nPos + nLen - 1 ]

		aResult = [ pcSubStr, aSection ]
		return aResult

		def NthSCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindNthSCSZZ(n, pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSZZ(n, pcsubStr, pnStartingAt)
		return This.FindNthSCSZZ(n, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def NthSZZ(n, pcsubStr, pnStartingAt)
			return This.FindNthSZZ(n, pcsubStr, pnStartingAt)

	  #--------------------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#--------------------------------------------------------------------------------------#

	def FindFirstSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCSZZ(1, pcSubStr, pnStartingAt, pCaseSensitive)

		def FirstSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindFirstSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSZZ(pcSubStr, pnStartingAt)
		return This.FindFirstSCSZZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def FirstSZZ(pcSubStr, pnStartingAt)
			return This.FindFirstSZZ(pcSubStr, pnStartingAt)

	  #-------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION -- ZZEXTENDED  #
	#-------------------------------------------------------------------------------------#

	def FindLastSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindNthSCSZZ(:Last, pcSubStr, pnStartingAt, pCaseSensitive)

		def LastSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindLastSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSZZ(pcSubStr, pnStartingAt)
		return This.FindLastSCSZZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		def LastSZZ(pcSubStr, pnStartingAt)
			return This.FindLastSZZ(pcSubStr, pnStartingAt)

	    #===========================================================================#
	   #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #
	#===========================================================================#

	def FindNthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		
		aResult = [ pcSubStr, This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

		def NthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSDZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDCSZ(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

		def NthSDZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSDZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION                                                     #                           #
	#------------------------------------------------------------------------------#

	def FindFirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCSZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDCSZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FirstSDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSDZ(pcSubStr, pnStartingAt, pcDirection)

	    #---------------------------------------------------------------------------#
	   #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND  #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION                                                  #                          #
	#---------------------------------------------------------------------------#

	def FindLastSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return This.FindNthSDCSZ(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDCSZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def LastSDZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSDZ(pcSubStr, pnStartingAt, pcDirection)

	    #===========================================================================#
	   #  FINDING NTH OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                     #
	#===========================================================================#

	def FindNthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n1 = This.FindNthSDCS(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		n2 = n1 + Q(pcSubStr).NumberOfChars() - 1
		aResult = [ pcSubStr, [n1, n2] ]
		return aResult

		def NthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindNthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)
		return This.FindNthSDCSZZ(n, pcSubStr, pnStartingAt, pcDirection, :CS = TRUE)

		def NthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)
			return This.FindNthSDZZ(n, pcSubStr, pnStartingAt, pcDirection)

	    #------------------------------------------------------------------------------#
	   #  FINDING FIRST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND    #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION --RETURNING THE SUBSTRING     #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                        #                           #
	#------------------------------------------------------------------------------#

	def FindFirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return FindNthSDCSZZ(1, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def FirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindFirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindFirstSDCSZZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FirstSDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindFirstSDZZ(pcSubStr, pnStartingAt, pcDirection)

	    #----------------------------------------------------------------------------#
	   #  FINDING LAST OCCURRENCE OF A SUBSTRING STARTING AT A GIVEN POSITION AND   #
	  #  GOING EITHER IN FORWARD OR BACKWARD DIRECTION -- RETURNING THE SUBSTRING  #
 	 #  ALONG WITH ITS POSITION AS A SECTION                                      #                          #
	#----------------------------------------------------------------------------#

	def FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		return FindNthSDCSZZ(:LastOccurrence, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		def LastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindLastSDCSZZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def LastSDZZ(pcSubStr, pnStartingAt, pcDirection)
			return This.FindLastSDZZ(pcSubStr, pnStartingAt, pcDirection)

	  #======================================================#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- EXTENDED   #
	#======================================================#

	def FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthXT(2, "word", :ReturnSection)
		#--> [30, 33]
		
		? o1.NthXT(2, "word", :Between = ["<<", ">>"])
		#--> 43
		
		? o1.NthCSXT(2, "WORD", :Between = ["<<", ">>"], :CS = FALSE)
		#--> 43

		? o1.FindNthXT(2, "word", :StartingAt = 5)

		
		*/

		# Enabling the syntax :BoundedBy = "*"

		if isList(paOption) and
		   Q(paOption).IsBoundedByNamedParam() and
		   isString(paOption[2])
			aTemp = [paOption[2], paOption[2]]
			paOption[2] = aTemp
		ok

		# CASE 1: ? o1.NthXT(2, "word", :ReturnSection)
		if isString(paOption) and paOption = :ReturnSection
			return This.NthSectionCS(n, pcSubStr, pCaseSensitive)

		# CASE 2: ? o1.NthXT(2, "word", :Between = ["<<",">>"])
		but isList(paOption) and
		    ( Q(paOption).IsBetweenNamedParam() or
		      Q(paOption).IsBoundedByNamedParam()
		    )

			cSubStr1 = ""
			cSubStr2 = ""

			paOption = paOption[2]
			if isList(paOption)
				if Q(paOption).IsPairOfStrings()

					cSubStr1 = paOption[1]
					cSubStr2 = paOption[2]

				but Q(paOption).IsPair() and
				    Q(paOption[1]).IsAString() and
				    Q(paOption[2]).IsAndNamedParam() and
				    Q(paOption[2][2]).IsAString()

					cSubStr1 = paOption[1]
					cSubStr2 = paOption[2][2]
				ok

				nResult = This.FindBetweenCS(
						pcSubStr,
						cSubStr1, cSubStr2,
						pCaseSensitive)[n]

				return nResult
			ok

		# CASE 3: ? o1.FindNthXT(2, "word", :StartingAt = 5)
		but isList(paOption) and Q(paOption).IsStartingAtNamedParam()
			nStartPos = paOption[2]
			if NOT isNumber(nStartPos)
				stzRaise("Incorrect param type! :StartingAt must be a number.")
			ok

			nResult = This.SectionQ(nStartPos, :LastChar).FindNthCS(n, pcSubStr, pCaseSensitive)
			return nResult

		else
			stzRaise("Incorrect format!")
		ok

		#< @FunctionAlternativeForms

		def NthCSXT(n, pcSubStr, paOption, pCaseSensitive)
			return This.FindNthCSXT(n, pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WTIHOUT CASESENSITIVITY

	def FindNthXT(n, pcSubStr, paOption)
		return This.FindNthCSXT(n, pcSubStr, paOption, :CaseSensitive = TRUE)

		def NthXT(n, pcSubStr, paOption)
			return This.FindNthXT(n, pcSubStr, paOption)

	  #-------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#-------------------------------------------------------#

	def FirstCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.NthCSXT(1, pcSubStr, paOption, pCaseSensitive)

		#< @FuntionAlternativeForm

		def FindFirstCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.FirstCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FirstXT(pcSubStr, paOption)
		return This.NthCSXT(1, pcSubStr, paOption, :CaseSensitive = TRUE)

		def FindFirstXT(pcSubStr, paOption)
			return This.FirstXT(pcSubStr, paOption)

	  #------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- EXTENDED  #
	#------------------------------------------------------#

	def LastCSXT(pcSubStr, paOption, pCaseSensitive)
		return This.NthXT(:Last, pcSubStr, paOption, pCaseSensitive)

		#< @FuntionAlternativeForm

		def FindLastCSXT(pcSubStr, paOption, pCaseSensitive)
			return This.LastCSXT(pcSubStr, paOption, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def LastXT(pcSubStr, paOption)
		return This.LastCSXT(pcSubStr, paOption, :CaseSensitive = TRUE)

		def FindLastXT(pcSubStr, paOption)
			return This.LastXT(pcSubStr, paOption)

	  #============================================#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING   #
	#============================================#

	// Returns the position of the 1st occurrence of the substring inside the string
	// or returns 0 if nothing is found

	def FindFirstCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FindFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def PositionOfFirstSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		def FirstCS(pcSubStr)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForms

		def FindFirsteCS(pcSubStr, pCaseSensitive)
			return This.FindFirstCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirst(pcSubstr)
		return This.FindFirstCS(pcSubstr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def FindFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FindFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def First(pcSubStr)
			return This.FindFirst(pcSubStr)

		#--

		def PositionOfFirstOccurrence(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstOccurrencePosition(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirst(pcSubStr)
			return This.FindFirst(pcSubStr)

		def PositionOfFirstSubString(pcSubStr)
			return This.FindFirst(pcSubStr)

		def FirstSubStringPosition(pcSubStr)
			return This.FindFirst(pcSubStr)
	
		#>

		#< @FunctionMisspelledForms

		def FindFirste(pcSubStr)
			return This.FindFirst(pcSubStr)

		#>
		

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#---------------------------------------------------------#

	def FindFirstCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindFirstCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		#< @FunctionAlternatives

		def FirstCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstCSZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstZ(pcSubStr)
		return This.FindFirstCSZ(pcSubStr, :CaseSensitive = TRUE)

		def FirstZ(pcSubStr)
			return This.FindFirstZ(pcSubStr)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindFirstAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		#< @FunctionAlternativeForms

		def FirstCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstZZ(pcSubStr)
		return This.FindFirstCSZZ(pcSubStr, :CaseSensitive = TRUE)

		def FirstZZ(pcSubStr)
			return This.FindFirstZZ(pcSubStr)

	  #-------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#-------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		nStart = 1
		if pcDirection = :Backward
			nStart = This.NumberOfChars()
		ok
			
		nResult = FindNthSDCS(n, pcSubStr, nStart, pcDirection, pCaseSensitive)
		return nResult


	#-- WITHOUT CASESENSITIVITY

	def FindNthD(n, pcSubStr, pcDirection)
		return This.FindNthDCS(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(1, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindFirstD(pcSubStr, pcDirection)
		return This.FindFirstDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- D-EXTENDED  #
	#--------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDCS(pcSubStr, pcDirection, pCaseSensitive)
		nResult = This.FindNthDCS(:Last, pcSubStr, pcDirection, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindLastD(pcSubStr, pcDirection)
		return This.FindLastDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #--------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#--------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

		def NthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZ(n, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthDZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZ(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def NthDZ(n, pcSubStr, pcDirection)
			return This.FindNthDZ(n, pcSubStr, pcDirection)

	  #----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZ(1, pcSubStr, pcDirection, pCaseSensitive)

		def FirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZ(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def FirstDZ(pcSubStr, pcDirection)
			return This.FindFirstDZ(pcSubStr, pcDirection)

		#< @FunctionMisspelledForm

		def FindFirtDZ(n, pcSubStr, pcDirection)
			return This.FindFirstDZ(n, pcSubStr, pcDirection)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- DZ-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDCSZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		def LastDCSZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZ(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastDZ(pcSubStr, pcDirection)
		return This.FindLastDCSZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def LastDZ(pcSubStr, pcDirection)
			return This.FindLastDZ(pcSubStr, pcDirection)

	  #---------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#---------------------------------------------------------#
	# TODO: Add other alternatives

	def FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindNthAsSectionDCS(n, pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult

		def NthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindNthDCSZZ(n, pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthDZZ(n, pcSubStr, pcDirection)
		return This.FindNthDCSZZ(n, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def NthDZZ(n, pcSubStr, pcDirection)
			return This.FindNthDZZ(n, pcSubStr, pcDirection)

	  #-----------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#-----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(1, pcSubStr, pcDirection, pCaseSensitive)

		def FirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindFirstDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstDZZ(pcSubStr, pcDirection)
		return This.FindFirstDCSZZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def FirstDZZ(pcSubStr, pcDirection)
			return This.FindFirstDZZ(pcSubStr, pcDirection)

		#< @FunctionMisspelledForm

		def FindFirtDZZ(n, pcSubStr, pcDirection)
			return This.FindFirstDZZ(n, pcSubStr, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- DZZ-EXTENDED  #
	#----------------------------------------------------------#
	# TODO: Add other alternatives

	def FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
		return This.FindNthDCSZZ(:LastOccurrence, pcSubStr, pcDirection, pCaseSensitive)

		def LastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindLastDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastDZZ(pcSubStr, pcDirection)
		return This.FindLastDCSZZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		def LastDZZ(pcSubStr, pcDirection)
			return This.FindLastDZZ(pcSubStr, pcDirection)

	  #=================================================#
	 #      FINDING LAST OCCURRENCE OF A SUBSTRING     #
	#=================================================#

	def FindLastCS(pcSubStr, pCaseSensitive)
		#< TODO: @QtBased | Uses QString2.lastIndexOf()

		/* EXAMPLE

		#                      4     0     6    1
		o1 = new stzString("---***---***---***---")
		? o1.FindLast("***")
		#--> 16

		*/

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT This.ContainsCS(pcSubstr, pCaseSensitive)
			return 0
		ok

		n = This.NumberOfOccurrenceCS(pcSubstr, pCaseSensitive)
		nResult = This.FindNthCS(n, pcsubStr, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm
	
		def FindLastOccurrenceCS(pcSubstr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def FindLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)
			
		def LastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#--

		def PositionOfLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def PositionOfLastSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		def LastSubStringPositionCS(pcSubStr, pCaseSensitive)
			return This.FindLastCS(pcSubStr, pCaseSensitive)

		#>

	def FindLast(pcSubStr)
		return This.FindLastCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def FindLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def Last(pcSubStr)
			return This.FindLast(pcSubStr)

		#--

		def PositionOfLastOccurrence(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastOccurrencePosition(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLast(pcSubStr)
			return This.FindLast(pcSubStr)

		def PositionOfLastSubString(pcSubStr)
			return This.FindLast(pcSubStr)

		def LastSubStringPosition(pcSubStr)
			return This.FindLast(pcSubStr)

		#>

	  #--------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- Z-EXTENDED  #
	#--------------------------------------------------------#

	def FindLastCSZ(pcSubStr, pCaseSensitive)
		anPos = This.FindLastCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, anPos ]

		return aResult

		def LastCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastCSZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastZ(pcSubStr)
		return This.FindLastCSZ(pcSubStr, :CaseSensitive = TRUE)

		def LastZ(pcSubStr)
			return This.FindLastZ(pcSubStr)

	  #---------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING -- ZZ-EXTENDED  #
	#---------------------------------------------------------#

	def FindLastCSZZ(pcSubStr, pCaseSensitive)
		aSection = This.FindLastAsSectionCS(pcSubStr, pCaseSensitive)
		aResult = [ pcSubStr, aSection ]

		return aResult

		def LastCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastCSZZ(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastZZ(pcSubStr)
		return This.FindLastCSZZ(pcSubStr, :CaseSensitive = TRUE)

		def LastZZ(pcSubStr)
			return This.FindLastZZ(pcSubStr)

	  #====================================================================#
	 #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING   #
	#====================================================================#

	def FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("ring __ ring __ ring __ ring")
		? o1.FindOccurrences([ 2, 3 ], "ring") #--> [ 9, 17 ]
		*/

		if NOT ( isList(panOccurr) and Q(panOccurr).IsListOfNumbers() )
			StzRaise("Incorrect param type! panOccurr must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneTheseNamedParams([ :Of, :OfSubString ])
			# NOTE that IsOneTheseNamedParams() is a misspelled form of
			# IsOneOfTheseNamedParams(). I forgot "These" but hopefully
			# Softanza forgave it ;)

			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPositions = This.FindAllCS(pcSubStr, pCaseSensitive)
		nLenOccurr = len(panOccurr)

		anResult = []
		for i = 1 to nLenOccurr
			anResult + anPositions[panOccurr[i]]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindOccurrencesCSXT(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrences(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesXT(panOccurr, pcSubStr)
			return This.FindTheseOccurrences(panOccurr, pcSubStr)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING THE GIVEN OCCURRENCES OF A SUBSTRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#------------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)

		anPos = This.FindTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsCSXT(panOccurr, pcSubStr, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSections(panOccurr, pcSubStr)
		return This.FindTheseOccurrencesAsSectionsCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsXT(panOccurr, pcSubStr)
			return This.FindTheseOccurrencesAsSections(panOccurr, pcSubStr)

		#>

	   #=====================================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING,   #
	 #   STARTING AT A GIVEN POSITION, AND GOING IN A GIVEN DIRECTION      #
	#=====================================================================#

	def FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Resolving params

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfThese([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward
			anPos = This.SectionQ(pnStartingAt, :LastChar).FindCS(pcSubStr, pCaseSensitive)

			nLen = len(anPos)
			nLenSubStr = Q(pcSubStr).NumberOfChars()
	
			
			for i = 1 to nLen
				anResult + (pnStartingAt + anPos[i] - 1)
			next
	
		else // pcDirection = :Bacward
			anResult = This.SectionQ(1, pnStartingAt).
				 	FindCSQ(pcSubStr, pCaseSensitive).Reversed()

		ok

		return anResult


		#< @FunctionAlternativeForms

		def FindOccurrencesSDCSXT(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesSDXT(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #----------------------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING AT A GIVEN   #
	 #   POSITION, GOING IN A GIVEN DIRECTION, AND RETURNING THOSE POSITIONS AS SECTIONS      #
	#----------------------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsSDCSXT(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)
		return This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsSDXT(panOccurr, pcSubStr, pnStartingAt, pcDirection)
			return This.FindTheseOccurrencesAsSectionsSD(panOccurr, pcSubStr, pnStartingAt, pcDirection)

		#>

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING STARTING AT A GIVEN POSITION                 #
	#==========================================================#

	def FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
		aResult = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

		#< @FunctionAlternativeForms

		def FindOccurrencesXTSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		def FindOccurrencesSCSXT(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)
			return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesSCS(panOccurr, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesXTS(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)

		def FindOccurrencesSXT(panOccurr, pcSubStr, pnStartingAt)
			return This.FindTheseOccurrencesS(panOccurr, pcSubStr, pnStartingAt)

		#>

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING STARTING   #
	 #   AT A GIVEN POSITION AND RETURNING THOSE POSITIONS AS SECTIONS             #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsSCS(panOccurr, pcSubStr, pnStartingAt, pCaseSensitive)

		aResult = This.FindTheseOccurrencesAsSectionsSDCS(panOccurr, pcSubStr, pnStartingAt, :Forward, pCaseSensitive)
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsS(panOccurr, pcSubStr, pnStartingAt)
		return This.FindTheseOccurrencesAsSectionsSCS(panOccurr, pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #==========================================================#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN   #
	 #   SUBSTRING GOINING IN A GIVEN DIRECTION                 #
	#==========================================================#

	def FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		if CheckParams() = TRUE
			if NOT ( isList(panOccurr) and Q(panOccurr).IsListOfNumbers() )
				StzRaise("Incorrect param type! pabOccurr must be a list of numbers.")
			ok
	
			if isList(pcSubStr) and Q(pcSubStr).IsOfOrOfSubString()
				pcSubStr = pcSubStr[2]
			ok
	
			if isList(pcDirection) and Q(pcDirection).IsDirectionNamedParam()
				pcDirection = pcDirection[2]
			ok
		ok

		nStartAt = 1

		if pcDirection = :Backward
			nStartAt = This.NumberOfChars()
		ok

		anPos = This.FindTheseOccurrencesSDCS(panOccurr, pcSubStr, nStartAt, pcDirection, pCaseSensitive)

		nLen = len(panOccurr)
		anResult = []
		for i = 1 to nLen
			anResult + anPos[panOccurr[i]]
		next

		return anResult


	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, :CaseSensitive = TRUE)

	   #-----------------------------------------------------------------------------#
	  #   FINDING THE POSITIONS OF SOME OCCURRENCES OF A GIVEN SUBSTRING GOING IN   #
	 #   A GIVEN DIRECTION AND RETURNING THOSE POSITIONS  AS SECTIONS              #
	#-----------------------------------------------------------------------------#

	def FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindTheseOccurrencesDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
		nLen = len(anPos)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		anResult = []
		for i = 1 to nLen
			anResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindOccurrencesAsSectionsDCSXT(panOccurr, pcSubStr, pcDirection, pCaseSensitive)
			return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)
		return This.FindTheseOccurrencesAsSectionsDCS(panOccurr, pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindOccurrencesAsSectionsDXT(panOccurr, pcSubStr, pcDirection)
			return This.FindTheseOccurrencesAsSectionsD(panOccurr, pcSubStr, pcDirection)

		#>

	   #=============================================#
	  #   FINDING NEXT OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION              #
	#=============================================#

	# TODO: Add FindAllNextAsSectionsCS()
	# 	    FindNextAsSectionCS()

	def FindAllNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(pnStartingAt, :LastChar)
		anPos = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		anResult = []

		if len(anPos) > 0
			anResult = StzListOfNumbersQ(anPos).AddToEachQ(pnStartingAt).Content()
		ok

		return anResult
		
	#-- WITHOUT CASESENSITIVITY

	def FindAllNext(pcSubStr, pnStartingAt)
		aResult = This.FindAllNext(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)
		return aResult

	   #-------------------------------------------------#
	  #   FINDING PREVIOUS OCCURRENCES OF A SUBSTRING   #
	 #   STARTING AT A GIVEN POSITION                  #
	#-------------------------------------------------#

	# TODO:
	# 	def FindAllPreviousAsSection()
	# 	def FindAllNextAsSection()

	def FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and StzListQ(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		oSection = This.SectionQ(1, pnStartingAt)
		anPositions = oSection.FindAllCS(pcSubStr, pCaseSensitive)
		
		return anPositions

	#-- WITHOUT CASESENSITIVITY

	def FindAllPrevious(pcSubStr, pnStartingAt)
		aResult = This.FindAllPreviousCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)
		return aResult

	   #=====================================================#
	  #      FINDING NTH NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                   #
	#=====================================================#

	def FindNthNextCS( n, pcSubStr, nStart, pCaseSensitive )

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if NOT BothAreNumbers(n, nStart)
			StzRaise("Incorrect param type! n and nStart must be numbers.")
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")

		ok

		# Early checks (gains performance for large strings)

		if pcSubStr = ""
			return 0
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		nLen = This.NumberOfChars()

		if nStart = nLen
			return 0
		ok

		if (NOT Q(n).IsBetween(1, nLen - nStart)) or
		   (NOT Q(nStart).IsBetween(1, nLen - n))

			return 0
		ok

		if n = nLen and
		   This.LastCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
			return nLen
		ok

		# Full check

		nResult  = This.SectionQ(nStart, :LastChar).
				FindNthCS(n, pcSubStr, pCaseSensitive)

		if nResult != 0
			nResult += nStart - 1
		ok

		return nResult

	def FindNthNext(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------------------#
	 #  FINFING NTH NEXT OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#--------------------------------------------------------------------------------------#

	def FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY
	
	def FindNthNextAsSection(n, pcSubStr, nStart )
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)
	
	   #=========================================================#
	  #      FINDING NTH PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION                       #
	#=========================================================#

	# TODO: Add FindNthPreviousAsSectionsCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

		# Resolving params

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isString(nStart) and Q(nStart).IsEither(:Last, :Or = :LastChar)
			nStart = This.NumberOfChars()
		ok

		if isString(n)
			oNString = Q(n)

			if oNString.IsEither(:First, :Or = :FirstOccurrence)
				n = 1

			but oNString.IsEither(:Last, :Or = :LastOccurrence)
				n = This.SectionQ(1, nStart).NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			ok
		ok

		if NOT BothAreNumbers(n, nStart)
			StzRaise("Incorrect param type! n and nStart must be numbers.")
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")

		ok

		# Early checks (gains performance for large strings)

		if pcSubStr = ""
			return 0
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return 0
		ok

		nLen = This.NumberOfChars()

		if nStart = 1
			return 0
		ok

		if (NOT Q(n).IsBetween(1, nLen - 1)) or
		   (NOT Q(nStart).IsBetween(n + 1, nLen))

			return 0
		ok

		if n = nLen and
		   This.FirstCharQ().IsEqualToCS(pcSubStr, pCaseSensitive)
			return nLen
		ok

		# Full check (only occurrences of pcSubStr are parsed, not every char)

		nPos = nStart + 1
		nFound = 0
		i = 0

		while TRUE
			i++
			if i > nLen
				exit
			ok

			nPos = This.FindPreviousCS(pcSubStr, :StartingAt = nPos, pCaseSensitive)

			if nPos = 0
				exit
			else
				nFound++
				if nFound = n
					return nPos
				ok
			ok
		end

		return 0

	def FindNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------------------------#
	 #  FINFING NTH PREVIOUS OCCURRENCE OF A SUBSTRING AND RETURNING ITS POSITION AS A SECTION  #
	#------------------------------------------------------------------------------------------#

	def FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive )
		nPos = This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )
		nLen = Q(pcSubStr).NumberOfChars()
		aResult = [nPos, nPos + nLen - 1]
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY
	
	def FindNthPreviousAsSection(n, pcSubStr, nStart )
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

	   #-------------------------------------------------#
	  #      FINDING NEXT OCCURRENCE OF A SUBSTRING     #
	 #      STARTING AT A GIVEN POSITION               #
	#-------------------------------------------------#

	# TODO: FindNextW() FindPreviousW()

	def FindNextCS(pcSubStr, nStart, pCaseSensitive)
		#< QTBased | Uses: QString.IndexOf() >

		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if NOT isNumber(nStart)
			StzRaise("Incorrect param type! nStart must be a number.")
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nResult = QStringObject().indexof(pcSubStr, nStart, pCaseSensitive) + 1

		return nResult
		

	#-- WITHOUT CASESENSITIVITY

	def FindNext(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart, :CaseSensitive = TRUE)

	   #-----------------------------------------------------#
	  #      FINDING PREVIOUS OCCURRENCE OF A SUBSTRING     #
	 #      STARTING FROM A GIVEN POSITION N               #
	#-----------------------------------------------------#

	def FindPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		if pcSubStr = "" or
		   NOT This.ContainsCS(pcSubStr, pCaseSensitive)

			return 0
		ok

		nResult = This.SectionQ(1, pnStartingAt - 1).FindLastCS(pcSubStr, pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def FindPrevious(pcSubStr, nStart)
		return This.FindPreviousCS(pcSubStr, nStart, :CaseSensitive = TRUE)
	
	  #-------------------------------------------------#
	 #      FINDING ALL OCCURRENCES OF A SUBSTRING     #
	#=================================================#

	def FindCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.IndexOf() >

		# Resolving the pcSubStr param

		if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
			return This.FindManyCS(pcSubStr, pCaseSensitive)
		ok

		if isList(pcSubStr) and
			( Q(pcSubStr).IsOfNamedParam() or
			  Q(pcSubStr).IsOfSubStringNamedParam() )

			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return []
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nLenString = This.NumberOfChars()
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		if nLenString < nLenSubStr
			return []
		ok

		anResult = []

		bContinue = TRUE
		nPos = 0

		while bContinue
			
			nPos = This.QStringObject().indexOf(pcSubStr, nPos, pCaseSensitive) + 1

			if nPos = 0
				bContinue = FALSE
			else
				anResult + nPos
			ok
		end

		return anResult

		#< @FunctionFluentForm

		def FindCSQ(pcSubStr, pCaseSensitive)
				return This.FindCSQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCS(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCS(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForms : See bottom of file #>

	#-- WITHOUT CASESENSITIVITY

	def Find(pcSubStr)
		return This.FindCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindQ(pcSubStr)
			return This.FindQR(pcSubStr, :stzList)
		
		def FindQR(pcSubStr, pcReturnType)
				return This.FindCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms : See bottom of file #>

	  #---------------------------------------------------------------------------------------#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#=======================================================================================#

	def FindCSZ(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindAllOccurrencesCSZQ(pcSubStr, pCaseSensitive)
				return This.FindAllOccurrencesCSZQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindAllOccurrencesCSZQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCSZ(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindACSZ(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCSZ(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCSZ(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>


	#-- WITHOUT CASESENSITIVITY

	def FindZ(pcSubStr)
		return This.FindCSZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindZQ(pcSubStr)
			return This.FindZQR(pcSubStr, :stzList)
		
		def FindZQR(pcSubStr, pcReturnType)
				return This.FindCSZQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #-------------------------------------------------------------------------------------#
	 # FINDING ALL OCCURRENCES OF A SUBSTRING -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------------#

	def FindCSZZ(pcSubStr, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcSubStr)
			return This.FindManyCSZZ(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindCSZZQ(pcSubStr, pCaseSensitive)
				return This.FindCSZZQR(pcSubStr, pCaseSensitive, :stzList)
			
		def FindCSZZQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindCSZZ(pcSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCSZZ(pcSubStr, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindCSZZ(pcSubStr, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindCSZZ(pcSubStr, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindZZ(pcSubStr)
		return This.FindCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindZZQ(pcSubStr)
			return This.FindZZQR(pcSubStr, :stzList)
		
		def FindZZQR(pcSubStr, pcReturnType)
				return This.FindsCSZZQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #--------------------------------------------------#
	 #  FINDING POSITIONS OF ANTI-PARTS OF A SUBSTRING  #
	#--------------------------------------------------#

	def AntiFindCS(pcSubStr, pCaseSensitive)
		return QR( This.AntiFindAsSectionsCS(pcSubStr, pCaseSensitive), :stzListOfPairs ).FirstItems()

	#-- WITHOUT CASESENSITIVITY

	def AntiFind(pcsubStr)
		return This.AntiFindCS(pcSubStr, :CaseSensitive = TRUE)

	  #===============================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING IN A GIVEN DIRECTION  #
	#===============================================================#

	def FindDCS(pcSubStr, pcDirection, pCaseSensitive)
	
		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		if pcDirection = :Forward or pcDirection = :Default
			return This.FindCS(pcSubStr, pCaseSensitive)

		but pcDirection = :Backward
			return This.FindAllCSQ(pcSubStr, pCaseSensitive).Reversed()

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok

		#< @FunctionFluentForm

		def FindDCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		def FindAllOccurrencesDCS(pcSubStr, pcDirection, pCaseSensitive)
			return This.FindDCS(pcSubStr, pcDirection, pCaseSensitive)

		#>
 
	#-- WITHOUT CASESENSITIVITY

	def FindD(pcSubStr, pcDirection)
		return This.FindDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDQ(pcSubStr, pcDirection)
			return This.FindDQR(pcSubStr, pcDirection, :stzList)
		
		def FindDQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def FindOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		def FindAllOccurrencesD(pcSubStr, pcDirection)
			return This.FindD(pcSubStr, pcDirection)

		#>

	   #-----------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                        #
	#-----------------------------------------------------------------------#

	def FindDCSZ(pcSubStr, pcDirection, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindDCS(pcSubStr, pcDirection, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindDCSZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSZQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSZQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCSZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDZ(pcSubStr, pcDirection)
		return This.FindDCSZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDZQ(pcSubStr, pcDirection)
			return This.FindDZQR(pcSubStr, pcDirection, :stzList)
		
		def FindDZQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSZQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

	   #-----------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, GOING IN A GIVEN DIRECTION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS            #
	#-----------------------------------------------------------------------#

	def FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive)

		# Checking params

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		if pcDirection = :Forward or pcDirection = :Default
			return [ pcSubStr, This.FindAsSectionsCS(pcSubStr, pCaseSensitive) ]

		but pcDirection = :Backward
			return [ pcSubStr, This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed() ]

		else
			StzRaise("Incorrect param value! pcDirection must be :Default, :Forward, or :Backward.")
		ok
		

		#< @FunctionFluentForm

		def FindDCSZZQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindDCSZZQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindDCSZZQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindDCSZZ(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindDZZ(pcSubStr, pcDirection)
		return This.FindDCSZZ(pcSubStr, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindDZZQ(pcSubStr, pcDirection)
			return This.FindDZZQR(pcSubStr, pcDirection, :stzList)
		
		def FindDZZQR(pcSubStr, pcDirection, pcReturnType)
				return This.FindDCSZZQR(pcSubStr, pcDirection, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #=========================================================================#
	 #  FINDING ALL OCCURRENCES OF A SUBSTRING STARTING FROM A GIVEN POSITION  #
	#=========================================================================#

	def FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Doing the job

		anPos = This.SectionQ(pnStartingAt, :LastChar).FindCS(pcSubStr, pCaseSensitive)

		aResult = []

		if Len(anPos) > 0
			aResult = StzListOfNumbersQ(anPos).AddedToEach(pnStartingAt - 1)
		ok

		return aResult


		#< @FunctionFluentForm

		def FindSCSQ(pcSubStr, pcDirection, pCaseSensitive)
				return This.FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, :stzList)
			
		def FindSCSQR(pcSubStr, pcDirection, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSCS(pcSubStr, pcDirection, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindS(pcSubStr, pnStartingAt)
		return This.FindSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSQ(pcSubStr, pnStartingAt)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSQR(pcSubStr, pnStartingAt, pcReturnType)
			return This.FindSQR(pcSubStr, pnStartingAt, :stzList)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS                          #
	#-------------------------------------------------------------------------#

	def FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindSCSZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.FindSCSZQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def FindSCSZQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSCSZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSZ(pcSubStr, pnStartingAt)
		return This.FindSCSZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSZQ(pcSubStr, pnStartingAt)
			return This.FindSZQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.FindSCSZQR(pcSubStr, pnStartingAt, :CaseSensitive = TRUE, pcReturnType)

		#>

	   #-------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING AT A GIVEN POSITION,  #
	 #  AND RETURNING THE SUBSTRING AND ITS POSITIONS AS SECTIONS              #
	#-------------------------------------------------------------------------#

	def FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		aResult = [ pcSubStr, This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive) ]
		return aResult
		

		#< @FunctionFluentForm

		def FindSCSZZQ(pcSubStr, pnStartingAt, pCaseSensitive)
				return This.FindSCSZZQR(pcSubStr, pnStartingAt, pCaseSensitive, :stzList)
			
		def FindSCSZZQR(pcSubStr, pnStartingAt, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPair
				return new stzPair( This.FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			on :stzPairOfNumbers
				return new stzPairOfNumbers( This.FindSCSZZ(pcSubStr, pnStartingAt, pCaseSensitive) )
	
			other
				stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSZZ(pcSubStr, pnStartingAt)
		return This.FindSCSZZ(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindSZZQ(pcSubStr, pnStartingAt)
			return This.FindSZZQR(pcSubStr, pnStartingAt, :stzList)
		
		def FindSZZQR(pcSubStr, pnStartingAt, pcReturnType)
				return This.FindSCSZZQR(pcSubStr, pnStartingAt, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #==========================================================#
	 #  FINDING OCCURRENCES OF A SIUBSTRING IN A GIVEN SECTION  #
	#==========================================================#
	
	def FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastChar ])
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastChar ])
					n2 = This.NumberOfChars()
				but Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		if This.IsEmpty() or pcSubStr = NULL
			return 0
		ok

		anPos = This.SectionQ(n1, n2).FindCS(pcSubStr, pCaseSensitive)
		nLen = len(anPos)

		n1 = Min([ n1, n2 ])

		anResult = []
		for i = 1 to nLen
			anResult + (anPos[i] + (n1 - 1))
		next

		return anResult

		#< @FunctionAlternativeForm

		def FindInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSection(pcSubStr, n1, n2)
		return This.FindInSectionCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)
		
		#< @FunctionAlternativeForm

		def FindInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringInSectionZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#--

		def FindSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSS(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		def FindSubStringSSZ(pcSubStr, n1, n2)
			return This.FindInSection(pcSubStr, n1, n2)

		#>

	   #---------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS              #
	#---------------------------------------------------------#

	def FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		if nLenSubStr = 0
			return []
		ok

		anPos = This.FindInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nLen = len(anPos)

		if nLen = 0
			return []
		ok

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult
	
		#< @FunctionAlternativeForm

		def FindInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionAsSectionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#--

		def FindSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringAsSectionsSSCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		def FindSubStringSSCSZZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionZZ(pcSubStr, n1, n2)
		return This.FindInSectionAsSectionsCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionAsSections(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringInSectionZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#--

		def FindSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringAsSectionsSS(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		def FindSubStringSSZZ(pcSubStr, n1, n2)
			return This.FindInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS  #
	#-------------------------------------------------------#

	def FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		anResult = StzListOfPairsQ( This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive) ).FirstItems()
		return anResult

		#< @FunctionAlternativeForms

		def FindInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSections(pcSubStr, paSections)
		return This.FindInSectionsCS(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindInManySections(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#--

		def FindInSectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		def FindInManySectionsZ(pcSubStr, paSections)
			return This.FindInSections(pcSubStr, paSections)

		#>

	   #--------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION               #
	#--------------------------------------------------------#

	def FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				aResult + [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindInSectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindInManySectionsAsSectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindInSectionsZZ(pcSubStr, paSections)
		return This.FindInSectionsCSZZ(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindInSectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsZZ(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		def FindInManySectionsAsSections(pcSubStr, paSections)
			return This.FindInSectionsZZ(pcSubStr, paSections)

		#>

	  #------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#============================================================#

	def FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		# Resolving the n1 and n2 params

		if CheckParams()
			if isList(n1) and Q(n1).IsOneOfTheseNamedParams([ :From, :FromPosition, :FromPositionOf ])
				n1 = n1[2]
			ok
	
			if isString(n1)
				if Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n1 = 1
				but Q(n1).IsOneOfThese([ :Last, :LastChar ])
					n1 = This.NumberOfChars()
				ok
			ok
	
			if NOT isNumber(n1)
				StzRaise("Incorrect param type! n1 must be a number.")
			ok
	
			if isList(n2) and Q(n2).IsOneOfTheseNamedParams([ :To, :ToPosition, :ToPositionOf ])
				n2 = n2[2]
			ok
	
			if isString(n2)
				if Q(n2).IsOneOfThese([ :Last, :LastChar ])
					n2 = This.NumberOfChars()
				but Q(n1).IsOneOfThese([ :First, :FirstChar ])
					n2 = 1
				ok
			ok
	
			if NOT isNumber(n2)
				StzRaise("Incorrect param type! n2 must be a number.")
			ok
		ok

		# Doing the job

		nPos = This.SectionQ(n1, n2).FindNthCS(n, pcSubStr, pCaseSensitive)
		nResult = n1 + nPos - 1

		return nResult

		#< @FunctionAlternativeForm

		def FindNthInSectionCSZ(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSection(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCS(n, pcSubStr, n1, n2, :CaseSensitive = TRUE)
		
		#< @FunctionAlternativeForm

		def FindNthInSectionZ(n, pcSubStr, n1, n2)
			return This.FindNthInSection(n, pcSubStr, n1, n2)

		#>

	   #------------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                   #
	#------------------------------------------------------------#

	def FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok
		ok

		nPos = This.FindNthInSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
		nLenSubStr = Q(pcSubStr).NumberOfChars()
		anResult = [nPos, nPos + nLenSubStr - 1]
		
		return anResult
	
		#< @FunctionAlternativeForm

		def FindNthInSectionAsSectionCS(n, pcSubStr, n1, n2, pCaseSensitive)
			return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionZZ(n, pcSubStr, n1, n2)
		return This.FindNthInSectionCSZZ(n, pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthInSectionAsSection(n, pcSubStr, n1, n2)
			return This.FindNthInSectionZZ(n, pcSubStr, n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#----------------------------------------------------------#

	def FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)
		nResult = This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)[1]
		return nResult

		#< @FunctionAlternativeForms

		def FindNthInManySectionsCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#--

		def FindNthInSectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCS(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSections(n, pcSubStr, paSections)
		return This.FindNthInSectionsCS(n, pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthInManySections(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#--

		def FindNthInSectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		def FindNthInManySectionsZ(n, pcSubStr, paSections)
			return This.FindNthInSections(n, pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT isString(pcSubStr)
				StzRaise("Incorrect param type! pcSubStr must be a string.")
			ok

			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nLenSubStr = Q(pcSubStr).NumberOfChars()
		nLen = len(paSections)
		aResult = []
		nCounter = 0

		for i = 1 to nLen
			anPos = This.FindInSectionCS(pcSubStr, paSections[i][1], paSections[i][2], pCaseSensitive)
			nLenPos = len(anPos)
			for j = 1 to nLenPos
				nCounter++
				if nCounter = n
					aResult = [ anPos[j], (anPos[j] + nLenSubStr - 1) ]
					exit
				ok
			next
		next

		return aResult

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		def FindNthInManySectionsAsSectionCS(n, pcSubStr, paSections, pCaseSensitive)
			return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthInSectionsZZ(n, pcSubStr, paSections)
		return This.FindNthInSectionsCSZZ(n, pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthInSectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(pcSubStr, paSections)

		def FindNthInManySectionsZZ(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		def FindNthInManySectionsAsSection(n, pcSubStr, paSections)
			return This.FindNthInSectionsZZ(n, pcSubStr, paSections)

		#>

	  #--------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#==============================================================#

	def FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSection(pcSubStr, n1, n2)
		return This.FindFirstInSectionCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)
		
		#< @FunctionAlternativeForm

		def FindFirstInSectionZ(pcSubStr, n1, n2)
			return This.FindFirstInSection(pcSubStr, n1, n2)

		#>

	   #--------------------------------------------------------------#
	  #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                     #
	#--------------------------------------------------------------#

	def FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindFirstInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionZZ(pcSubStr, n1, n2)
		return This.FindFirstInSectionCSZZ(pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstInSectionAsSection(pcSubStr, n1, n2)
			return This.FindFirstInSectionZZ(pcSubStr, n1, n2)

		#>

	  #------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#------------------------------------------------------------#

	def FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindFirstInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindFirstInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSections(pcSubStr, paSections)
		return This.FindFirstInSectionsCS(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstInManySections(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#--

		def FindFirstInSectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		def FindFirstInManySectionsZ(pcSubStr, paSections)
			return This.FindFirstInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING NTH OCCURRENCE OF A SUBSTRING IN MANY SECTIONS   #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindFirstInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindFirstInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstInSectionsZZ(pcSubStr, paSections)
		return This.FindFirstInSectionsCSZZ(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstInSectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsZZ(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		def FindFirstInManySectionsAsSection(pcSubStr, paSections)
			return This.FindFirstInSectionsZZ(pcSubStr, paSections)

		#>

	  #-------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	#=============================================================#

	def FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
		nResult = This.FindNthInSectionCS(1, pcSubStr, n1, n2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastInSectionCSZ(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSection(pcSubStr, n1, n2)
		return This.FindLastInSectionCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)
		
		#< @FunctionAlternativeForm

		def FindLastInSectionZ(pcSubStr, n1, n2)
			return This.FindLastInSection(pcSubStr, n1, n2)

		#>

	   #-------------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN A GIVEN SECTION  #
	 #  AND RETURNING ITS POSITION AS A SECTION                    #
	#-------------------------------------------------------------#

	def FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)
		aResult = This.FindNthInSectionCSZZ(1, pcSubStr, n1, n2, pCaseSensitive)
		return aResult
	
		#< @FunctionAlternativeForm

		def FindLastInSectionAsSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionZZ(pcSubStr, n1, n2)
		return This.FindLastInSectionCSZZ(pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastInSectionAsSection(pcSubStr, n1, n2)
			return This.FindLastInSectionZZ(pcSubStr, n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		nResult = 0
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			nResult = This.FindLastInSectionCS(aSections[1], pCasSensitive)
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindLastInManySectionsCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#--

		def FindLastInSectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCS(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSections(pcSubStr, paSections)
		return This.FindLastInSectionsCS(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastInManySections(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#--

		def FindLastInSectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		def FindLastInManySectionsZ(pcSubStr, paSections)
			return This.FindLastInSections(pcSubStr, paSections)

		#>

	   #-----------------------------------------------------------#
	  #  FINDING LAST OCCURRENCE OF A SUBSTRING IN MANY SECTIONS  #
	 #  AND RETURNING ITS POSITION AS A SECTION                  #
	#-----------------------------------------------------------#

	def FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
		if CheckParams()
			if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
				StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
			ok
		ok

		aResult = []
		if len(aSections) > 0
			aSections = QR(paSections, :stzListOfPairs).Sorted()
			aResult = This.FindLastInSectionCSZZ(aSections[1], pCasSensitive)
		ok

		return aResult

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsCSZZ(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		def FindLastInManySectionsAsSectionCS(pcSubStr, paSections, pCaseSensitive)
			return This.FindLastInSectionsCSZZ(pcSubStr, paSections, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastInSectionsZZ(pcSubStr, paSections)
		return This.FindLastInSectionsCSZZ(pcSubStr, paSections, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastInSectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsZZ(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		def FindLastInManySectionsAsSection(pcSubStr, paSections)
			return This.FindLastInSectionsZZ(pcSubStr, paSections)

		#>

	   #===========================================================================#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                           #
	#===========================================================================#

	def FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		anResult = []

		if pcDirection = :Forward or pcDirection = :Default
			anResult = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		else // pcDirection = :Backward

			if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
				pnStartingAt = pnStartingAt[2]
			ok

			if NOT isNumber(pnStartingAt)
				StzRaise("Incorrect param type! pnStartingAt must be a number.")
			ok

			anResult = This.SectionQ(1, pnStartingAt).
					FindCSQ(pcSubStr, pCaseSensitive).
					Reversed()
		ok

		return anResult

	#-- WITHOUT CASESENSITIVIY

	def FindSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS POSITIONS  #
	#-------------------------------------------------------------------------------#

	def FindSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDCSZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #-------------------------------------------------------------------------------#
	  #  FINDING ALL OCCURRENCES OF A SUBSTRING, STARTING FROM A GIVEN POSITION,      #
	 #  AND GOING IN A GIVEN DIRECTION -- RETURNING THE SUBSTRING AND ITS SECTIONS  #
	#-------------------------------------------------------------------------------#

	def FindSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVIY

	def FindSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindSDCSZZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  FINDING OCCURRENCES OF CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------------------------#

	def FindW(pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCpndition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @char ir @substring but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			anPos = This.FindSubStringsW(pcCondition)
			return anPos

		else

			anPos = This.FindCharsW(pcCondition)
			return anPos
		ok

	def FindAsSectionsW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCpndition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @char ir @substring but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			anPos = This.FindSubStringsAsSectionsW(pcCondition)
			return anPos

		else

			anPos = This.FindCharsAsSectionsW(pcCondition)
			return anPos
		ok

	  #------------------------------------------------------------#
	 #  FINDING OCCURRENCES OF CHARS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------------------#

	# TODO: Add ..Where() alternative to all ..W() functions

	def FindCharsW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		cCode = 'bOk = (' + StzCCodeQ(pcCondition).Transpiled() + ')'
		nLen = This.NumberOfChars()
		anResult = []

		for @i = 1 to nLen
			eval(cCode)
			if bOk
				anResult + @i
			ok
		next

		return anResult

		#< @FunctionFluentForms

		def FindCharsWQ(pcCondition)
			return This.FindCharsWQR(pcCondition, :stzList)

		def FindCharsWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.FindCharsW(pcCondition) )
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindCharsW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def FindCharsWhere(pcCondition)
			return This.FindCharsW(pcCondition)

			def FindCharsWhereQ(pcCondition)
				return This.FindCharsWhereQR(pcCondition, :stzList)
	
			def FindCharsWhereQR(pcCondition, pcReturnType)
				return This.FindCharsWQR(pcCondition, pcReturnType)
		#>

	def FindCharsAsSectionsW(pcCondition)

		anPos = This.FindCharsW(pcCondition)
		nLen = len(anPos)
		
		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], anPos[i] ]
		next

		return aResult

		def FindCharsAsSectionsWhere(pcCondition)
			return This.FindCharsAsSectionsW(pcCondition)

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#------------------------------------------------------------------#

	def FindSubStringsAsSectionsW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		acSubStr = This.SubStringsU() # Or UniqueSubStrings()

		nLen = len(acSubStr)

		cCode = 'if (' + StzCCodeQ(pcCondition).Transpiled() + ') { bOk = TRUE }'

		aResult = []
		
		for i = 1 to nLen
			@substring = acSubStr[i]
			bOk = FALSE
			eval(cCode)

			if bOk
				aSections = This.FindAsSections(acSubStr[i])
				nLenSections = len(aSections)
				for j = 1 to nLenSections
					aResult + aSections[j]
				next
			ok
		next

		aResult = QR(aResult, :stzListOfPairs).Sorted()
		return aResult

		#< @FunctionAlternativeForm

		def FindSubStringAsSectionsW(pcCondition)
			return This.FindSubStringsAsSectionsW(pcCondition)

		#>

	   #------------------------------------------------------------------#
	  #  FINDING OCCURRENCES OF A SUBSTRING VERIFYING A GIVEN CONDITION  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS                       #
	#------------------------------------------------------------------#

	def FindSubStringsW(pcCondition)
		aSections = This.FindSubStringsAsSectionsW(pcCondition)
		anPos = QR(aSections, :stzListOfPairs).FirstItems()
		return anPos

		def FindSubStringW(pcCondition)
			return This.FindSubStringsW(pcCondition)

	  #--------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#--------------------------------------------------------------------------#

	def FindNthW(n, pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCpndition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @char ir @substring but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.FindNthSubStringW(n, pcCondition)

		else
			return This.FindNthCharW(n, pcCondition)
		ok

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------#

	def FindNthCharW(n, pcCondition)
		# TODO: Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextCharW() and use it instead.

		if isString(n)
			if n = :FirstChar or n = :First
				n = 1
			but n = :LastChar or n = :Last
				n = nLen
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anPos = This.FindCharsW(pcCondition)
		nResult = anPos[n]

		return nResult

	  #----------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE OF A CHAR VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------#

	def FindNthSubStringW(n, pcCondition)
		# TODO: Change implementation for better performance
		# There is no need to traverse all the charsW and then
		# returning the nth one.
		#--> Add FindNextSubStringW() and use it instead.

		if isString(n)
			if n = :FirstSubString or n = :First
				n = 1
			but n = :LastSubString or n = :Last
				n = nLen
			ok
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anPos = This.FindSubStringsW(pcCondition)
		nResult = anPos[n]

		return nResult

	  #----------------------------------------------------------------------------#
	 #  FINDING FIRST OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------------------#

	def FindFirstW(pcCondition)
		return This.FindNthW(1, pcCondition)

	def FindFirstCharW(pcCondition)
		return This.FindNthCharW(1, pcCondition)

	def FindFirstSubStringW(pcCondition)
		return This.FindNthSubStringW(1, pcCondition)

	  #---------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE OF A CHAR/SUBSTRING VERIFYING A GIVEN CONDITION  #
	#---------------------------------------------------------------------------#

	def FindLastW(pcCondition)
		return This.FindNthW(:Last, pcCondition)

	def FindLastCharW(pcCondition)
		return This.FindNthCharW(:Last, pcCondition)

	def FindLastSubStringW(pcCondition)
		return This.FindNthSubStringW(:Last, pcCondition)

	  #-----------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- ZZ-EXTENDED  # 
	#-----------------------------------------------------------#

	def FindManyCSZZ(pacSubStr, pCaseSensitive)
		aResult = []
		nLen = len(pacSubStr)

		for i = 1 to nLen
			cSubStr = pacSubStr[i]
			nLenStr = Q(cSubStr).NumberOfChars()

			anPos = This.FindCS(cSubStr, pCaseSensitive)
			nLenPos = len(anPos)
			aSections = []

			for j = 1 to nLenPos
				aSections + [ anPos[j], anPos[j] + nLenStr - 1 ]
			next

			aResult + [ cSubStr, aSections ]

		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindManyZZ(pacSubStr)
		return This.FindManyCSZZ(pacSubStr, :CaseSensitive = TRUE)

	  #----------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- Z-EXTENDED  # 
	#----------------------------------------------------------#

	def FindManyCSZ(pacSubStr, pCaseSensitive)
		aManyZZ = This.FindManyCSZZ(pacSubStr, pCaseSensitive)
		nLen = len(aManyZZ)

		aResult = []

		for i = 1 to nLen
			
			aSections = aManyZZ[i][2]
			nLenSections = len(aSections)

			anPositions = []
			for j = 1 to nLenSections
				anPositions + aSections[j][1]
			next

			aResult + [ aManyZZ[i][1], anPositions ]
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindManyZ(pacSubStr)
		return This.FindManyCSZ(pacSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME  # 
	#--------------------------------------------#

	def FindManyCS(pacSubStr, pCaseSensitive)
		/*
		o1 = new stzString("My name is Mansour. What's your name please?")
		? o1.FindManyCS( [ "name", "your", "please" ], :CS = TRUE )

		#--> [ [ 4, 33 ], [ 28 ], [ 38 ] ]

		*/

		aResult = []

		for str in pacSubStr

			aResult + This.FindAllCS(str, pCaseSensitive)
		next

		aResult = Q(aResult).FlattenQ().Sorted()
		return aResult

		#< @FunctionFluentForm

		def FindManyCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, :stzList)
	
		def FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindManyCS(pacSubStr, pCaseSensitive) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindMany(pacSubStr)
		return This.FindManyCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindManyQ(pacSubStr)
			return This.FindManyQR(pacSubStr, :stzList)
	
		def FindManyQR(pacSubStr, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.FindMany(pacSubStr) )
	
			on :stzListOfNumbers
				return new stzListOfNumbers( This.FindMany(pacSubStr) )
	
			other
				return stzRaise("Unsupported return type!")
			off
		#>

	  #----------------------------------------------------------------------------#
	 #  FINDING MANY SYBSTRINGS IN THE SAME TIME -- RETURN POSITIONS AS SECTIONS  # 
	#----------------------------------------------------------------------------#

	def FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		nLenSubStr = len(pacSubStr)

		aResult = []

		for i = 1 to nLenSubStr
			aSections = This.FindAsSectionsCS(pacSubStr[i], pCaseSensitive)

			nLenSections = len(aSections)
			for j = 1 to nLenSections
				aResult + aSections[j]
			next
		next

		aResult = Q(aResult).ToStzListOfPairs().Sorted()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindManyAsSections(pacSubStr)
		return This.FindManyAsSectionsCS(pacSubStr, :CaseSensitive = TRUE)

	  #=====================================#
	 #  FINDING THINGS, THE EXTENDED FORM  #
	#=====================================#

	def FindCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :InBetween = [ "<<", :And = ">>" ])
			but  oP2.IsInBetweenNamedParam()
				p2 = p2[2]
				return This.FindInBetweenCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindXT("word", :StartingAt = 12)
			but oP2.IsStartingAtNamedParam()
				p2 = p2[2]
				return This.FindSCS(p1, p2,pCaseSensitive)

			# FindXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				return This.FindInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			# FindXT( "*", :InSections = [ [10,14], [19, 23] ] )
			but oP2.IsInSectionsNamedParam()
				return This.FindInSectionsCS(p1, p2[2], pCaseSensitive)

			# FindXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindCSXT( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindCSXT( p1, :InSection = [nPos, :LastChar], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

				ok

			# FindXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

			# FindXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenCS(n, p1[2], p2[1], p2[2], pCaseSensitve)

			# FindXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedByCS(n, p1[2], p2, pCaseSensitve)

			# FindXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindCSXT( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindCSXT( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindCSXT( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					return This.FindCSXT( p1[2], :InSection = [n, :LastChar], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindCSXT( p1[2], :InSection = [p2[2], :LastChar], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindCSXT( p1[2], :InSection = [ p2[2], :LastChar ], pCaseSensitive )

			# FindXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByCS(p2[2], pCaseSensitive)

			# FindXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				nPos = This.SectionQ(p2[1], p2[2]).FindCS(p1, pCaseSensitive)
				nResult = nPos + p2[1]
				return nResult
			ok
		ok

		StzRaise("Unsupported syntax!")

	#-- WITHOUT CASESENSITIVITY

	def FindXT(p1, p2)
		return This.FindCSXT(p1, p2, :CaseSensitive = TRUE)

	  #=================================================#
	 #  FINDING THINGS AS SECTIONS, THE EXTENDED FORM  #
	#=================================================#

	def FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		if ( isString(p1) OR ( isList(p1) and Q(p1).IsSubStringNamedParam() ) ) AND
		   ( isList(p2) )

			oP2 = Q(p2)

			# FindAsSectionsXT( "*", :Between = [ "<<", :And = ">>" ])
			if  oP2.IsBetweenNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BoundedBy = '"' )
			but oP2.IsBoundedByNamedParam()
				return This.FindBoundedByAsSectionsCS(p1, p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InBetween = [ "<<", :And = ">>" ])
			but  oP2.IsInBetweenNamedParam()
				p2 = p2[2]
				return This.FindInBetweenAsSectionsCS(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :BetweenIB = [ "<<", :And = ">>" ])
			but  oP2.IsBetweenIBNamedParam()
				p2 = p2[2]
				return This.FindBetweenAsSectionsCSIB(p1, p2[1], p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [10 , 14 ] )
			but oP2.IsInSectionNamedParam()
				anPos = This.SectionQ(p2[2]).FindCS(p1, pCaseSensitive)
				if len(anPos) = 0
					return []
				ok

				anPos = QR(anPos, :stzListOfNumbers).AddedToEach(p2[2])
				nLen = Q(p1).NumberOfChars()

				aSections = []
				for i = 1 to nLen
					aSections + [ anPos[i], anPos[i] + nLen - 1 ]
				next

				return aSections

			# FindAsSectionsXT( "*", :Before = "--")
			but oP2.IsBeforeNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsCSXT( p1, :InSection = [1, nPos], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :BeforePosition = 10)
			but oP2.IsBeforePositionNamedParam()
				return This.FindAsSectionsCSXT( p1, :InSection = [1, p2[2]], pCaseSensitive )

			# FindAsSectionsXT( "*", :After = "--")
			but oP2.IsAfterNamedParam()
				if isString(p2[2])
					nPos = This.FindFirstAsSectionsCS(p2, pCaseSensitive)
					if nPos > 0
						return This.FindAsSectionsCSXT( p1, :InSection = [nPos, :LastChar], pCaseSensitive )

					else
						return []
					ok

				but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

				ok

			# FindAsSectionsXT( "*", :AfterPosition = 3)
			but oP2.IsAfterPositionNamedParam()
				return This.FindAsSectionsCSXT( p1, :InSection = [ p2[2], :LastChar], pCaseSensitive )

			# FindAsSectionsXT( :3rd = "*", :Between = [ "<<", ">>" ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBetweenAsSectionCS(n, p1[2], p2[1], p2[2], pCaseSensitve)

			# FindAsSectionsXT( :3rd = "*", :BoundedBy = '"' ])
			but isList(p1) and  isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				n = 0+ Q(p1[1]).FirstNumber()
				return This.FindNthBoundedAsSectionByCS(n, p1[2], p2, pCaseSensitve)

			# FindAsSectionsXT( :3rd = "*", :InSection = [5, 24] ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsInSectionNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPair()

				n = 0+ Q(p1[1]).FirstNumber()
				nPos = This.SectionQ(p2[2][1], p2[2][2]).FindNthAsSectionCS(n, p1[2], pCaseSensitive)
				nPos += p2[2][1]

				return nPos

			# FindAsSectionsXT( :3rd = "*", :Before = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforeNamedParam()

				if isString(p2[2])
					n = This.FindFirstCS(p2[2], pCaseSensitive)
					return This.FindAsSectionCSXT( p1[2], :InSection = [1, n], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1[2], :InSection = [1, p2[2] ], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :BeforePosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsBeforePositionNamedParam()

				return This.FindAsSectionsCSXT( p1[2], :InSection = [ 1, p2[2] ], pCaseSensitive )


			# FindAsSectionsXT( :3rd = "*", :After = '!' ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterNamedParam()

				if isString(p2[2])
					n = This.FindLastCS(p2[2], pCaseSensitive)
					return This.FindAsSectionsCSXT( p1[2], :InSection = [n, :LastChar], pCaseSensitive)

			 	but isNumber(p2[2])
					return This.FindAsSectionsCSXT( p1[2], :InSection = [p2[2], :LastChar], pCaseSensitive )

				else
					StzRaise("Incorrect param type! :Before = ... must be fellowed by a string or number.")
				ok

			# FindAsSectionsXT( :3rd = "*", :AfterPosition = 12 ])
			but isList(p1) and isString(p1[2]) and
			    isString(p1[1]) and
			    Q(p1[1]).StartsWithANumber() and
			    Q(p1[1]).EndsWithOneOfThese([ :st, :rd, :th ]) and

			    isList(p2) and Q(p2).IsAfterPositionNamedParam()

				return This.FindAsSectionsCSXT( p1[2], :InSection = [ p2[2], :LastChar ], pCaseSensitive )

			# FindAsSectionsXT( :AnySubString, :Between = ["<<", ">>" )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBetweenNamedParam() and
			    isList(p2[2]) and Q(p2[2]).IsPairOfStrings()

				return This.FindAnyBetweenAsSectionsCS(p2[2][1], p2[2][1], pCaseSensitive)

			# FindAsSectionsXT( :Any, :BoundedBy = '"' )
			but isString(p1) and Q(p1).IsOneOfThese([ :Any, :AnySubString ]) and
			    isList(p2) and Q(p2).IsBoundedByNamedParam()

				return This.FindAnyBoundedByAsSectionsCS(p2[2], pCaseSensitive)

			# FindAsSectionsXT( "*", :InSection = [5, 24] )
			but isList(p2) and Q(p2).IsInSectionNamedParam() and Q(p2).IsPairOfNumbers()

				aSections = This.SectionQ(p2[1], p2[2]).FindAsSectionsCS(p1, pCaseSensitive)
				nLen = len(aSections)
				nLenSubStr = Q(p2).NumberOfChars()

				aResult = []

				for i = 1 to nLen
					aResult + [ (aSections[i][1] + nLenSubStr - 1), (aSections[i][2] + nLenSubStr - 1) ]
				next

				return aResult
			ok
		ok

		StzRaise("Unsupported syntax!")

		#< @FunctionAlternativeForm

		def FindAsSectionCSXT(p1, p2, pCaseSensitive)
		# Without an (s) after Section
		# We need it because some forms
		# return definetly only one section
		# like FindAsSectionXT( :3rd = "*" :InSection = ...)

			return This.FindAsSectionsCSXT(p1, p2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def FindAsSectionsXT(p1, p2)
		return This.FindAsSectionsCSXT(p1, p2, :CaseSensitive = TRUE)

	   #=====================================================#
	  #   CHECKING IF STRING OCCURES BEFORE/AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST              #
	#=====================================================#

	def OccursCS( pcBeforeOrAfter, pIn, pCaseSensitive )
		# TODO: Generalise this fuction so pIn can also be a list
		# TODO: Implement the same function in all other types

		/* EXAMPLE

		o1 = new stzString("ONE")

		? o1.Occurs( :Before = "TWO", :In = "***ONE***TWO***")	#--> TRUE
		? o1.Occurs( :After = "TWO", :In = "***ONE***TWO***")	#--> FALSE

		? o1.Occurs( :Before = "two", :In = [ "***", "ONE", "***", "TWO", "***" ])
		#--> TRUE
		? o1.Occurs( :After = "TWO", :In = [ "***", "ONE", "***", "TWO", "***" ])
		#--> FALSE

		*/
		cBeforeOrAfter = ""

		if isList(pcBeforeOrAfter) and Q(pcBeforeOrAfter).IsBeforeOrAfterNamedParam()
			cTemp = pcBeforeOrAfter[1]

			pcBeforeOrAfter = pcBeforeOrAfter[2]
		ok

		if NOT isString(pcBeforeOrAfter)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok
	

		if isString(pIn)
			oStr = new stzString(pIn)
	
			nThis  = oStr.FindFirstCS( This.Content(), pCaseSensitive )
			nOther = oStr.FindFirstCS( pcBeforeOrAfter, pCaseSensitive )

		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)

				nThis  = oListStr.FindFirstCS( This.Content(), pCaseSensitive )
				nOther = oListStr.FindFirstCS( pcBeforeOrAfter, pCaseSensitive )
			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
	
					nThis  = oList.FindFirst( This.Content() )
					nOther = oList.FindFirst( pcBeforeOrAfter )
						
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nThis  = oList.FindFirst( This.ContentQ().Lowercased() )
					nOther = oList.FindFirst( pcBeforeOrAfter )

				ok
			ok

		ok

		bResult = FALSE

		if cTemp = :After
			bResult = nThis > nOther

		but cTemp = :Before
			bResult = nThis < nOther
		ok

		return bResult

	#-- WITHOUT CASESENSITIVTY

	def Occurs(pcBeforeOrAfter, pIn)
		return This.OccursCS(pcBeforeOrAfter, pIn, :CaseSensitive = TRUE)

	   #-----------------------------------------------#
	  #   CHECKING IF STRING OCCURES BEFORE A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST        #
	#-----------------------------------------------#

	def OccursBeforeCS( pcSubStr, pIn, pCaseSensitive )
		return This.OccursCS( :Before = pcSubStr, pIn, pCaseSensitive)

	#-- WITHOUT CASESENSITIVTY

	def OccursBefore(pcSubStr, pIn)
		return This.OccursBeforeCS( pcSubStr, pIn, :CaseSensitive = TRUE )

	   #----------------------------------------------#
	  #   CHECKING IF STRING OCCURES AFTER A GIVEN   #
	 #   SUBSTRINGING AN OTHER STRING OR LIST       #
	#----------------------------------------------#

	def OccursAfterCS( pcSubStr, pIn, pCaseSensitive )
		return This.OccursCS( :After = pcSubStr, pIn, pCaseSensitive)

	#-- WITHOUT CASESENSITIVTY

	def OccursAfter(pcSubStr, pIn)
		return This.OccursAfterCS( pcSubStr, pIn, :CaseSensitive = TRUE )

	  #-------------------------------------------------------------------#
	 #   CHECKING IF STRING OCCURES N TIMES IN AN OTHER STRING OR LIST   #
	#-------------------------------------------------------------------#

	def OccursNTimesCS( n, pIn, pCaseSensitive )

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok
	
		nOccurrence = 0

		if isString(pIn)
			oStr = new stzString(pIn)
			nOccurrence  = oStr.NumberOfOccurrenceCS( This.Content(), pCaseSensitive )

		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)
				nOccurrence  = oListStr.NumberOfOccurrenceCS( This.Content(), pCaseSensitive )

			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
					nOccurrence  = oList.NumberOfOccurrence( This.Content() )
		
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nThis  = oList.FindFirst( This.ContentQ().Lowercased() )
					nOccurrence  = oList.NumberOfOccurrence( This.Content() )
		
				ok
			ok

		ok

		bResult = FALSE

		if nOccurrence = n
			bResult = TRUE
		ok

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def OccursNTimes( n, pIn )
		return This.OccursNTimesCS( n, pIn, :CaseSensitive = TRUE )

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE NTH TIME,       #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheNthTimeCS(n, pIn, pnAt, pCaseSensitive)
		/* EXAMPLE

		? Q("*").OccursForTheNthTime( 1, :In = "a*b*c*d", :AtPosition = 2 )
		#--> TRUE

		? Q("*").OccursForTheNthTime( 3, :In = "a*b*c*d", :AtPosition = 6 )
		#--> TRUE

		*/

		if isList(pIn) and Q(pIn).IsInNamedParam()
			pIn = pIn[2]
		ok

		if NOT ( isString(pIn) or isList(pIn) )
			StzRaise("Incorrect param type! pcIn must be a string or list.")
		ok

		if isList(pnAt) and Q(pnAt).IsAtOrAtPositionNamedParam()
			pnAt = pnAt[2]
		ok
	
		if NOT isNumber(pnAt)
			StzRaise("Incorrect param type! pAt must be a number.")
		ok

		nNthOccurrence = 0

		if isString(pIn)
			oStr = new stzString(pIn)
			nNthOccurrence = oStr.NthOccurrenceCS( n, This.String(), pCaseSensitive)
	
		but isList(pIn)
			if Q(pIn).IsListOfStrings()
				oListStr = new stzListOfStrings(pIn)
				nNthOccurrence  = oListStr.NthOccurrenceCS( n, This.String(), pCaseSensitive)

			else
				if pCaseSensitive[2] = TRUE
					oList = new stzList(pIn)
					nNthOccurrence  = oList.NthOccurrence( n, This.String() )
		
				else
					oList = new stzList(pIn)
					oList.Lowercase()

					nNthOccurrence  = oList.NthOccurrence( n, This.String() )
		
				ok
			ok

		ok


		if nNthOccurrence = pnAt
			return TRUE

		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheNthTime(n, pIn, pnAt)
		return This.OccursForTheNthTimeCS(n, pIn, pnAt, :CaseSensitive = TRUE)

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE FIRST TIME,     #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheFirstTimeCS(pIn, pnAt, pCaseSensitive)
		return This.OccursForTheNthTimeCS(1, pIn, pnAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheFirstTime(pIn, pnAt)
		return This.OccursForTheFirstTimeCS(pIn, pnAt, :CaseSensitive = TRUE)

	   #----------------------------------------------------#
	  #  CHECKING IF STRING OCCURS FOR THE LAST TIME,      #
	 #  IN AN OTHER STRING OR LIST, AT A GIVEN POSITION   #
	#----------------------------------------------------#

	def OccursForTheLastTimeCS(pIn, pnAt, pCaseSensitive)
		nLast = Q(pIn).FindLastCS(This.Content(), pCaseSensitive)
		return This.OccursForTheNthTimeCS(nLast, pIn, pnAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def OccursForTheLastTime(pIn, pnAt)
		return This.OccursForTheLastTimeCS(pIn, pnAt, :CaseSensitive = TRUE)

	  #===================================================#
	 #   FINDING BY PATTERN (AN ALTERNATIVE TO REGEXP)   # TODO (FUTURE)
	#===================================================#

	// Finds all the occurrences of a given substring in the string
	// depending on the provided format
	def FindPattern(paFormat) // TODO
		/* ... */

		StzRaise("FindPattern() function is not implemented yet!")

	def FindInside(pcTemplate) // TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInside("KLM", 'amc@bmi') #--> 10

		o1.FindInside("KLM", lower("AMC") + '@' + lower("BMI") #-->

		*/

		/* ... */

		StzRaise("FindInside() function is not implemented yet!")

	def FindInsideW(pcTemplate, pcCondition) # TODO
		/*
		o1 = new stzString("opsus amcKLMbmi findus")
		o1.FindInsideW("KLM", :Where = [
			'{ @(3).CharsBefore = "amc" }',
			'{ @(3).CharsAfter = "bmi" }'
		])
		*/

		/* ... */

		StzRaise("FindInsideW() function is not implemented yet!")


	  #===============================================================#
	 #  FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS  #
	#===============================================================#

	def FindAsSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"
		? o1.FindAsSections( "ring" )
		#--> [ [7, 10], [24, 27] ]

		*/

		if isList(pcSubStr)
			return This.FindManyAsSectionsCS(pcSubStr, pCaseSensitive)
		ok

		anFirstPos = This.FindCS(pcSubStr, pCaseSensitive)

		aResult = []

		if len(anFirstPos) > 0
			nLen = StzStringQ(pcSubStr).NumberOfChars()
			anLastPos = StzListOfNumbersQ(anFirstPos).AddToEachQ(nLen-1).Content()
	
			aResult = StzListQ(anFirstPos).AssociatedWith(anLastPos)
		ok

		return aResult

		#< @FunctionFlunentForm

		def FindAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>


	#-- WITHOUT CASESENSITIVITY

	def FindAsSections(pcSubStr)
		return This.FindAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQR(pcSubStr, :stzList)

		def FindAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- D/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		# Checking the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# Doing the job

		aResult = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS SECTIONS -- S/Extented  #
	#---------------------------------------------------------------------------#

	def FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		# Checking pnStartingAt param

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if isString(pnStartingAt)
			if pnStartingAt = :First or pnStartingAt = :FirstChar
				pnStartingAt = 1

			but pnStartingAt = :Last or pnStartingAt = :LastChar
				pnStartingAt = This.NumberOfChars()

			ok
		ok

		if NOT ( isNumber(pnStartingAt) and pnStartingAt != 0)
			StzRaise("Incorrect param type! pnstartingAt must be a non null number.")
		ok

		# Doing the job

		aResult = []

		anPos1 = This.FindSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		if len(anPos1) > 0
			anPos2 = StzListOfNumbersQ(anPos1).AddedToEach(Q(pcSubStr).NumberOfChars() - 1)
			aResult = Association([ :Of = anPos1, :And = anPos2 ])
		ok

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsS(pcSubStr, pnStartingAt)
		return This.FindAsSectionsSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION                                    #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		# Checking the pcSubStr param (because we will use it below)

		if isList(pcSubStr) and Q(pcSubStr).IsSubStringNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# Doing the job

		anPos = This.FindSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		nLen = len(anPos)

		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			aResult + [ anPos[i], (anPos[i] + nLenSubStr - 1) ]
		next

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- Z/EXTENDED                      #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDCSZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAllSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSDZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCSZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS SECTIONS, STARTING FROM A GIVEN POSITION,  #
	 #  AND GOING IN A GIVEN DIRECTION -- ZZ/EXTENDED                     #
	#--------------------------------------------------------------------#

	def FindAsSectionsSDCSZZ(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)
		aResult = [ pcSubStr, This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive) ]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsSectionsSDZZ(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsSectionsSDCSZZ(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #=====================================================================#
	 #   FINDING A SUBSTRING AND RETURNING ITS POSITIONS AS ANTI-SECTIONS  #
	#=====================================================================#

	def FindAsAntiSectionsCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("hello ring what a nice ring!"

		? o1.FindAsSections("ring")
		#--> [ [7, 10], [24, 27] ]

		? o1.FindAsAntiSections("ring")
		#--> [ [1, 6], [11, 23], [28, 28] ]

		*/

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

		#< @FunctionFlunentForm

		def FindAsAntiSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindAsAntiSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.FindAsAntiSectionsCS(pcSubStr, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSections(pcSubStr)
		return This.FindAsAntiSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindAsAntiSectionsQ(pcSubStr)
			return This.FindAsAntiSectionsQR(pcSubStr, :stzList)

		def FindAsAntiSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsAntiSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- D/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsDCS(pcSubStr, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsD(pcSubStr, pcDirection)
		return This.FindAsSectionsDCS(pcSubStr, pcDirection, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------#
	 #  FINDING SUBSTRING AND RETURNING ITS POSITIONS AS ANTISECTIONS -- S/Extented  #
	#-------------------------------------------------------------------------------#

	def FindAsAntiSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aSections = This.FindAsSectionsSCS(pcSubStr, pnStartingAt, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsS(pcSubStr, pnStartingAt)
		return This.FindAsAntiSectionsSCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	   #--------------------------------------------------------------#
	  #  FINDING A SUBSTRING AS ANTISECTIONS, STARTING FROM A GIVEN  #
	 #  POSITION, AND GOING IN A GIVEN DIRECTION                    #
	#--------------------------------------------------------------#

	def FindAsAntiSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAsSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, pCaseSensitive)

		aResult   = StzListQ( 1 : This.NumberOfChars() ).
				FindAntiSectionsQ(aSections).
				Content()

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def FindAsAntiSectionsSD(pcSubStr, pnStartingAt, pcDirection)
		return This.FindAsAntiSectionsSDCS(pcSubStr, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #=========================================================================#
	 #   FINDING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#=========================================================================#

	def FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		/* EXAMPLE 1:

		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindBetweenCS("word", "<<", ">>", :CaseSensitive = FALSE)
		#--> [ 9, 41 ]

		EXAMPLE 2:

		o1 = new stzString("12*A*33*A*")
		? o1.FindBetween("A", "*", "*")
		*/

		# Checking params

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT isString(pcBound1)
			StzRaise("Incorrect param type! pcBound1 must be a string.")
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT isString(pcBound2)
			StzRaise("Incorrect param type! pcBound2 must be a string.")
		ok
	
		nLenBound1 = Q(pcBound1).NumberOfChars()

		# Doing the job

		anPos = This.FindAllCS( pcBound1 + pcSubStr + pcBound2, pCaseSensitive )

		anResult = []

		if len(anPos) > 0
			anResult = QR(anPos, :stzListOfNumbers).AddedToEach(nLenBound1)
		ok

		return anResult

		#< @FunctionFluentForm

		def FindBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

			def FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off
	
		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile #>

		def FindBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

	#-- WITHOUT CASESENSITIVITY

	def FindBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

			def FindBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
				return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms: SeeBottomOfFile #>

		def FindBoundedBy(pcSubStr, pacBounds)
			return This.FindBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  FINDING A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS -- IB() EXTENDED  #
	#---------------------------------------------------------------------#

	def FindBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		anPos = This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if len(anPos) = 0
			return []
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		anResult = QR(anPos, :stzListOfNumbers).AddedToEach( - nLenBound1 )

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsCSIB(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isLisy(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenAsSectionsCSIB(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByAsSectionsCSIB(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSectionsIB(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsIB(cSubStr, pcBound1, pcBound2)
			return This.FindBetweenAsSectionsIB(pcSubStr, pcBound1, pcBound2)

		def FindBoundedByAsSectionsIB(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsCSIB(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByAsSectionsIB(pcSubStr, pacBounds)
			return FindBoundedByAsSectionsIB(pcSubStr, pacBounds)

	  #-----------------------------------------------------------------------------------#
	 #  FINDING (AS SECTIONS) A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS -- IB() EXTENDED  #
	#-----------------------------------------------------------------------------------#

	def FindBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen = len(aSections)
		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		anResult = []

		for i = 1 to nLen
			anResult + [ aSections[i][1] - nLenBound1, aSections[i][2] + nLenBound2 ]
		next

		return anResult

		#< @FunctionAlternativeForms

		def FindSubStringBetweenCSIB(cSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenCSIB(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isLisy(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenCSIB(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenIB(pcSubStr, pcBound1, pcBound2)
		return This.FindBetweenCSIB(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSubStringBetweenIB(cSubStr, pcBound1, pcBound2)
			return This.FindBetweenIB(pcSubStr, pcBound1, pcBound2)

		def FindBoundedByIB(pcSubStr, pacBounds)
			return This.FindBoundedByCSIB(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByIB(pcSubStr, pacBounds)
			return FindBoundedByIB(pcSubStr, pacBounds)

	  #--------------------------------------------------------#
	 #   FINDING NTH SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#--------------------------------------------------------#

	def FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if CheckParams()
			if n = :First or n = :FirstSubString
				n = 1
			but n = :Last or n = :LastSubString
				n = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			ok
		ok

		anPositions = This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = anPositions[n]
		return nResult

		def FindNthSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindNthBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetween(n, pcSubStr, pcBound1, pcBound2)
		return This.FindNthBetweenCS(n, pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindNthSubStringBetween(n, pcSubStr, pcBound1, pcBound2)
			return This.FindNthBetween(n, pcSubStr, pcBound1, pcBound2)

	  #----------------------------------------------------------#
	 #   FINDING FIRST SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#----------------------------------------------------------#

	def FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = This.FindNthBetweenCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		def FindFirstSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindFirstBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindFirstSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindFirstBetween(pcSubStr, pcBound1, pcBound2)

	  #----------------------------------------------------------#
	 #   FINDING LAST SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#----------------------------------------------------------#

	def FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aSection = This.FindBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nResult = This.FindLastInSectionCS(pcSubStr, aSection)
		return nResult

		def FindLastSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindLastBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindLastSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This.FindLastBetween(pcSubStr, pcBound1, pcBound2)

	   #-------------------------------------------------------------#
	  #   FINDING ALL OCCURRENCES OF A SUBSTRING BETWEEN            #
	 #   TWO OTHER SUBSTRINGS AND RETURN THEIR RELATIVE SECTIONS   #
	#-------------------------------------------------------------#

	def FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindSubStringBetweenAsSectionsCS("word", "<<", ">>", :CaseSensitive = FALSE)
		
		(we used here the simple form of the function)

		#--> [ [11, 14], [28, 31], [41, 44] ]
		*/

		if BothAreNumbers(pcBound1, pcBound2)
			return This.FindInSectionCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		ok

		# Getting all the occurrences of pcSubStr in the string

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		#--> [ [ 11, 14 ], [ 32, 35 ], [ 43, 47 ] ]
		nLenSections = len(aSections)

		# Checking the ones that are bounded by pcSubStr1 (<<) and pcSubStr2 (>>)

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		anResult = []
		
		for i = 1 to nLenSections

			aPair = aSections[i]

			cStr = This.Section(aPair[1] - nLen1, aPair[2] + nLen2 )

			if StzStringQ(cStr).IsBoundedByCS([pcBound1, pcBound2], pCaseSensitive)
				anResult + aPair
			ok
		next

		return anResult

		#< @FunctionFluentForm

		def FindBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, :stzList)

			def FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive) )
	
				on :stzListOfStrings
					return new stzListOfStrings( This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive) )
	
				other
					stzRaise("Unsupported return type!")
				off
		#>

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

			def FindSubStringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
				return This.FindBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

			def FindSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)
				return This.FindBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

		def FindBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenAsSectionsCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def FindSubStringBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)

		#--

		def FindBetweenCSZZ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindSubStringBetweenCSZZ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindSubStringBoundedByCSZZ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def FindBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, :stzList)

			def FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)
				return This.FindSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForms

		def FindSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)

			def FindSubStringBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
				return This.FindBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)

			def FindSubStringBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)
				return This.FindBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)

		def FindBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindSubStringBoundedByAsSections(pcSubStr, pacBounds)
			return This.FindBoundedByAsSectionsCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		#--

		def FindBetweenZZ(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)

		def FindSubStringBetweenZZ(pcSubStr, pcBound1, pcbound2)
			return This.FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)

		def FindBoundedByZZ(pcSubStr, pacBounds)
			return This.FindBetweenAsSections(pcSubStr, pcBound1, pcbound2)

		def FindSubStringBoundedByZZ(pcSubStr, pacBounds)
			return This.FindBoundedByAsSections(pcSubStr, pacBounds)

		#>

	  #========================================================================#
	 #  FINDING SUBSTRINGS IN-BETWEEN (INSIDE THE SUBSTRINGS BOUNDED BY) TWO  #
	#  GIVEN SUBSTRINGS (PSOTITIONS ARE RETURNED AS SECTIONS)                #
	#=======================================================================#

	def FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<--hi!-->>...<<-->>...<<hi!>>...")
		? o1.FindInBetweenAsSections( "hi!", "<<", ">>" )
		#--> [ [8, 10], [29, 30] ]

		# TODO
		? @@( o1.FindXT( "*", :InBetween = [ "<<", ">>" ]) ) # or :InSubStringsBetween
		
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		acBetweenZZ = This.BetweenCSZZ(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(acBetweenZZ)
		nLenSubStr = Q(pcSubStr).NumberOfChars()

		aResult = []

		for i = 1 to nLen
			oBetween = Q(acBetweenZZ[i][1])
			
			if oBetween.ContainsCS(pcSubStr, pCaseSensitive)
				anPos = oBetween.FindAllCS(pcSubStr, pCaseSensitive)
				nLenPos = len(anPos)

				for j = 1 to nLenPos
					n1 = anPos[j] + acBetweenZZ[i][2][1] - 1
					n2 = n1 + nLenSubStr - 1
					aResult + [ n1, n2 ]
				next

			ok
		next

		return aResult

		def FindInBetweenCSZZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindInBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindInBetweenZZ(pcSubStr, pcBound1, pcBound2)
			return This.FindInBetweenAsSections(pcSubStr, pcBound1, pcBound2)

	  #-----------------------------------------------------------------------------------------#
	 #  FINDING SUBSTRINGS IN-BETWEEN (INSIDE THE SUBSTRINGS BOUNDED BY) TWO GIVEN SUBSTRINGS  #
	#=========================================================================================#

	def FindInBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		aResult = []
		aSections = This.FindInBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if len(aSections) > 0
			aResult = QR(aSections, :stzListOfPairs).FirstItems()
		ok

		return aResult

		def FindInBetweenCSZ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindInBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindInBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindInBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def FindInBetweenZ(pcSubStr, pcBound1, pcBound2)
			return This.FindInBetween(pcSubStr, pcBound1, pcBound2)

	  #====================================================================#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#====================================================================#

	def NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		anResult = len( This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive) )
		return anResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  NUMBER OF OCCURRENCE OF A SUBSTRING BOUNDED BY TWO OTHER SUBSTRINGS  #
	#-----------------------------------------------------------------------#

	def NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)
		/* EXAMPLE
		
		o1 = new stzString("How many <<many>> are there in (many <<many>>): so <<many>>!")
		? o1.NumberOfOccurrenceXT(
			:OfSubString = "many",
			:BetweenSubStrings = ["<<", :and = ">>"]
			# or :BoundedBy = ["<<", :and = ">>"]
		)
		#--> 

		*/

		if isList(pcSubStr) and ( Q(pcSubStr).IsOfNamedParam() or Q(pcSubStr).IsOfSubStringNamedParam() )
			pcSubStr = pcSubStr[2]
		ok

		if isList(pacBetween) and
			( Q(pacBetween).IsBetweenNamedParam() or
			Q(pacBetween).IsBetweenSubstringsNamedParam() or
			Q(pacBetween).IsBoundedByNamedParam() or
			Q(pacBetween).IsBoundedBySubStringsNamedParam() )

			pacBetween = pacBetween[2]
		ok

		if isList(pacBetween) and
			isList(pacBetween[2]) and
			Q(pacBetween[2]).IsAndNamedParam()

				pacBetween[2] = pacBetween[2][2]
		ok

		if NOT ( Q(pacBetween).IsPairOfStrings() or
			
			( isString(pacBetween[1]) and
			   	isList(pacBetween[2]) and
			  	 Q(pacBetween[2]).IsAndNamedParam() and
			   	 isString(pacBetween[2][2])
			)
		      )

			stzRaise("Incorrect param! pacBetween must be a pair of strings.")
		ok

		nResult = This.NumberOfOccurrenceBetweenCS(pcSubStr, pacBetween[1], pacBetween[2], pCaseSensitive)
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrenceXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#----------------------------------------------------------------------#

	def NumberOfOccurrenceW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pccondition)

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.NumberOfSubStringsW(pcCondition)
		else
			return This.NumberOfCharsW(pcCondition)
		ok

	  #----------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OCCURRENCES OF A GIVEN SUBSTRING  #
	#----------------------------------------------------------------------#

	def ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) = n
			return TRUE
		else
			return FALSE
		ok

		def ContainsExactlyNOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsNOccurrencesCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOccurrences(n, pcSubStr)
		return This.ContainsNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def ContainsExactlyNOccurrences(n, pcSubStr)
			return This.ContainsNOccurrences(n, pcSubStr)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsMoreThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) > n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThenNOccurrences(n, pcSubStr)
		return This.ContainsMoreThenNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS LESS THEN N OCCURRENCES OF A GIVEN SUBSTRING  #
	#--------------------------------------------------------------------------------#

	def ContainsLessThenNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		if This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) < n
			return TRUE
		else
			return FALSE
		ok

	#-- WITHOUT CASESENSITIVITY

	def ContainsLessThenNOccurrences(n, pcSubStr)
		return This.ContainsLessThenNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #======================================================#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#======================================================#

	def FindAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		aResult = StzListOfPairsQ(aSections).FirstItems()

		return aResult

		#< @FunctionAlterativeForms
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetween(pcBound1, pcBound2)
		return This.FindAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlterativeForms
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedBy(pacBounds)
			return This.FindAnyBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#====================================================================#

	def FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		anResult = StzListOfPairsQ(aSections).FirstItems()
		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenS(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByS(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByS(pacBounds, pnStartingAt)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#====================================================================#

	def FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartOrStopOrSection, pCaseSensitive)

		# Checking the pnStartOrStopOrSection param

		nLenStr = This.NumberOfChars()
		startAt = 1
		stopAt = nLenStr

		if isNumber(pnStartOrStopOrSection)
				startAt = pnStartOrStopOrSection

		but isList(pnStartOrStopOrSection)
			oTemp = Q(pnStartOrStopOrSection)

			if oTemp.IsOneOfTheseNamedParams([ :StartingAt, :StartAt, :Start ])
				startAt = pnStartOrStopOrSection[2]

			but oTemp.IsOneOfTheseNamedParams([ :StoppingAt, :StopAt, :Stop ])
				stopAt = pnStartOrStopOrSection[2]

			but oTemp.IsOneOfTheseNamedParams([ :Section, :InSection ])
				startAt = pnStartOrStopOrSection[2][1]
				stopAt  = pnStartOrStopOrSection[2][2]

			ok
		ok

		# Cheching the startAt value (the only one we use in this function)
		#--> we leave the checking of stopAt to the called .Section() function

		if isString(startAt)
			oTemp = Q(startAt)

			if oTemp.IsOneOfThese([ :First, :FirstChar ])
				startAt = 1

			but oTemp.IsOneOfThese([ :Last, :LastChar ])
				startAt = nLenStr
			ok
		ok

		# Doing the job

		aSections = This.SectionQ(startAt, stopAt).
				FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(aSections)

		aResult = []
		for i = 1 to nLen
			aResult + [ aSections[i][1] + startAt - 1, aSections[i][2] + startAt - 1 ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSCS(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCS(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsS(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSCS(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByAsSectionsS(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsS(pacBounds, pnStartingAt)

		#>

	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#=========================================================#

	def BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)		
		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForm

		def AnyBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def AnySubStringsBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringBetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenS(pcBound1, pcBound2, pnStartingAt)
		return This.BetweenSCS(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def SubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def AnySubStringsBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		def SubStringBetweenS(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenS(pcBound1, pcBound2, pnStartingAt)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#======================================================================#

	def FindAnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<***>>...<<***>>...")

		? o1.FindAnyBetween("<<", ">>")
		#--> [ 6, 16 ]

		? o1.FindAnyBetweenSIB("<<", ">>", :StartingAt = 10)
		#--> [ 16 ]

		*/

		nStoppingAt = 0

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
			nStoppingAt  = This.NumberOfChars()
		
		but isList(pnStartingAt) and Q(pnStartingAt).IsPairOfNumbers()
			pnStartingAt = pnStartingAt[1]
			nStoppingAt  = pnStartingAt[2]

		but isList(pnStartingAt) and Q(pnStartingAt).IsInSectionNamedParam()

			if isList(pnStartingAt[2]) and Q(pnStartingAt[2]).IsPairOfNumbers()
				nStoppingAt  = pnStartingAt[2][2]
				pnStartingAt = pnStartingAt[2][1]

			else
				StzRaise("Incorrect param! Correct form is :InSection = [n1, n2].")
			ok

		but isList(pnStartingAt) and Q(pnStartingAt).IsStoppingAtNamedParam()
			nStoppingAt  = pnStartingAt
			pnStartingAt = 1
		ok

		anPos = This.SectionQ(pnStartingAt, nStoppingAt).
			FindAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(anPos)
		for i = 1 to nLen
			anPos[i] += pnStartingAt - 1
		next

		return anPos

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedBySCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSCSIB(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCSIB(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCSIB(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedBySCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedBySCSIB(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySCSIB(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySIB(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedBySIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedBySIB(pacBounds, pnStartingAt)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#======================================================================#

	def FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		nStoppingAt = 0

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
			nStoppingAt  = This.NumberOfChars()
		
		but isList(pnStartingAt) and Q(pnStartingAt).IsPairOfNumbers()
			pnStartingAt = pnStartingAt[1]
			nStoppingAt  = pnStartingAt[2]

		but isList(pnStartingAt) and Q(pnStartingAt).IsInSectionNamedParam()

			if isList(pnStartingAt[2]) and Q(pnStartingAt[2]).IsPairOfNumbers()
				nStoppingAt  = pnStartingAt[2][2]
				pnStartingAt = pnStartingAt[2][1]

			else
				StzRaise("Incorrect param! Correct form is :InSection = [n1, n2].")
			ok

		but isList(pnStartingAt) and Q(pnStartingAt).IsStoppingAtNamedParam()
			nStoppingAt  = pnStartingAt
			pnStartingAt = 1
		ok

		aSections = This.SectionQ(pnStartingAt, nStoppingAt).
				FindAnyBetweenAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)

		nLen = len(aSections)
		for i = 1 to nLen
			aSections[i][1] += pnStartingAt - 1
			aSections[i][2] += pnStartingAt - 1
		next

		return aSections

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSCSIB(pcBounds, pcBounds, pnStartingAt, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSCSIB(pcBounds[1], pcBounds[2], pnStartingAt, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
		return This.FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		def FindAnySubStringsBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		def FindSubStringBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)
			return This.FindAnyBetweenAsSectionsSIB(pcBound1, pcBound2, pnStartingAt)

		#--

		def FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSCSIB(pacBounds, pnStartingAt, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)

		def FindAnySubStringBoundedByAsSectionsSIB(pacBounds, pnStartingAt)
			return This.FindAnyBoundedByAsSectionsSIB(pacBounds, pnStartingAt)

		#>

	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SIB/EXTENDED  #
	#===========================================================#

	def BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringsBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def AnySubStringsBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		def SubStringBetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSIB(pcBound1, pcBound2, pnStartingAt)
		return This.BetweenSCSIB(pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def SubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def AnySubStringsBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		def SubStringBetweenSIB(pcBound1, pcBound2, pnStartingAt)
			return This.BetweenSIB(pcBound1, pcBound2, pnStartingAt)

		#>

  	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#=====================================================================#

	def FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("...<<***>>...<<***>>...")

		? o1.FindAnyBetween("<<", ">>")
		#--> [ 6, 16 ]

		? o1.FindAnyBetweenSD("<<", ">>", :StartingAt = 10)
		#--> [ 16 ]

		*/

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		anResult  = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSDCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedBySD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySD(pacBounds, pnStartingAt, pcDirection)

		#>

	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#=====================================================================#

	def FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartOrStopOrSection, pcDirection, pCaseSensitive)
		
		# Resolving the pcDirection param

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )
			StzRaise("Incorrect param! pcDirection must be a string equal to :Default, :Forward or :Backward.")
		ok

		if pcDirection = :Default
			pcDirection = :Forward
		ok

		# Doing the job

		aResult = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartOrStopOrSection, pCaseSensitive)
		if pcDirection = :Backward
			aResult = Q(aResult).Reversed()
		ok

		return aResult


		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSDCS(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCS(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSD(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDCS(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSD(pacBounds, pnStartingAt, pcDirection)

		#>

	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SD/EXTENDED  #
	#==========================================================#

	def BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def SubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def AnySubStringsBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		def SubStringBetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
		return This.BetweenSDCS(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def SubStringsBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def AnySubStringsBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		def SubStringBetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)
			return This.BetweenSD(pcBound1, pcBound2, pnStartingOrStoppingAt, pcDirection)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#=======================================================================#

	def FindAnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		anResult  = QR(aSections, :stzListOfPairs).FirstItems()

		return anResult

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenSDCSIB(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCSIB(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDCSIB(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedBySDIB(pacBounds, pnStartingAt, pcDirection)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#=======================================================================#

	def FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections    = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		nLenSections = len(aSections)

		if isList(pcBound1) and Q(pcBound1).IsSubStringNamedParam()
			pcBound1 = pcBound1[2]
		ok

		if isList(pcBound2) and Q(pcBound2).IsOneOfTheseNamedParams([ :And, :AndSubString ])
			pcBound2 = pcBound2[2]
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			aSections[i][1] -= nLenBound1
			aSections[i][2] += nLenBound2
		next

		return aSections

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def FindSubStringBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#--

		def FindAnyBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindBetweenAsSectionsSDCSIB(pcBounds, pcBounds, pnStartingAt, pcDirection, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindBetweenSDCSIB(pcBounds[1], pcBounds[2], pnStartingAt, pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param ttpe! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringsBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		def FindAnySubStringBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSubStringsBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindAnySubStringsBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def FindSubStringBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.FindAnyBetweenAsSectionsSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#--

		def FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDCSIB(pacBounds, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		def FindAnySubStringsBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)

		def FindAnySubStringBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)
			return This.FindAnyBoundedByAsSectionsSDIB(pacBounds, pnStartingAt, pcDirection)

		#>

	  #------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- SDIB/EXTENDED  #
	#============================================================#

	def BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def AnyBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def SubStringsBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def AnySubStringsBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		def SubStringBetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
			return This.BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
		return This.BetweenSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def AnyBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def SubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def AnySubStringsBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		def SubStringBetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)
			return This.BetweenSDIB(pcBound1, pcBound2, pnStartingAt, pcDirection)

		#>

	   #------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS           #
	#======================================================#

	def FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		# Checking the pcBound1 and pcBound2 params

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRaise("Incorrect param type! pcBound1 and pcBound2 must both be strings.")
		ok

		# Doing the job

		if This.ContainsNoCS(pcBound1, pCaseSensitive) or
		   This.ContainsNoCS(pcBound2, pCaseSensitive)

			return []
		ok

		aResult = []

		if pcBound1 = pcBound2

			if This.NumberOfOccurrenceCS(pcBound1, pCaseSensitive) = 1
				return []
			ok

			aSections = This.FindAsSectionsCS(pcBound1, pCaseSensitive)

			if This.IsBoundedByCS(pcBound1, pCaseSensitive)

				aResult = This.FindAntiSectionsQ(aSections).Content()

			else

				aResult = This.FindAntiSectionsQ(aSections).
					      FirstAndLastItemsRemoved()
			ok

		else // pcBound1 != pcBound2

			anPos1 = StzListOfNumbersQ( This.FindCS(pcBound1, pCaseSensitive) ).
				 AddedToEach( Q(pcBound1).NumberOfChars() )
	
			anPos2 = StzListOfNumbersQ( This.FindCS(pcBound2, pCaseSensitive) ).
				 AddedToEach( -1 )
	
			nLen1 = len(anPos1)
			nLen2 = len(anPos2)
	
			if nLen1 > 0 and nLen2 > 0
				n = 1
				for j = 1 to nLen2
					if anPos2[j] < anPos1[1]
						n++
					ok
				next
	
				anPos2 = Q(anPos2).Section(n, nLen2)
				aResult = StzListOfListsQ([anPos1, anPos2]).ShrinkQ().Associated()
	
			ok
	
		ok

		return aResult

		#< @FunctionAlternativeForms
		# NOTE: Reorganise! some alternatives are in bottom of file

		def FindAnySubStringBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		def FindAnySubStringsBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
			return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)


		def FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsCS(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsCS(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindAnySubStringBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)

		def FindAnySubStringsBoundedByAsSectionsCS(pacBounds, pCaseSensitive)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSections(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms
		# NOTE: Reorganise! some alternatives are in bottom of file

		def FindAnySubStringBetweenAsSections(pcBound1, pcBound2)
			return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

		def FindAnySubStringsBetweenAsSections(pcBound1, pcBound2)
			return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

		def FindAnyBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSectionsCS(pacBounds, :CaseSensitive = TRUE)

		def FindAnySubStringBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSections(pacBounds)

		def FindAnySubStringsBoundedByAsSections(pacBounds)
			return This.FindAnyBoundedByAsSections(pacBounds)

		#>

	   #--------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS    #
	 #  AND RETURNING THEIR POSITIONS -- D/EXTENDED           #
	#========================================================#
	
	def FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anResult = QR( This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive), :stzListOfPairs).FirstItems()
		return anResult
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenDCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenDCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenD(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByD(pacBounds, pcDirection)
			return This.FindAnyBoundedByDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	   #-----------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS       #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- D/EXTENDED  #
	#===========================================================#

	def FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		# Checking pcDirection param

		if isList(pcDirection) and
		   Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])

			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and Q(pcDirection).IsOneOfThese([ :Forward, :Backward, :Default ]) )
			SzRaise("Incorrect param type! pcDirection must be a string equal to :Forward, :Backward, or :Default.")
			# NOTE this is a misspelled form of StzRaise()
		ok

		# Doing the job

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if pcDirection = :Backward
			aSections = Q(aSections).Reversed()
		ok

		return aSections

		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsDCS(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsDCS(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenAsSectionsD(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsD(pacBounds, pcDirection)
			return This.FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- D/EXTENDED  #
	#=========================================================#
	
	def AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)
		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			aSections = This.FindAnyBoundedByAsSectionsDCS(pacBounds, pcDirection, pCaseSensitive)
			acResult  = This.Sections(aSections)
			return acResult
	
		def BoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenD(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenD(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenD(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByDCS(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		def SubStringsBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByDC(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		def AnySubStringBoundedByD(pacBounds, pcDirection)
			return This.AnyBoundedByD(pacBounds, pcDirection)
	
		#>
	
	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DZ/EXTENDED  #
	#==========================================================#
	
	def AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acBetween   = This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anPositions = This.FindAnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acResult = Association([ acBetween, anPositions ])

		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		
		def SubStringsBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		
		def AnySubStringBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.AnyBetweenDCSZ(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.AnyBetweenDCSZ(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def BoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
		
		def SubStringsBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
		
		def AnySubStringsBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
		
		def AnySubStringBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZ(pacBounds, pcDirection, pCaseSensitive)
		
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCSZ(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDCSZ(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZ(pacBounds, pcDirection)
	
		#>

	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DZZ/EXTENDED  #
	#===========================================================#
	
	def AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acBetween = This.AnyBetweenDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		acResult = Association([ acBetween, aSections ])

		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		
		def SubStringsBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		
		def AnySubStringsBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.AnyBetweenDCSZZ(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.AnyBetweenDCSZZ(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def BoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSZZ(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCSZZ(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDZZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDCSZZ(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDZZ(pacBounds, pcDirection)
	
		#>

	   #--------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS    #
	 #  AND RETURNING THEIR POSITIONS -- DIB/EXTENDED         #
	#========================================================#
	
	def FindAnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		anResult = QR( This.FindAnyBetweenAsSectionsDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive), :stzListOfPairs).FirstItems()
		return anResult
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenDCSIB(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenDCSIB(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenDIB(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByDIB(pacBounds, pcDirection)
			return This.FindAnyBoundedByDCSIB(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	   #-------------------------------------------------------------#
	  #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS         #
	 #  AND RETURNING THEIR POSITIONS AS SECTIONS -- DIB/EXTENDED  #
	#=============================================================#

	def FindAnyBetweenAsSectionsDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)

		if NOT isString(pcBound1)
			StzRaise("Incorrect param type! pcBound1 must be a string.")
		ok

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT isString(pcBound2)
			StzRaise("Incorrect param type! pcBound2 must be a string.")
		ok

		nLenBound1 = Q(pcBound1).NumberOfChars()
		nLenBound2 = Q(pcBound2).NumberOfChars()

		aSections = This.FindAnyBetweenAsSectionsDCS(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		nLenSections = len(aSections)

		for i = 1 to nLenSections
			aSections[i][1] -= nLenBound1
			aSections[i][2] += nLenBound2
		next

		return aSections
	
		#< @FunctionAlternativeForm

		def FindAnyBoundedByAsSectionsDCSIB(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsDCSIB(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsDCSIB(pacBound[1], pacBound[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		#>
	
	#-- WITHOOUT CASESENSITIVITY
	
	def FindAnyBetweenAsSectionsDIB(pcBound1, pcBound2, pcDirection)
		return This.FindAnyBetweenAsSectionsDCSIB(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForm
	
		def FindAnyBoundedByAsSectionsDIB(pacBounds, pcDirection)
			return This.FindAnyBoundedByAsSectionsDCSIB(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		#>
	
	  #-----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIB/EXTENDED  #
	#===========================================================#
	
	def AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		acResult  = This.Sections(aSections)
		return acResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDCSIB(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDCSIB(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok
	
		def BoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIB(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIB(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIB(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDCSIB(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDC(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIB(pacBounds, pcDirection)
			return This.AnyBoundedByDIB(pacBounds, pcDirection)
	
	  #------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIBZ/EXTENDED  #
	#============================================================#
	
	def AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		acBetween  = This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aPositions = This.FindAnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aResult    = Association([ acBetween, aPositions ])

		return aResult
	
		#< @FunctionAlternativeForms
	
		def BetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDCSIBZ(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDCSIBZ(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def BoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
	
		def SubStringsBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZ(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCSIBZ(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIBZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDCSIBZ(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIBZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZ(pacBounds, pcDirection)

	  #-------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- DIBZZ/EXTENDED  #
	#=============================================================#
	
	def AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		acBetween = This.AnyBetweenDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsDCSIB(pcBound1, pcBound2, pcDirection, pCaseSensitive)
		aResult   = Association([ acBetween, aSections ])

		return aResult
	
		#< @FunctionAlternativeForms

		def BetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def SubStringsBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringsBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		def AnySubStringBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
			return This.AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, pCaseSensitive)
	
		#--
	
		def AnyBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
			if isString(pacBounds)
	
				return This.AnyBetweenDCSIBZZ(pacBounds, pacBounds, pcDirection, pCaseSensitive)
	
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
	
				return This.AnyBetweenDCSIBZZ(pacBounds[1], pacBounds[2], pcDirection, pCaseSensitive)
	
			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def BoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)

		def SubStringsBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringsBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
	
		def AnySubStringBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
			return This.AnyBoundedByDCSIBZZ(pacBounds, pcDirection, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
		return This.AnyBetweenDCSIBZZ(pcBound1, pcBound2, pcDirection, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def BetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def SubStringsBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringsBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		def AnySubStringBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
			return This.AnyBetweenDIBZZ(pcBound1, pcBound2, pcDirection)
	
		#--
	
		def AnyBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDCSIBZZ(pacBounds, pcDirection, :CaseSensitive = TRUE)
	
		def BoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def SubStringsBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def AnySubStringsBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)
	
		def AnySubStringBoundedByDIBZZ(pacBounds, pcDirection)
			return This.AnyBoundedByDIBZZ(pacBounds, pcDirection)

	  #---------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#=====================================================================#
	#--> Bounds are also considered in the result

	def FindAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		anPositions = This.FindAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		nNumberOfPositions = len(anPositions)
		nLenBound1 = StzStringQ(pcBound1).NumberOfChars()

		for i = 1 to nNumberOfPositions
			anPositions[i] -= nLenBound1
		next

		return anPositions

		#< @FunctionAlternativeForm

		def FindAnyBoundedByCSIB(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenCSIB(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenCSIB(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenIB(pcBound1, pcBound2)
		return This.FindAnyBetweenCSIB(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindAnyBoundedByIB(pacBounds)
			return This.FindAnyBoundedByCSIB(pacBounds, :CaseSensitive = TRUE)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING ANY SUBSTRING (AS SECTIONS) BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#===================================================================================#
	#--> Bounds are also considered in the result

	def FindAnyBetweenAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		nLen1 = StzStringQ(pcBound1).NumberOfChars()
		nLen2 = StzStringQ(pcBound2).NumberOfChars()

		for i = 1 to len(aSections)
			aSections[i][1] = aSections[i][1] - nLen1
			aSections[i][2] = aSections[i][2] + nLen2
		next

		return aSections

		#< @FunctionAlternatives
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByAsSectionsCSIB(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindAnyBetweenAsSectionsCSIB(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindAnyBetweenAsSectionsCSIB(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnyBetweenAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsCSIB(pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternatives
		# NOTE: see other alternatives in bottom of file

		def FindAnyBoundedByAsSectionsIB(pacBounds)
			return This.FindAnyBoundedByAsSectionsCSIB(pacBounds, :CaseSensitive = TRUE)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#===================================================================================#

	def FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthBetweenAsSection(2, "word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 28, 31 ]
		*/

		# Getting all the occurrences of pcSubStr in the string

		if n = :First or n = :FirstSection
			n = 1

		but n = :Last or n = :LastSection
			n = This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		ok

		anResult = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)[n]

		return anResult

		#< @FunctionAlternativeForm

		def FindNthSubStringBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pcBound1, pcBound2, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pcBound[1], pcBound[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindNthSubStringBoundedByAsSectionCS(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionCS(n, pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSubStringBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)
			return This.FindNthBetweenAsSection(n, pcSubStr, pcBound1, pcbound2)

		def FindNthBoundedByAsSection(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionCS(n, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindNthSubStringBoundedByAsSection(n, pcsubStr, pacBounds)
			return This.FindNthBoundedByAsSection(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------#
	 #   FINDING FIRST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#=======================================================================================#

	def FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindFirstBetweenAsSection("word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 10, 13 ]
		*/

		nResult = This.FindNthBetweenAsSectionCS(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(1, pcSubStr, pacBounds, pCaseSensitive)

		def FindFirstSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSection(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSubStringBetweenAsSection(pcSubStr, pcBound1, pcbound2)
			return This.FindFirstBetweenAsSection(pcSubStr, pcBound1, pcbound2)

		def FindFirstBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSection(1, pcSubStr, pacBounds)

		def FindFirstSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSection(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------#
	 #   FINDING LAST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS   #
	#======================================================================================#

	def FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindLastBetweenAsSections("word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 27, 32 ]
		*/

		nResult = This.FindNthBetweenAsSectionCS(:Last, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCS(:Last, pcSubStr, pacBounds, pCaseSensitive)

		def FindLastSubStringBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastBoundedByAsSectionCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSection(pcSubStr, pcBound1, pcbound2)
		return This.FindLastBetweenAsSectionCS(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSubStringBetweenAsSection(pcSubStr, pcBound1, pcbound2)
			return This.FindLasttBetweenAsSection(pcSubStr, pcBound1, pcbound2)

		def FindLastBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSection(:Last, pcSubStr, pacBounds)

		def FindLastSubStringBoundedByAsSection(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSection(pcSubStr, pacBounds)

		#>

	  #--------------------------------------------------------------------------------------------------#
	 #  FINDING NTH OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#==================================================================================================#
	# Bounds are considered in the result. Otherwise use FindNthAsSections() instead (without ..IB())

	def FindNthBetweenAsSectionCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindNthBetweenAsSectionIB(2, "word", "<<", ">>")

		(we used here the simple form of the function)

		#--> [ 26, 33 ]
		*/

		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRaise("Incorrect param types! pcBound1 and pcBound2 must both be strings.")
		ok

		aSections = This.FindNthBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		nLen = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLen
			aSections[i][1] -= nLen1
			aSections[i][2] += nLen2
		next

		return aSections

		#< @FunctionAlternativeForms

		def FindNthSubStringBetweenAsSectionCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindNthBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pacBounds, pacBounds, pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok

		def FindNthSubStringBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionCSIB(n, pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSubStringBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)
			return This.FindNthBetweenAsSectionIB(n, pcSubStr, pcBound1, pcbound2)

		def FindNthBoundedByAsSectionIB(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionCSIB(n, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindNthSubStringBoundedByAsSectionIB(n, pcSubStr, pacBounds)
			return This.FindNthBoundedByAsSectionIB(n, pcSubStr, pacBounds)

		#>

	  #---------------------------------------------------------------------------------------------------#
	 # FINDING FIRST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#===================================================================================================#

	def FindFirstBetweenAsSectionCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindFirstBetweenAsSectionIB("word", "<<", ">>")

		#--> [ 9, 16 ]
		*/

		nResult = This.FindNthBetweenAsSectionCSIB(1, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSubStringBetweenAsSectionCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindFirstBetweenAsSectionCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindFirstBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCSIB(1, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFirstSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindFirstBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSubStringBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)
			return This.FindFirstBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)

		def FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSectionCSIB(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFirstSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindFirstBoundedByAsSectionIB(pcSubStr, pacBounds)

		#>

	  #------------------------------------------------------------------------------------#
	 #  FINDING LAST OCCURRENCE (AS SECTION) OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#====================================================================================#

	def FindLastBetweenAsSectionsCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("bla bla <<word>> bla bla <<noword>> bla <<word>>")
		? o1.FindLastBetweenAsSectionsIB("word", "<<", ">>")

		#--> [ 41, 48 ]
		*/

		nResult = This.FindNthBetweenAsSectionsCSIB(:Last, pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSubStringBetweenAsSectionCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
			return This.FindLastBetweenAsSectionCSIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

		def FindLastBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindNthBoundedByAsSectionCSIB(:Last, pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindFLastSubStringBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindLastBoundedByAsSectionCSIB(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSectionsIB(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastBetweenAsSectionsIB(pcSubStr, pcBound1, pcbound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSubStringBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)
			return This.FindLastBetweenAsSectionIB(pcSubStr, pcBound1, pcbound2)

		def FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSectionCSIB(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		def FindLastSubStringBoundedByAsSectionIB(pcSubStr, pacBounds)
			return This.FindLastBoundedByAsSectionIB(pcSubStr, pacBounds)

		#>

	  #==============================================================#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION  #
	#==============================================================#
	# Distance is given by the number of chars inbetween
	# the starting and target positions are not included
	# To include them, use ...XT() form of the function

	def DistanceToCS(pcSubStr, pnStartingAt, pCaseSensitive)
		nResult = This.DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive) - 2
		return nResult

	#-- WITHOUT CASESENSITIVITY

	def DistanceTo(pcSubStr, pnStartingAt)
		return This.DistanceToCS(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------------#
	 #  DISTANCE TO A GIVEN SUBSTRING STARTING AT A GIVEN POSITION -- EXTENDED  #
	#--------------------------------------------------------------------------#

	def DistanceToCSXT(pcSubStr, pnStartingAt, pCaseSensitive)

		if isList(pnStartingAt) and Q(pnStartingAt).IsStartingAtNamedParam()
			pnStartingAt = pnStartingAt[2]
		ok

		if NOT isNumber(pnStartingAt)
			StzRaise("Incorrect param type! pnStartingAt must be a number.")
		ok

		n1 = pnStartingAt
		n2 = 0

		if isString(pcSubStr)
			n2 = This.FindNext(pcSubStr, pnStartingAt, pCaseSensitive)
		
		but isNumber(pcSubStr)
			n1 = pcSubStr

		but isList(pcSubStr)
			if Q(pcSubStr).IsNextNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = This.FindNext(pcSubStr, pnStartingAt + 1, pCaseSensitive)

			but Q(pcSubStr).IsNthNextNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :NextNth, :NthNext ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = This.FindNextNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)
			
				ok

			but Q(pcSubStr).IsPreviousNamedParam()
				pcSubStr = pcSubStr[2]

				if NOT isString(pcSubStr)
					StzRaise("Incorrect syntax! You must provide a string after :Next = ...")
				ok

				n2 = n1
				n1 = This.FindPreviousCS(pcSubStr, pnStartingAt - 1, pCaseSensitive)

			but Q(pcSubStr).IsNthPreviousNamedParam()

				if isList(pcSubStr) and
				   Q(pcSubStr).IsPair() and

				   isString(pcSubStr[1]) and
				   Q(pcSubStr[1]).IsOneOfThese([ :PreviousNth, :NthPrevious ]) and

				   isList(pcSubStr[2]) and Q(pcSubStr[2]).IsPair()
				   isNumber(pcSubStr[2][1]) and isString(pcSubStr[2][2])

					n2 = n1
					n1 = This.FindPreviousNthCS(pcSubStr[2][1], pcSubStr[2][2], pnStartingAt, pCaseSensitive)

				ok

			ok

		ok

		nResult = n2 - n1 + 1

		return nResult

	#-- WITHOUT CASESENSITIVITY

	def DistanceToXT(pcSubStr, pnStartingAt)
		return This.DistanceToCSXT(pcSubStr, pnStartingAt, :CaseSensitive = TRUE)

	  #==============================================================#
	 #   SUBSTRING(S) ENCLOSED BETWEEN TWO SUBSTRINGS OR POSITIONS  # 
	#==============================================================#

	def BetweenCS(p1, p2, pCaseSensitive)
		aSections = This.FindAnyBetweenAsSectionsCS(p1, p2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def BetweenCSQ(p1, p2, pCaseSensitive)
			return Q( This.BetweenCS(p1, p2, pCaseSensitive) )

		def BetweenCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassNames() )
				StzRaise("Incorrect param! pcReturnType must be a string containing a Softanza class name.")
			ok

			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				if pcReturnType = :stzString
					return new stzString(Between)
				else
					StzRaise("Can't return a stzString! Because the data is a list.")
				ok

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)

				on :stzListOfStrings
					return new stzListOfStrings(Between)

				other
					StzRaise("Unsupported return type!")
				off

			ok

		#>

		# See alternatives in bottom of file including BoundedBy()

	#-- WITHOUT CASESENSITIVITY

	def Between(p1, p2)
		return This.BetweenCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def BetweenQ(p1, p2)
			return Q( This.Between(p1, p2) )

		def BetweenQR(p1, p2, pcReturnType)
			return This.BetweenCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- Z/EXTENDED  #
	#==================================================================#

	def BetweenCSZ(p1, p2, pCaseSensitive)

		between = This.BetweenCS(p1, p2, pCaseSensitive)

		if isString(between) # In case p1 and p2 are numbers forming a section
			return [ between, This.FindCS(between, pCaseSensitive) ]
		
		else
			return This.SubStringsBetweenCSZ(p1, p2, pCaseSensitive) 
		ok
		
		#< @FunctionAlternativeForm

		def AnyBetweenCSZ(p1, p2, pCaseSensitive)
			return This.BetweenCSZ(p1, p2, pCaseSensitive)
	
		def BoundedByCSZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenCSZ(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsListOfStrings()
				return This.BetweenCSZ(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def AnyBoundedByCSZ(pacBounds, pCaseSensitive)
			return This.BoundedByCSZ(pacBounds, pCaseSensitive)
		
		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenZ(p1, p2)
		return This.BetweenCSZ(p1, p2, :CaseSensitive = TRUE)
 
		#< @FunctionAlternativeForm

		def AnyBetweenZ(p1, p2)
			return This.BetweenZ(p1, p2)

		def BoundedByZ(pacBounds)
			return This.BoundedByCSZ(pacBounds, :CaseSensitive = TRUE)

		def AnyBoundedByZ(pacBounds)
			return This.BoundedByZ(pacBounds)

		#>

	  #----------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- ZZ/EXTENDED  #
	#==========================================================#

	def SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acSubStr  = This.Sections(aSections)

		aResult = Association([ acSubStr, aSections ])

		return aResult

		#< @FunctionFluentForm

		def SubStringsBetweenCSZZQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSZZQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubStringsBetweenCSZZQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				StzRaise( "Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		# TODO: Add ...AndTheirSections() alternatives to all ...ZZ() functions
		# TODO: Add ...AndTheirPositions() alternatives to all ...Z() functions

		def SubStringsBetweenAndTheirSectionsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def subStringsBetweenZZQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenCSZZQ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def SubStringsBetweenZZQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenCSZZQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS -- Z/EXTENDED  #
	#=========================================================#

	def SubStringsBetweenCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		aBetweenZZ = This.SubStringsBetweenCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		nLen = len(aBetweenZZ)

		aResult = []
		for i = 1 to nLen
			aResult + [ aBetweenZZ[i][1], aBetweenZZ[i][2][1] ]
		next

		return aResult

		#< @FunctionAlternativeForm

		def AnySubStringsBetweenCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenZ( pcSubStr1, pcSubStr2 )
		return This.SubStringsBetweenCSZ( pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def SubStringsBetweenAndTheirPositions( pcSubStr1, pcSubStr2 )
			return This.SubStringsBetweenZ( pcSubStr1, pcSubStr2 )

		def AnySubStringsBetweenZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenZ(pcSubStr1, pcSubStr2)
		
		def AnySubStringsBetweenAndTheirPositions(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenZ(pcSubStr1, pcSubStr2)

		#>

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZZ/EXTENDED  #
	#====================================================================#

	def BetweenCSZZ(p1, p2, pCaseSensitive)

		between = This.BetweenCS(p1, p2, pCaseSensitive)

		if isString(between) # Case where p1 and p2 are numbers
			return [ between, This.FindAsSectionsCS(between, pCaseSensitive) ]

		else
			return This.SubStringsBetweenCSZZ(p1, p2, pCaseSensitive)
		ok
		
		#< @FunctionAlternativeForm

		def AnyBetweenCSZZ(p1, p2, pCaseSensitive)
			return This.BetweenCSZZ(p1, p2, pCaseSensitive)
		
		def BoundedByCSZZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenCSZZ(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsListOfStrings()
				return This.BetweenCSZZ(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
			ok

		def AnyBoundedByCSZZ(pacBounds, pCaseSensitive)
			return This.BoundedByCSZZ(pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenZZ(p1, p2)
		return This.BetweenCSZZ(p1, p2, :CaseSensitive = TRUE)
 
		#< @FunctionAlternativeForm

		def AnyBetweenZZ(p1, p2)
			return This.BetweenZZ(p1, p2)
		
		def BoundedByZZ(pacBounds)
			return This.BoundedByCSZZ(pacBounds, :CaseSensitive = TRUE)

		def AnyBoundedByZZ(pacBounds)
			return This.BoundedByZZ(pacBounds)

		#>

	  #------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO OTHER SUBSTRINGS #
	#==========================================#

	def SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive )
		aBetweenZZ = This.SubStringsBetweenCSZZ( pcSubStr1, pcSubStr2, pCaseSensitive )
		nLen = len(aBetweenZZ)

		aResult = []

		for i = 1 to nLen
			aResult + aBetweenZZ[i][1]
		next

		return aResult

		#< @FunctionFluentForm

		def SubStringsBetweenCSQ( pcSubStr1, pcSubStr2, pCaseSensitive )
			return This.SubStringsBetweenCSQR( pcSubStr1, pcSubStr2, pCaseSensitive, :stzList )

		def SubStringsBetweenCSQR( pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType )
			switch pcReturnType
			on :stzList
				return new stzList( This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive ) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, pCaseSensitive ) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		// See them in bottom of file

		#>
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetween( pcSubStr1, pcSubStr2 )
		return This.SubStringsBetweenCS( pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		// See them in bottom of file

		#>

	  #------------------------------------------------------------------------------#
	 #  SUBSTRING(S) ENCLOSED BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/EXTENDED  # 
	#==============================================================================#

	def BetweenCSIB(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			return this.SubStringsBetweenCSIB(p1, p2, pCaseSensitive)

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenCSIBQ(p1, p2, pCaseSensitive)
			Between = This.BetweenCSIB(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenCSIBQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenCSIB(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIB(p1, p2)
		return This.BetweenCSIB(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenIBQ(p1, p2)
			return This.BetweenCSIBQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenIBQR(p1, p2, pcReturnType)
			return This.BetweenCSIBQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

	  #-----------------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/Z() EXTENDED  #
	#=======================================================================#

	def BetweenCSIBZ(p1, p2, pCaseSensitive)
	
		acBetweenIBU = This.BetweenCSIB(p1, p2, pCaseSensitive)
		anPositions  = This.FindAnyBetweenCSIB(p1, p2, pCaseSensitive)

		aResult = Association([ acBetweenIBU,  anPositions ])
		return aResult
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenCSIBZ(p1, p2, pCaseSensitive)
			return This.BetweenCSIBZ(p1, p2, pCaseSensitive)
	
		def BoundedByCSIBZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenCSIBZ(pacBounds, pacBounds, pCaseSensitive)
			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.BetweenIBUCSZ(pacBounds[1], pacBounds[2], pCaseSensitive)
			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		def AnyBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.BoundedByCSIBZ(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def BetweenIBZ(p1, p2)
		return This.BetweenCSIBZ(p1, p2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenIBZ(p1, p2)
			return This.BetweenIBZ(p1, p2)
	
		def BoundedByIBZ(pacBounds)
			return This.BoundedByCSIBZ(pacBounds, :CaseSensitive = TRUE)
	
		def AnyBoundedByIBZ(pacBounds)
			return This.BoundedByIBZ(pacBounds)
	
		#>
		
	  #------------------------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS (OR POSITIONS) -- IB/ZZ() EXTENDED  #
	#========================================================================#

	def BetweenCSIBZZ(p1, p2, pCaseSensitive)
	
		acBetweenIB = This.BetweenCSIB(p1, p2, pCaseSensitive)
		anSections  = This.FindAnyBetweenAsSectionsCSIB(p1, p2, pCaseSensitive)

		aResult = Association([ acBetweenIB, anSections ])
		return aResult
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenCSIBZZ(p1, p2, pCaseSensitive)
			return This.BetweenCSIBZZ(p1, p2, pCaseSensitive)

		def BoundedByCSIBZZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.BetweenCSIBZZ(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.BetweenCSIBZZ(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		def AnyBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.BoundedByCSIBZZ(pacBounds, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def BetweenIBZZ(p1, p2)
		return This.BetweenCSIBZZ(p1, p2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnyBetweenIBZZ(p1, p2)
			return This.BetweenIBZZ(p1, p2)
	
		def BoundedByIBZZ(pacBounds)
			return This.BoundedByCSIBZZ(pacBounds, :CaseSensitive = TRUE)
	
		def AnyBoundedByIBZZ(pacBounds)
			return This.BoundedByIBZZ(pacBounds)
	
		#>

	  #----------------------------------------------------------------------#
	 #   SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS  -- IB/EXTENDED   # 
	#======================================================================#
	# Bounds are considered in the results

	def SubstringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("blabla bla <<word1>> bla bla <<word2>>")
		? o1.SubstringsBetweenIB("<<", ">>")

		#--> [ "<<word1>>", "<<word2>>" ]
		*/

		aSections = This.FindAnyBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.SubstringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SubstringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenCSIB(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenIBQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenCSIBQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #--------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS -- IB/Z() EXTENDED  #
	#========================================================#

	def SubStringsBetweenCSIBZ(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		acBetweenIB = This.SubStringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		anPositions = This.FindBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		aResult = Association([ acBetweenIB, anPositions ])
	
		return aResult
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenCSIBZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenCSIBZ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSIBZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenCSIBZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		
		def SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.SubStringsBetweenCSIBZ(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.SubstringsBetweenCSIBZ(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		def AnySybStringBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)

		def AnySybStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZ(pacBounds, pCaseSensitive)
	
		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenCSIBZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenIBZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
	
		def AnySubStringsBetweenIBZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZ(pcSubStr1, pcSubStr2)

		def SubStringsBoundedByIBZ(pacBounds)
			return This.SubstringsBoundedByCSIBZ(pacBounds, :CaseSensitive = TRUE)
	
		def AnySubStringBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)

		def AnySubStringsBoundedByIBZ(pacBounds)
			return This.SubStringsBoundedByIBZ(pacBounds)
	
		#>
		
	  #---------------------------------------------------------#
	 #  SUBSTRINGS BETWEEN TWO SUBSTRINGS -- IB/ZZ() EXTENDED  #
	#=========================================================#

	def SubStringsBetweenCSIBZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		acBetweenIB = This.SubStringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		anSections  = This.FindBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		aResult = Association( :Of = acBetweenIB, :And = anPositions )
	
		return aResult
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenCSIBZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSIBZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def AnySubStringsBetweenCSIBZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSIBZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
	
		def SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			if isString(pacBounds)
				return This.SubstringsBetweenCSIBZZ(pacBounds, pacBounds, pCaseSensitive)

			but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
				return This.SubStringsBetweenCSIBZZ(pacBounds[1], pacBounds[2], pCaseSensitive)

			else
				StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
			ok
	
		def AnySubstringBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		def AnySubstringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBZZ(pacBounds, pCaseSensitive)

		#>
	
	#-- WITHOUT CASESENSITIVITY
	
	def SubstringsBetweenIBZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenCSIBZZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms
	
		def AnySubStringBetweenIBZZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBZZ(pcSubStr1, pcSubStr2)

		def SubstringsBoundedByIBZZ(pacBounds)
			return This.subStringsBoundedByCSIBZZ(pacBounds, :CaseSensitive = TRUE)
	
		def AnySubStringBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)
	
		def AnySubStringsBoundedByIBZZ(pacBounds)
			return This.SubStringsBoundedByIBZZ(pacBounds)

		#>

	  #----------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRING(S) ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  # 
	#============================================================================#

	def BetweenUCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			acResult = This.BetweenCSQ(p1, p2, pCaseSensitive).DupplicatesRemoved()
			return acResult

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenUCSQ(p1, p2, pCaseSensitive)
			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenUCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

		#< @FunctionAlternativeForm

		def AnyBetweenUCS(p1, p2, pCaseSensitive)
			return This.BetweenUCS(p1, p2, pCaseSensitive)

		def AnyBetweenUCSQ(p1, p2, pCaseSensitive)
			return This.BetweenUCSQ(p1, p2, pCaseSensitive)

		def AnyBetweenUCSQR(p1, p2, pCaseSensitive, pcReturType)
			return This.BetweenUCSQR(p1, p2, pCaseSensitive, pcReturType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenU(p1, p2)
		return This.BetweenUCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenUQ(p1, p2)
			return This.BetweenUCSQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenUQR(p1, p2, pcReturnType)
			return This.BetweenUCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForm

		def AnyBetweenU(p1, p2)
			return This.BetweenU(p1, p2)

		def AnyBetweenUQ(p1, p2)
			return This.BetweenUQ(p1, p2)

		def AnyBetweenUQR(p1, p2)
			return This.BetweenUQR(p1, p2)

		#>

	  #--------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS)  #
	#==========================================================================#

	def SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive).
				DuplicatesRemoved()

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			acResult = This.SubstringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType).
				DuplicatesRemoved()

			return acResult

		#>

		#< @FunctionAlternativeForm

		def AnySubStringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturType)
			return This.SubStringsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQR(pcSubStr1, pcSubStr2, :stzList)

		def SubstringsBetweenUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenICSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>


		#< @FunctionAlternativeForm

		def AnySubStringsBetweenU(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenU(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenUQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenUQR(pcSubStr1, pcSubStr2, pcReturType)
			return This.SubStringsBetweenUCQR(pcSubStr1, pcSubStr2, pcReturType)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  UNIQUE SUBSTRING(S) ENCLOSED BETWEEN TWO OTHER SUBSTRINGS (OR POSITIONS) -- IB/Extended  # 
	#===========================================================================================#

	def BetweenIBUCS(p1, p2, pCaseSensitive)
		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([ :SubString, :Position, :SubStrings, :Positions ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :And, :AndSubString, :AndPosition ])
			p1 = p1[2]
		ok

		if BothAreNumbers(p1, p2)
			return This.Section(p1, p2)

		but BothAreStrings(p1, p2)
			acResult = This.BetweenCSIBQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
			return acResult

		else
			StzRaise("Incorrect param's types! p1 and p2 must be both numbers or both strings.")

		ok

		#< @FunctionFluentForm

		def BetweenIBUCSQ(p1, p2, pCaseSensitive)
			Between = This.BetweenIBUCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				return new stzList(Between)
			ok

		def BetweenIBUCSQR(p1, p2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )

				StzRaise("Incorrect param type! pcReturnType must be a string " +
					 "containing a Softanza class name.")
			ok

			Between = This.BetweenIBUCS(p1, p2, pCaseSensitive)

			if isString(Between)
				return new stzString(Between)

			but isList(Between)
				switch pcReturnType
				on :stzList
					return new stzList(Between)
				on :stzListOfStrings
					return new stzListOfStrings(Between)
				other
					StzRaise("Unsupported return type!")
				off
			ok

		#>

		#< @FunctionAlternativeForm

		def AnyBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnyBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.BetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnyBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.BetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBU(p1, p2)
		return This.BetweenIBUCS(p1, p2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def BetweenIBUQ(p1, p2)
			return This.BetweenIBUCSQ(p1, p2, :CaseSensitive = TRUE)

		def BetweenIBUQR(p1, p2, pcReturnType)
			return This.BetweenIBUCSQR(p1, p2, :CaseSensitive = TRUE, pcReturnType)
		#>

		#< @FunctionAlternativeForm

		def AnyBetweenIBU(pcSubStr1, pcSubStr2)
			return This.BetweenIBU(pcSubStr1, pcSubStr2)

		def AnyBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.BetweenIBUQ(pcSubStr1, pcSubStr2)

		def AnyBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.BetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)

		#>

	  #-----------------------------------------------------------------------------#
	 #   UNIQUE SUBSTRINGS ENCLOSED BETWEEN TWO OTHER SUBSTRINGS  -- IB/EXTENDED   # 
	#=============================================================================#

	def SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		acResult = This.SubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive).
				DuplicatesRemoved()

		return acResult

		#< @FunctionFluentForm

		def SubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			acResult = This.SubstringsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType).
				DuplicatesRemoved()

			return acResult

		#>

		#< @FunctionAlternativeForm

		def AnySubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenIBUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenIBUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubstringsBetweenIBU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenIBUCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, :stzList)

		def SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenIBUSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def AnySubstringsBetweenIBU(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBU(pcSubStr1, pcSubStr2)

		def AnySubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenIBUQ(pcSubStr1, pcSubStr2)

		def AnySubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenIBUQR(pcSubStr1, pcSubStr2, pcReturnType)

		#>

	  #-------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZ/EXTENDED  #
	#===================================================================#
	# TODO: add FluentForms and AlternativeForms

	def BetweenUCSZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenUCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY

	def BetweenUZ(p1, p2, pCaseSensitive)
		return BetweenUCSZ(p1, p2, :CaseSensitive = TRUE)

	  #------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- UZ/EXTENDED  #
	#============================================================#

	def SubStringsBetweenUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenUCSZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- UZZ/EXTENDED  #
	#====================================================================#

	def BetweenUCSZZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenUCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult
	
	#-- WITHOUT CASESENSITIVITY

	def BetweenUZZ(p1, p2)
		return BetweenUCSZZ(p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- UZZ/EXTENDED  #
	#=============================================================#

	def SubStringsBetweenUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenUCSZZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBUZ/EXTENDED  #
	#=====================================================================#

	def BetweenIBUCSZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenCSIBQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBUZ(p1, p2)
		return This.BetweenIBUCSZ(p1, p2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- IBUZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenIBUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenIBUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenIBUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBUCSZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBUZZ/EXTENDED  #
	#======================================================================#

	def BetweenIBUCSZZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenCSIBQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenIBUZZ(p1, p2)
		return This.BetweenIBUCSZZ(p1, p2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- IBUZZ/EXTENDED  #
	#===============================================================#

	def SubStringsBetweenIBUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenIBUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenIBUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIBUCSZZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SUZ/EXTENDED  #
	#====================================================================#

	def BetweenSUCSZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSUZ(p1, p2)
		return This.BetweenSUCSZ(p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SUZ/EXTENDED  #
	#=============================================================#

	def SubStringsBetweenSUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenSUCSZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSUZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenSUCSZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SUZZ/EXTENDED  #
	#=====================================================================#

	def BetweenSUCSZZ(p1, p2, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSUZZ(p1, p2)
		return This.BetweenSUCSZZ(p1, p2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SUZZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenSUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.BetweenSUCSZZ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSUZZ(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenSUCSZZ(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDUZ/EXTENDED  #
	#=====================================================================#

	def BetweenSDUCSZ(p1, p2, pnStartingAt, pCaseSensitive)
		acBetween = This.BetweenSDCSQ(p1, p2, pnStartingAt, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDUZ(p1, p2)
		return This.BetweenSDUCSZ(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDUZ/EXTENDED  #
	#==============================================================#

	def SubStringsBetweenSDUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.BetweenSDUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDUZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.SubStringsBetweenSDUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDUZZ/EXTENDED  #
	#======================================================================#

	def BetweenSDUCSZZ(p1, p2, pnStartingAt, pCaseSensitive)
		acBetween = This.BetweenSCSQ(p1, p2, pnStartingAt, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDUZZ(p1, p2, pnStartingAt)
		return This.BetweenSDUCSZZ(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDUZZ/EXTENDED  #
	#===============================================================#

	def SubStringsBetweenSDUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)
		return This.BetweenSDUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDUZZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.SubStringsBetweenSDUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBUZ/EXTENDED  #
	#=======================================================================#

	def BetweenSDIBUCSZ(p1, p2, pnStartingAt, pcDirection, pCaseSensitive)
		acBetween = This.BetweenSDCSIBQ(p1, p2, pnStartingAt, pcDirection, pcCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			anPos = This.FindSubStringBetweenCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], anPos ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIBUZ(p1, p2)
		return This.BetweenSDIBUCSZ(p1, p2, pnStartingAt, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDIBUZ/EXTENDED  #
	#================================================================#

	def SubStringsBetweenSDIBUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)
		return This.BetweenSDIBUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDIBUZ(pcSubStr1, pcSubStr2, pcDirection, pnStartingAt)
		return This.SubStringsBetweenSDIBUCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBUZZ/EXTENDED  #
	#========================================================================#

	def BetweenSDIBUCSZZ(p1, p2, pnStartingAt, pcDirection, pCaseSensitive)
		acBetween = This.BetweenSDCSQ(p1, p2, pnStartingAt, pcDirection, pCaseSensitive).DuplicatesRemoved()
		nLen = len(acBetween)
	
		aResult = []
		for i = 1 to nLen
			aSections = This.FindBetweenAsSectionsCS(acBetween[i], p1, p2, pCaseSensitive)
			aResult + [ acBetween[i], aSections ]
		next i
	
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def BetweenSDIBUZZ(p1, p2, pnStartingAt, pcDirection)
		return This.BetweenSDIBUCSZZ(p1, p2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO GIVEN SUBSTRINGS -- SDIBUZZ/EXTENDED  #
	#=================================================================#

	def SubStringsBetweenSDIBUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirectionpCaseSensitive)
		return This.BetweenSDIBUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenSDIBUZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.SubStringsBetweenSDIBUCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

#---------------------------

# TODO (future): Add ..CR() to update functions (CR --> Check Return)
#--> Cheks if the function has really made its jobs (returns TRUE or FALSE)

# TODO (future): Add ..XP() to explain what the function does

#---------------------------

	  #-------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SZ/EXTENDED  #
	#===================================================================#

	def BetweenSCSZ(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.BetweenSCSZ(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SZZ/EXTENDED  #
	#====================================================================#

	def BetweenSCSZZ(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSCS(pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSZZ(pcSubStr1, pcSubStr2, pnStartingAt)
		return This.BetweenSCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDZ/EXTENDED  #
	#====================================================================#

	def BetweenSDCSZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSDZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDCSZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDZZ/EXTENDED  #
	#=====================================================================#

	def BetweenSDCSZZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDCS(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSDZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDCSZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBZ/EXTENDED  #
	#======================================================================#

	def BetweenSDCSIBZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
	
		aSections = This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		anPositions = QR(aSections, :stzListOfPairs).FirstItems()
		
		aResult = Association([ acSubStrings, anPositions ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSDIBZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDCSIBZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------#
	 #  SUBSTRING(S) BETWEEN TWO POSITIONS OR SUBSTRINGS -- SDIBZZ/EXTENDED  #
	#=======================================================================#

	def BetweenSDCSIBZZ(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)

		aSections = This.FindAnyBetweenAsSectionsSDCSIB(pcBound1, pcBound2, pnStartingAt, pcDirection, pCaseSensitive)
		acSubStrings = This.Sections(aSections)
		
		aResult = Association([ acSubStrings, aSections ])

		return aResult

	#-- WITHOUT CASESENSITIVE

	def BetweenSDIBZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection)
		return This.BetweenSDCSIBZZ(pcSubStr1, pcSubStr2, pnStartingAt, pcDirection, :CaseSensitive = TRUE)

	  #======================================================================#
	 #  GETIING THE NUMBER OF SUBSTRINGS BOUNDED BY GIVEN OTHER SUBSTRINGS  #
	#======================================================================#

	def NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return len(This.SubStringsBoundedByCS(pacBounds, pCaseSensitive))

	#-- WITHOUT CASESENSITIVITY

	def NumberOfSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

	  #=====================================================#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=====================================================#

	def NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)

		if isString(n) and
		   (n = :First or n = :FirstSubString)

				n = 1
		ok

		aBetween = This.SubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		if isString(n) and
		   n = :Last or n = :LastSubString

			n = len(aBetween)
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		return Q(aBetween).NthItem(n)

	#-- WITHOUT CASESENSITIVITY

	def NthBetween(n, pcBound1, pcBound2)
		return This.NthBetweenCS(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- Z/EXTENDED  #
	#-------------------------------------------------------------------#

	def NthBetweenCSZ(n, pcBound1, pcBound2, pCaseSensitive)
		cSubStr = This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		anPos   = This.FindNthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
 
		aResult = [cSubStr, anPos]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenZ(n, p1, p2)
		return This.NthBetweenCSZ(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- ZZ/EXTENDED  #
	#--------------------------------------------------------------------#

	def NthBetweenCSZZ(n, p1, p2, pCaseSensitive)
		cSubStr  = This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		aSection = This.FindNthBetweenAsSectionCS(n, pcBound1, pcBound2, pCaseSensitive)

		aResult = [cSubStr, aSection]
		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenZZ(n, p1, p2)
		return This.NthBetweenCSZZ(n, pcBound1, pcBound2, :CaseSensitive = TRUE)
	
	  #--------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IB/EXTENDED  #
	#--------------------------------------------------------------------#
	
	def NthBetweenCSIB(n, pcBound1, pcBound2, pCaseSensitive)
		cResult = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIB(n, pcBound1, pcBound2)
		return This.NthBetweenCSIB(pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBZ/EXTENDED  #
	#---------------------------------------------------------------------#

	def NthBetweenCSIBZ(n, pcBound1, pcBound2, pCaseSensitive)

		cSubStr = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2
		nPos    = This.FindNthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive) - Q(pcBound1).NumberOfChars()
		aResult = [ cSubStr, nPos ]

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIBZ(n, pcBound1, pcBound2)
		return This.NthBetweenCSIBZ(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------#
	 #  NTH SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS -- IBZZ/EXTENDED  #
	#---------------------------------------------------------------------#

	def NthBetweenCSIBZZ(n, pcBound1, pcBound2, pCaseSensitive)

		cSubStr  = pcBound1 + This.NthBetweenCS(pcBound1, pcBound2, pCaseSensitive) + pcBound2

		aSection = This.FindNthBetweenAsSectionsCS(n, pcBound1, pcBound2, pCaseSensitive)
		aSection[1] = aSection[1] - Q(pcBound1).NumberOfChars()
		aSection[2] = aSection[2] + Q(pcBound1).NumberOfChars()

		aResult = [ cSubStr, aSection ]

		return aResult

	#-- WITHOUT CASESENSITIVITY

	def NthBetweenIBZZ(n, pcBound1, pcBound2)
		return This.NthBetweenCSIBZZ(n, pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #==============================#
	 #   NTH SUBSTRING -- EXTENDED  # 
	#==============================#

	def NthSubStringXT(n, paOption)

		cOption = ""
		pOption = []

		if isList(paOption) and
		   Q(paOption).IsOneOfTheseNamedParams([ :Between, :BetweenCS, :Where ])

			cOption = paOption[1]
			pOption = paOption[2]
		ok

		if cOption = :Between
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetween(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BetweenCS
			if isList(pOption) and Q(pOption).IsPairOfStrings()
				return This.NthSubStringBetweenCS(n, pOption[1], pOption[2])
			else
				stzRaise("Incorrect param type! pOption must be a pair of strings.")
			ok

		but cOption = :BoundedBy
			
			if isString(pOption) or
			    ( isList(pOption) and Q(pOption).IsPairOfStrings() )

				return This.NthSubStringBoundedBy(n, pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string or a pair of strings.")
			ok

		but cOption = :Where
			if isString(pOption)
				return This.NthSubStringW(pOption)
			else
				stzRaise("Incorrect param type! pOption must be a string.")
			ok
		else
			stzRaise("Can't proceed. Null or unrecognized option.")
		ok

	  #------------------------------------------------#
	 #   NTH SUBSTRING WHERE A CONDITION IS VERIFIED  # 
	#------------------------------------------------#

	# TODO: Reimplement it for better performance

	def NthSubStringW(n, pcCondition)
		return This.SubStringsW()[n]

	  #=======================================================================#
	 #  DEEPFINDING OCCURRENCES OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS  #
	#=======================================================================#

	/* TODO */

	  #--------------------------------------------------------------------#
	 #  DEEPFINDING SECTIONS OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS  #
	#--------------------------------------------------------------------#
	# Bounding chars are NOT counted in the result

	def DeepFindAnyBetweenAsSectionsCS(pcChar1, pcChar2, pCaseSensitive)
		aSections = This.DeepFindAnyBetweenAsSectionsCSIB(pcChar1, pcChar2, pCaseSensitive)
		nLen = len(aSections)

		aResult = []
		for i = 1 to nLen
			aSections[i][1] = aSections[i][1] + 1
			aSections[i][2] = aSections[i][2] - 1
			
		next

		return aSections

	  #--------------------------------------------------------------------------------#
	 #  DEEPFINDING SECTIONS OF ANY SUBSTRING ENCLOSED BETWEEN TWO CHARS -- EXTENDED  #
	#--------------------------------------------------------------------------------#
	# Bounding chars are counted in the result

	def DeepFindAnyBetweenAsSectionsCSIB(pcChar1, pcChar2, pCaseSensitive)

		# Checking the params

		if isList(pcChar1) and Q(pcChar1).IsSubStringNamedParam()
			pcChar1 = pcChar1[2]
		ok

 		if isList(pcChar2) and
			( Q(pcChar2).IsAndNamedParam() or
			  Q(pcChar2).IsAndSubStringNamedParam() )

			pcChar2 = pcChar2[2]
		ok

		if NOT BothAreChars(pcChar1, pcChar2)
			stzRaise("Incorrect params types! pcChar1 and pcChar2 must be chars.")
		ok


		# Doing the job (sometimes we undertake a bit of magic ;)

		nNumberOfSections = This.NumberOfOccurrenceCS(pcChar1, pCaseSensitive)

		aList1 = This.FindAllCS(pcChar1, pCaseSensitive)
		aList2 = This.FindAllCS(pcChar2, pCaseSensitive)
		
		aList = Q(aList1).MergeWithQ(aList2).Sorted()
		nLenList = len(aList)
		aSections = []
		
		while TRUE
		
			for i = 2 to nLenList
			
				if ring_find(aList1, aList[i-1]) > 0 and
				   ring_find(aList2, aList[i]) > 0
			
					aSections + [ aList[i-1], aList[i] ]
					if len(aSections) = nNumberOfSections
						exit 2
					ok
		
				ok
			next
			
			aList = Q(aList).ManyRemoved(Q(aSections).Merged())
			nLenList = len(aList)
		
		end

		return aSections

		#< @FunctionFluentForm

		def DeepFindanyBetweenAsSectionsCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.DeepFindAnyBetweenAsSectionsCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, :stzList)

		def DeepFindAnyBetweenAsSectionsCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			# TODO: Generalize this check

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepFindAnyBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfLists
				return new stzListOfLists( This.DeepFindAnyBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfPairs
				return new stzListOfPairs( This.DeepFindAnyBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

	#-- WITHOUT CASESENSiTiVITY

	def DeepFindAnyBetweenAsSectionsIB(pcSubStr1, pcSubStr2)
		return This.DeepFindAnyBetweenAsSectionsCSIB(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepFindAnyBetweenAsSectionsIBQ(pcSubStr1, pcSubStr2)
			return This.DeepFindAnyBetweenAsSectionsIBQR(pcSubStr1, pcSubStr2, :stzList)

		def DeepFindAnyBetweenAsSectionsIBQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.DeepFindAnyBetweenAsSectionsCSIBQR(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE, pcReturnType)

		#>

	  #-----------------------------------------------------------#
	 #   EXTRACTING DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO CHARS   # TODO: Generealize to substrings not only chars
	#-----------------------------------------------------------#
	# Bouding chars are NOT counted in the result

	def DeepAnyBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		aSections = This.DeepFindAnyBetweenAsSectionsCS(pcChar1, pcChar2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def DeepAnyBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepAnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.DeepAnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepAnyBetween(pcChar1, pcChar2)
		return This.DeepAnyBetweenCS(pcChar1, pcChar2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepAnyBetweenQ(pcChar1, pcChar2)
			return This.DeepAnyBetweenQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.DeepAnyBetweenCSQR(pcChar1, pcChar2, :CaseSensitive = TRUE, pcReturnType)
			
		#>

	  #-----------------------------------------------------------------------#
	 #   EXTRACTING DEEP-SUBSTRINGS ENCLOSED BETWEEN TWO CHARS -- EXTENDED   # 
	#-----------------------------------------------------------------------#
	# Bound chars are counted in the result

	def DeepAnyBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

		aSections = This.DeepFindAnyBetweenAsSectionsCSIB(pcChar1, pcChar2, pCaseSensitive)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def DeepAnyBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)
			return This.DeepAnyBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.DeepAnyBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.DeepAnyBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off
			
		#>

	#-- WITHOUT CASESENSITIVITY

	def DeepAnyBetweenIB(pcChar1, pcChar2)
		return This.DeepAnyBetweenCSIB(pcChar1, pcChar2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def DeepAnyBetweenIBQ(pcChar1, pcChar2)
			return This.DeepAnysBetweenIBQR(pcChar1, pcChar2, pCaseSensitive, :stzList)

		def DeepAnyBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.DeepAnyBetweenCSIBQR(pcChar1, pcChar2, :CaseSensitive = TRUE, pcReturnType)
			
		#>

	  #========================================#
	 #  VISUALLY FINDING CHARS IN THE STRING  #
	#========================================#

	def VizFindChar(c)
		if IsStzChar(c)
			c = c.Content()
		ok

		if NOT ( isString(c) and StringIsChar(c) )
			return NULL
		ok

		cResult = @@( This.Content() )
		anPositions = This.FindAll( c )

		nLen = StzStringQ(cResult).NumberOfChars()

		cViz = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anPositions)
				cViz += "^"
			else
				cViz += "-"
			ok

		next

		cResult += (NL + cViz)

		return cResult

		#< @FunctionFluentForm

		def VizFindCharQ(pItem)
			return new stzString( This.VizFindChar(pItem) )

		#>

	  #-----------------------------------------#
	 #      VISUALLY FINDING A SUBSTRING       #
	#-----------------------------------------#

	def VizFindXT(pcSubStr, paOptions)

		# STEP 1: Checking params TYPES
		
		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if NOT ( isList(paOptions) and
			 Q(paOptions).IsHashList() and

			 StzHashListQ(paOptions).KeysQ().IsMadeOfSome([
				:CaseSensitive, :CS, :PositionSign,
				:BlankSign, :Numbered, :Spacified,
				:Boxed, :BoxOptions ]) )
			 
			stzRaise("Incorrect param type! paOptions must be a wellformed hashlist.")
		ok

		# At this level, we are sure pcSubStr is a string and
		# paOptions is a hashlist made of some of the allowed keys for boxing

		# Before going further, Delegate the work to VizFindBoxedXT()
		# when boxing is required

		if StzHashListQ(paOptions).ContainsKey(:Boxed) and
		   IsBoolean(paOptions[ :Boxed ]) and paOptions[ :Boxed ] = TRUE

			return This.VizFindBoxedXT(pcSubStr, paOptions)
		ok

		if StzHashListQ(paOptions).KeysQ().ContainsBoth(:CaseSensitive, :CS)
			stzRaise("Incorrect options! :CaseSensitive and its short form :CS must not be used both.")
		ok

		# Unfying the :CaseSensitive / :CS keyword

		n = StzHashListQ(paOptions).FindKey(:CS)
		if n > 0
			paOptions[n][1] = :CaseSensitive
		ok

		# STEP 2: Reading params values

		bCaseSensitive = TRUE
		if ( isString(paOptions[:CaseSensitive]) and paOptions[:CaseSensitive] != NULL ) or
		   ( isNumber(paOptions[:CaseSensitive]) and IsBoolean(paOptions[:CaseSensitive])  )

			bCaseSensitive = paOptions[:CaseSensitive]
		ok

		cPositionSign = "^"
		if isString(paOptions[:PositionSign]) and paOptions[:PositionSign] != NULL
			cPositionSign = paOptions[:PositionSign]
		ok

		cBlankSign = "-"
		if isString(paOptions[:BlankSign]) and paOptions[:BlankSign] != NULL
			cBlankSign = paOptions[:BlankSign]
		ok

		bNumbered = FALSE
		if ( isString(paOptions[:Numbered]) and paOptions[:Numbered] != NULL ) or
		   ( isNumber(paOptions[:Numbered]) and IsBoolean(paOptions[:Numbered])  )

			bNumbered = paOptions[:Numbered]
		ok

		bSpacified = FALSE
		if ( isString(paOptions[:Spacified]) and paOptions[:Spacified] != NULL ) or
		   ( isNumber(paOptions[:Spacified]) and IsBoolean(paOptions[:Spacified])  )

			bSpacified = paOptions[:Spacified]
		ok

		# STEP 3: Checking the correctness of the provided values

		bCorrect = TRUE
		acWhy = [] # Will host the reasons of the errors

		If NOT IsBoolean(bCaseSensitive)

			bCorrect = FALSE
			acWhy + ":CaseSensitive option must be a boolean"
		ok

		if NOT ( isString(cPositionSign) and StringIsChar(cPositionSign) )

			bCorrect = FALSE
			acWhy + ":PositionSign option must be a char"
		ok

		if NOT ( isString(cBlankSign) and StringIsChar(cBlankSign) )

			bCorrect = FALSE
			acWhy + ":BlankSign option must be char"
		ok

		if NOT cPositionSign != cBlankSign

			bCorrect = FALSE
			acWhy + ":PositionSign and :BlankSign options must be different"
		ok

		If NOT IsBoolean(bNumbered)

			bCorrect = FALSE
			acWhy + ":Numbered option must be a boalean"
		ok

		If NOT IsBoolean(bSpacified)

			bCorrect = FALSE
			acWhy + ":Spacified option must be a boalean"
		ok

		if NOT bCorrect
			stzRaise([
				:Where	= "stzString.ring > vizFindXT()",
				:What	= StzListOfStringsQ(acWhy).ConcatenatedUsing(", ") + "."
			])
		ok

		# At this level, we are sure the params are well formed
		#--> Let's do the job!

		if bSpacified
			cString= @@( This.Spacified() )
		else
			cString = @@( This.Content() )
		ok

		oString = new stzString(cString)

		anPositions = oString.FindAllCS( pcSubStr, :CS = bCaseSensitive )

		anVizPositions = StzListOfNumbersQ(anPositions).
				 SubstractFromEachQ(1).Content()

		nLen = oString.NumberOfChars()

		cVizLine = " "
		for i = 1 to nLen - 2
			
			if StzNumberQ(i).IsOneOfThese(anVizPositions)
				cVizLine += cPositionSign
			else
				cVizLine += cBlankSign
			ok

		next

		cResult = oString.Content() + NL + cVizLine

		if bNumbered

			oVizLine = new stzString(cVizLine)

			oVizLine {
	
				Replace(cBlankSign, " ")

				cCondition = '@char = ' + @@(cPositionSign)

				if NOT bSpacified

					cReplacement@ = '{ Q( ""+ ( This.FindAll(' +
						 @@(cPositionSign) +
						 ')[@i] - 1 ) ).LastChar() }'

				else

					cReplacement@ = '{ Q( ""+ ( This.FindAll(' +
						 @@(cPositionSign) +
						 ')[@i] / 2 ) ).LastChar() }'
					
				ok

				ReplaceW( :Where = cCondition, :With@ = cReplacement@ )

			}

			cResult += NL + oVizLine.TrailingSpacesRemoved()

		ok

		return cResult

		#< @FunctionFluentForm

		def VizFindXTQ(pcSubStr, paOptions)
			return new stzString( This.VizFindXT(pcSubStr, paOptions) )

		#>

	def VizFind(pcSubStr)
		return This.VizFindXT(pcSubStr, [ :PositionChar = "^" ] )

	def VizFindCS(pcSubStr, pCaseSensitive)
		return This.VizFindXT(pcSubStr, [ pCaseSensitive ])
		
	  #----------------------------------------------------#
	 #      VISUALLY FINDING AND BOXING A SUBSTRING       # TODO: Review this
	#----------------------------------------------------#

	def VizFindBoxedXT(pcSubstr, paOptions) # TODO
		/* EXAMLPE

		*/

		if NOT ( isString(pcSubStr) or
		  	sList(paOptions) and StzListQ(paOptions).IsBoxOptionsNamedParam() )

			stzRaise("Incorrect params!")
		ok


/*
	
			if paOptions[ :Casesensitive ] = TRUE or
			   paOptions[ :CS ] = TRUE
	
				paOptions + [ :Hilighted, 
					      This.FindAllCS(pcSubStr, :CS = TRUE)
					    ]
			else
				paOptions + [ :Hilighted, 
					      This.FindAllCS(pcSubStr, :CS = FALSE)
					    ]
			ok
	
			StzHashListQ(paOptions) {
				RemovePairByKeyQ(:Casesensitive = TRUE)
				RemovePairByKeyQ(:CS = TRUE)
				paOptions = Content()
			}
	
			oStzListOfChars = new stzListOfChars(This.String())
			return oStzListOfChars.BoxedXT(paOptions)
	*/

	  #======================================#
	 #   CONTAINMENT OF A GIVEN SUBSTRING   #
	#======================================#

	def ContainsCS(pcSubStr, pCaseSensitive)
		#< QtBased | Uses QString.indexOf() >

		# Checking params

		if isList(pcSubStr)
			return This.ContainsTheseSubStringsCS(pcSubStr, pCaseSensitive)
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a STRING, while you are providing a " +
				   ring_type(pcSubStr) + ".")
		ok

		# Resolving pCaseSensitive param

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Incorrect param! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job (Qt-side)

		nPos = This.QStringObject().indexOf(pcSubStr, 0, pCaseSensitive) + 1

		if nPos > 0
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForm

		def ContainsSubStringCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(cSubStr, pCaseSensitive)
		#>

		#< @FunctionNegativeForm

		def ContainsNoCS(pcSubStr, pCaseSensitive)
			return NOT This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm
	
		def CottainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		def ConttainsCS(pcSubStr, pCaseSensitive)
			return This.ContainsCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def Contains(pcSubStr)
		return This.ContainsCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def ContainsSubString(pcSubStr)
			return This.Contains(pcSubStr)
		#>

		#< @FunctionNegativeForm

		def ContainsNo(pcSubStr)
			return NOT This.Contains(pcSubStr)

		#>

		#< @FunctionMisspelledForm
	
		def Cottains(pcSubStr)
			return This.Contains(pcSubStr)

		def Conttains(pcSubStr)
			return This.Contains(pcSubStr)

		#>

	  #------------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS CONTAINED IN AN OTHER GIVEN STRING   #
	#------------------------------------------------------------------#

	def IsContainedInCS(pcOtherStr, pCaseSensitive)

		if NOT Q(pcOtherStr).IsStringOrList()
			StzRaise("Incorrect param type! pcOtherStr must be a string or list.")
		ok

		bResult = Q(pcOtherStr).ContainsCS(This.String(), pCaseSensitive) 
		return bResult

		#< @FunctionAlternativeForms

		def IsIncludedInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		def ExistsInCS(pcOtherStr, pCaseSensitive)
			return This.IsContainedInCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsContainedIn(pcOtherStr)
		return This.IsContainedInCS(pcOtherStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def IsIncludedIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		def ExistsIn(pcOtherStr)
			return This.IsContainedIn(pcOtherStr)

		#>

	  #------------------------------------------------#
	 #   CHECKING CONATAINMENT ON A GIVEN CONDITION   #
	#------------------------------------------------#

	def ContainsW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)
		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Icnorrect syntax! pcCondition must contain either @char or @substring keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.ContainsSubStringsW(pcCondition)

		else
			return This.ContainsCharsW(pcCondition)
		ok

	def ContainsCharsW(pcCondition)
		/* EXAMPLE

		? Q("__---__").ContainsXT(:CharsWhere, '@charQ.IsEither("_", :Or = "-")')
		#--> TRUE
		*/

		if (NOT isString(pcCondition)) or
		   (isString(pcCondition) and Q(pcCondition).WithoutSpaces() = "")

			return FALSE
		ok

		cCondition = StzCCodeQ(pcCondition).Transpiled()
		
		bResult = FALSE
		nLen = This.NumberOfChars()

		for @i = 1 to nLen
			cCode = 'bOk = (' + cCondition + ')'

			eval(cCode)
			if bOk
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def ContainsSubStringsW(pcCondition)
		if (NOT isString(pcCondition)) or
		   (isString(pcCondition) and Q(pcCondition).WithoutSpaces() = "")

			return FALSE
		ok

		pcCondition = StzStringQ(pcCondition).
				ReplaceCSQ("@substring", "@item", :CS = FALSE).
				Content()

		bResult = This.SubStringsQ().ContainsW(pcCondition)

		return bResult

	  #--------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITON/SUBSTRING  #
	#--------------------------------------------------------------------------------------#

	def ContainsBeforeCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosBefore = p

		if isString(p)
			nPosBefore = This.FindLastCS(p, pCaseSensitive)
		ok

		bResult = This.ContainsInSectionCS(pcSubStr, 1, nPosBefore-1, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsBefore(pcSubStr, p)
		return This.ContainsBeforeCS(pcSubStr, p, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITON/SUBSTRING  #
	#-------------------------------------------------------------------------------------#

	def ContainsAfterCS(pcSubStr, p, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		if isList(p) and Q(p).IsOneOfTheseNamedParams([ :Position, :SubString ])
			p = p[2]
		ok

		if NOT Q(p).IsNumberOrString() // can be wriiten Q(p).IsA([ :Number, :Or = :String ])
			StzRaise("Incorrect param type! p must be a number or string.")
		ok

		nPosAfter = p

		if isString(p)
			nPosAfter = This.FindFirstCS(p, pCaseSensitive)
		ok

		nLenSubStr = This.NumberOfChars()
		bResult = This.ContainsInSectionCS(pcSubStr, nPosAfter+1, nLenSubStr, pCaseSensitive)

		return bResult

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfter(pcSubStr, p)
		return This.ContainsAfterCS(pcSubStr, p, :CaseSensitive = TRUE)

	  #----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN POSITON  #
	#----------------------------------------------------------------------------#

	def ContainsBeforePositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforePosition(pcSubStr, pnPos)
		return This.ContainsBeforePositionCS(pcSubStr, pnPos, :CaseSensitive = TRUE)

	  #------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING BEFORE A GIVEN SUBSTRING  #
	#------------------------------------------------------------------------------#

	def ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsBeforeCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsBeforeSubString(pcSubStr1, pcSubStr2)
		return This.ContainsBeforeSubStringCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #---------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN POSITON  #
	#---------------------------------------------------------------------------#

	def ContainsAfterPositionCS(pcSubStr, pnPos, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr, :Position = pnPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterPosition(pcSubStr, pnPos)
		return This.ContainsAfterPositionCS(pcSubStr, pnPos, :CaseSensitive = TRUE)

	  #-----------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN SUBSTRING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.ContainsAfterCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsAfterSubString(pcSubStr1, pcSubStr2)
		return This.ContainsAfterSubStringCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

	  #=======================================#
	 #   CHECKING CONATAINMENT -- EXTENDED   #
	#=======================================#

	def ContainsCSXT(p1, p2, pCaseSensitive)
		
		#=== GENERAL

		# ? Q("").ContainsXT(:Chars, []) #--> FALSE
		if This.String() = "" and isString(p1) = :Chars and
		   (  (isList(p2)   and len(p2) = 0) or
		      (isString(p2) and p2 = ""    ) or
		      (isNumber(p2) and p2 = 0     )    )

			return FALSE

		# ? Q("").ContainsXT([], :Chars) #--> FALSE
		but ( (isList(p1)   and len(p1) = 0) or
		      (isString(p1) and p1 = ""    ) or
		      (isNumber(p1) and p1 = 0     )    ) and

		    isString(p2) and p2 = :Chars

			return FALSE

		# ? Q("____").ContainsXT("", "_")
		but BothAreStrings(p1, p2) and
		    NOT Q(p1).IsOneOfThese([
			:CharsW, :CharsWhere, :SubStringsW, :SubStringsWhere
			])

			return This.ContainsTheseCS([p1, p2], pCaseSensitive)
		
		# ? Q("____").ContainsXT("", "_")
		but isString(p1) and isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :And

			return This.ContainsTheseCS([p1, p2[2]], pCaseSensitive)

		# ? Q("______").ContainsXT(2, "")
		but isNumber(p1) and isString(p2)
			return This.ContainsNOccurrencesCS(p1, p2, pCaseSensitive)
		
		# ? Q("______").ContainsXT( :Exactly = 2, "" )
		but isList(p1) and Q(p1).IsExactlyNamedParam()
			return This.ContainsNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("______").ContainsXT( :MoreThen = 1, "")
		but isList(p1) and Q(p1).IsMoreThenNamedParam()
			return This.ContainsMoreThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("______").ContainsXT( :LessThen = 3, "")
		but isList(p1) and Q(p1).IsLessThenNamedParam()
			return This.ContainsLessThenNOccurrencesCS(p1[2], p2, pCaseSensitive)

		# ? Q("____").ContainsXT("", [])
		but isString(p1) and isList(p2) and len(p2) = 0 and
			NOT Q(p2).IsWhereNamedParam()

			return This.ContainsCS(p1, pCaseSensitive)

		# ? Q("_--_").ContainsXT("", :BoundedBy = "-")
		# ? Q("_--_").ContainsXT(:SubString = "", :BoundedBy = "-")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBoundedByNamedParam()

			if isList(p1) and Q(p1).IsSubStringNamedParam()
				p1 = p1[2]
			ok

			return This.ContainsSubStringBoundedByCS(p1, p2[2], pCaseSensitive)
		
		# ? Q("_/\_").ContainsXT("", :Between = ["/", :And = "\"])
		but isString(p1) and isList(p2) and Q(p2).IsBetweenNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			if Q(p2[2]).isListOfStrings()
				return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			but Q(p2[2]).isListOfNumbers()
				return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)

			ok

		# ? Q("..<<---->>..").ContainsXT("", :InBetween = ["<<", ">>"])
		but isString(p1) and isList(p2) and Q(p2).IsInBetweenNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			if Q(p2[2]).isListOfStrings()
				return This.ContainsInBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
			ok

		but isString(p1) and isList(p2) and
		    Q(p2).IsInSectionNamedParam() and
		    isList(p2[2]) and Q(p2[2]).IsPairOfNumbers()

			return This.containsInSectionCS(p1, p2[2][1], p2[2][2], pCaseSensitive)


		but isString(p1) and isList(p2) and Q(p2).IsBetweenSubStringsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		but isString(p1) and isList(p2) and Q(p2).IsBetweenPositionsNamedParam()

			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok

			return This.ContainsSubStringBetweenPositionsCS(p1, p2[2][1], p2[2][2], pCaseSensitive)
		
		# ? Q("__--__").ContainsXT(["_", "-", ""], [])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and len(p2) = 0
			return This.ContainsTheseCS(p1, pCaseSensitive)
		
		# ? Q("__--__--__").ContainsXT(["", ""], :BoundedBy = "-")
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBoundedByNamedParam()
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBoundedByCS(p1[i], p2[2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("__/\__/\__").ContainsXT(["", ""], :Between = ["/","\"])
		but isList(p1) and Q(p1).IsListOfStrings() and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok
		
			bResult = TRUE
		
			nLen = len(p1)
			for i = 1 to nLen
				if NOT This.ContainsSubStringBetweenCS(p1[1], p2[2][1], p2[2][2], pCaseSensitive)
					bResult = FALSE
					exit
				ok
			next
		
			return bResult
		
		# ? Q("____").ContainsXT([], "")
		but isList(p1) and len(p1) = 0 and isString(p2)
			return This.ContainsCS(p2, pCaseSensitive)
		
		# ? Q("______").ContainsXT( [], :BoundedBy = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBoundedByNamedParam()
			return This.ContainsSubStringsBoundedByCS(p2[2], pCaseSensitive)
		
		# ? Q("__/\__/^^\__").ContainsXT( [], :Between = ["/","\"] )
		but isList(p1) and len(p1) = 0 and isList(p2) and Q(p2).IsBetweenNamedParam()
			if Q(p2[2]).IsAndNamedParam()
				p2[2] = p2[2][2]
			ok
		
			return This.ContainsSubStringsBetweenCS(p2[2][1], p2[2][2], pCaseSensitive)
			
		#=== CHARS

		# ? Q("__--__").ContainsXT(:Chars, ["_", "-", "_"])
		# ? Q("__--__").ContainsXT(:TheseChars, ["_", "-", "_"])
		but isString(p1) and (p1 = :Chars or p1 = :TheseChars) and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:SomeOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :SomeOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsSomeOfTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:OneOfTheseChars, ["_", "-", "_"])
		but isString(p1) and p1 = :OneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsOneOfTheseSubStrings(p2)

		# ? Q("__--__").ContainsXT(:NoneOfTheseChars, ["A", "*", "B"])
		but isString(p1) and p1 = :NoneOfTheseChars and
		    isList(p2) and Q(p2).IsListOfChars()

			return This.ContainsNoneOfTheseSubStrings(p2)

		# ? Q("__---__").ContainsXT(:CharsWhere, '@charQ.IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:CharsW, '@charQ.IsEither("_", :Or = "-")')
		but isString(p1) and (p1 = :CharsWhere or p1 = :CharsW) and isString(p2)
			return This.ContainsCharsW(p2)
		
		# ? Q("__---__").ContainsXT(:Chars, :Where = '@charQ.IsEither("_", :Or = "-")')
		# ? Q("__---__").ContainsXT(:Chars, Where('@charQ.IsEither("_", :Or = "-")'))
		# ? Q("__---__").ContainsXT(:Chars, W('@charQ.IsEither("_", :Or = "-")'))
		but isString(p1) and p1 = :Chars and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return this.ContainsCharsW(p2[2])

		#=== SUBSTRINGS

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStrings, ["softanza", :And = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:TheseSubStrings, ["softanza", :And = "ring"])
		but isString(p1) and (p1 = :SubStrings or p1 = :TheseSubStrings) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfTheseSubStrings, ["ring", "php", :Or = "softanza"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:SomeOfThese, ["ring", "php", "softanza"])
		but isString(p1) and (p1 = :SomeOfTheseSubStrings or p1 = :SomeOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsSomeOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfTheseSubStrings, ["python", "php", :Or = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:OneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :OneOfTheseSubStrings or p1 = :OneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsOneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfTheseSubStrings, ["python", "php", :Nor = "ring"])
		# ? Q("_softanza_loves_ring_").ContainsXT(:NoneOfThese, ["python", "php", :Or = "ring"])
		but isString(p1) and (p1 = :NoneOfTheseSubStrings or p1 = :NoneOfThese) and
		    isList(p2) and Q(p2).IsListOfStrings()

			return This.ContainsNoneOfTheseSubStringsCS(p2, pCaseSensitive)

		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsWhere, '@SubStringQ.IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, '@SubStringQ.IsUppercase()')
		but isString(p1) and (p1 = :SubStringsWhere or p1 = :SubStringsW) and isString(p2)

			return This.ContainsSubStringsW(p2)
			
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where = '@SubStringQ.IsUppercase()')
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :Where('@SubStringQ.IsUppercase()') )
		# ? Q("_softanza_loves_ring_").ContainsXT(:SubStringsW, :W('@SubStringQ.IsUppercase()') )
		but isString(p1) and p1 = :SubStringsW and
		    isList(p2) and Q(p2).IsPairOfStrings() and p2[1] = :Where	

			return This.ContainsSubStringsW(p2[2])

		# ? Q("^^^^").ContainsXT("", :AtPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPosition ]) and
		    isNumber(p2[2])

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAt(p2[2], p1)

		# ? Q("^^^^").ContainsXT("", :AtPositions = [1, 4, 7])
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsOneOfTheseNamedParams([ :At, :AtPositions ]) and
		    isList(p2[2]) and Q(p2[2]).IsListOfNumbers()

			if isList(p1)
				p1 = p1[2]
			ok

			return This.ContainsAtPositions(p2[2], p1)

		# ? Q("^^^^").ContainsXT("^", :Before = "^")
		# ? Q("^^^^").ContainsXT("^", :Before = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforeNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsBefore(p1, p2[2])

		# ? Q("--^^").ContainsXT("^", :After = "-")
		# ? Q("^^^^").ContainsXT("^", :After = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterNamedParam() and Q(p2[2]).IsStringOrNumber()

			return This.ContainsAfter(p1, p2[2])

		# ? Q("^^^^").ContainsXT("^", :BeforePosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforePositionNamedParam() and isNumber(p2[2])

			return This.ContainsBefore(p1, :Position = p2[2])

		# ? Q("^^^^").ContainsXT("^", :AfterPosition = 3)
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterPositionNamedParam() and isNumber(p2[2])

			return This.ContainsAfter(p1, :Position = p2[2])

		# ? Q("^^^^").ContainsXT("^", :BeforeSubString = "^")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsBeforeSubStringNamedParam() and isString(p2[2])

			return This.ContainsBefore(p1, :SubString = p2[2])

		# ? Q("--^^").ContainsXT("^", :AfterSubString = "-")
		but ( isString(p1) or
		      ( isList(p1) and Q(p1).IsSubStringNamedParam() and isString(p1[2]) )
		    ) and

		    isList(p2) and Q(p2).IsAfterSubStringNamedParam() and isString(p2[2])

			return This.ContainsAfter(p1, :SubString = p2[2])

		else

			StzRaise("Unsupported syntax")
		ok

	#-- WITOUT CASESENSITIVITY

	def ContainsXT(p1, p2)
		return This.ContainsCSXT( p1, p2, :CaseSensitive = TRUE)

	  #-------------------------------------------------------------------#
	 #   CONTAINING A SUBSTRING BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS   #
	#-------------------------------------------------------------------#

	def ContainsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive) # :CaseSensitive = TRUE or :CaseSensitive = FALSE

		# Case where bounds are provided as numbers

		if isList(pacBounds) and Q(pacBounds).IsSectionNamedParam() and
		   Q(pacBounds[2]).IsPairOfNumbers()

			pacBounds = pacBounds[2]
		ok

		if isList(pacBounds) and Q(pacBounds).IsPositionsNamedParam() and
		   Q(pacBounds[2]).IsPairOfNumbers()

			pacBounds = pacBounds[2]
		ok

		# ? Q("^^^^").ContainsBoundedBy("", :Positions = [ 2, :And = 4])

		if isList(pacBounds) and Q(pacBounds).IsPositionsNamedParam() and
		   isList(pacBounds[2]) and len(pacBounds[2]) = 2 and
		   Q(pacBounds[2][2]).IsAndNamedParam()

				aTemp = []
				aTemp + pacBounds[2][1]
				aTemp + pacBounds[2][2][2]
				pacBounds = aTemp
		ok

		if isList(pacBounds) and len(pacBounds) = 2
			
			if isList(pacBounds[1]) and Q(pacBounds[1]).IsOneOfTheseNamedParams([ :Position, :Positions ])
				pacBounds[1] = pacBounds[1][2]
			ok

			if isList(pacBounds[2]) and Q(pacBounds[2]).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				pacBounds[2] = pacBounds[2][2]
			ok 
		ok

		if isList(pacBounds) and Q(pacBounds).IsPairOfNumbers()

			aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

			nLen = len(aSections)

			for i = 1 to nLen
				if aSections[i][1] = pacBounds[1] + 1 and
				   aSections[i][2] = pacBounds[2]  - 1

					return TRUE
				ok
			next

			return FALSE
		ok

		# Case where bounds are provided as strings

		if isList(pacBounds) and Q(pacBounds).IsAndNamedParam()
			pacBounds[2] = pacBounds[2]
		ok

		bResult = Q(pcSubStr).IsBoundedByIB(pacBounds, :InSide = This.String())

		return bResult

		#< @FunctionAlternativeForm

		def ContainsSubstringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This.ContainsBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoundedBy(pcSubStr, pacBounds)
		return This.ContainsSubstringBoundedByCS(pcSubStr, pacBounds, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def ContainsSubStringBoundedBy(pcSubStr, pacBounds)
			return This.ContainsBoundedBy(pcSubStr, pacBounds)

		#>

	  #-----------------------------------------------------------------------#
	 #    CONTAINING ANY SUBSTRINGS BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS   #
	#-----------------------------------------------------------------------#

	def ContainsAnyBoundedByCS(pacBounds, pCaseSensitive)
		return This.ContainsTheseBoundsCS(pacBounds, pCaseSensitive)

		def ContainsAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			if isList(pcBound1) and Q(pcBound1).IsSubStringNamedParam()
				pcBound1 = pcBound1[2]
			ok

			if NOT isString(pcBound1)
				StzRaise("Incorrect param type! pcBound1 must be a string.")
			ok

			if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
				pcBound2 = pcBound2[2]
			ok

			if NOT isString(pcBound21)
				StzRaise("Incorrect param type! pcBound2 must be a string.")
			ok

			return This.ContainsAnyBoundedByCS([pcBound1, pcBound2], pCaseSensitive)

	#--

	def ContainsAnyBoundedBy(pacBounds)
		return This.ContainsAnyBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		def ContainsAnyBetween(pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsAnyBetweenCS(pcBound1, pcBound2, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------------#
	 #    CONTAINING SUBSTRINGS BOUNDED BY ONE OR TWO GIVEN SUBSTRINGS    #
	#--------------------------------------------------------------------#

	def ContainsSubStringsBoundedByCS(paBounds, pCaseSensitive)
		/* EXAMPLE

		? Q("__/ring\__/is\__/fun\__").ContainsSubStringsBoundedBy(["/", "\"])
		#--> TRUE
		*/

		bResult = FALSE

		if isString(paBounds)
			bResult = This.NumberOfOccurrenceCSQ(paBounds, pCaseSensitive).IsEven()

		but isList(paBounds) and Q(paBounds).IsPair()
			if isList(paBounds[2]) and Q(paBounds[2]).IsAndNamedParam()
				paBounds[2] = paBounds[2][2]
			ok

			if Q(paBounds).IsPairOfStrings()

				n1 = This.FindFirstCS(paBounds[1], pCaseSensitive)
				n2 = This.FindFirstCS(paBounds[2], pCaseSensitive)
	
				if n2 > n1
					bResult = TRUE
				ok

			ok
		ok

		return bResult

		#< @FuntionAlternativeForm

		def ContainsSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsSubStringsBoundedByCS([pcBound1, pcBound2], pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsBoundedBy(paBounds)
		return This.ContainsSubStringsBoundedByCS(paBounds, :CaseSensitive = TRUE)

		#< @FuntionAlternativeForm

		def ContainsSubStringsBetween(pcBound1, pcBound2)
			return This.ContainsSubStringsBoundedBy([pcBound1, pcBound2])

		#>

	  #--------------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#--------------------------------------------------------------#

	def ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		if isList(p1) and Q(p1).IsOneOfTheseNamedParams([
			:Position, :Positions, :SubString, :SubStrings ])
			p1 = p1[2]
		ok

		if isList(p2) and Q(p2).IsOneOfTheseNamedParams([
			:And, :AndPosition, :AndSubString ])
			p2 = p2[2]
		ok

		bResult = FALSE

		# Q("^^^^").ContainsBetween("", 3, 5)
		if BothAreNumbers(p1, p2)
			if This.SectionQ(p1, p2).ContainsCS(pcSubStr, pCaseSensitive)
				bResult = TRUE
			ok

		# Q("<<>>").ContainsBetween("", "<<", ">>")
		but BothAreStrings(p1, p2)
			bResult = This.ContainsSubstringBoundedByCS(pcSubStr, [p1, p2], pCaseSensitive)

		else
			StzRaise("Incorrect param! p1 and p2 must be both numbers or strings.")
		ok

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		def ContainsInBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		def ContainsSubstringInBetweenCS(pcSubStr, p1, p2, pCaseSensitive)
			return This.ContainsBetweenCS(pcSubStr, p1, p2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetween(pcSubStr, p1, p2)
		return This.ContainsBetweenCS(pcSubStr, p1, p2, :CaseSensitive = TRUE)

		def ContainsSubstringBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

		def ContainsInBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

		def ContainsSubstringInBetween(pcSubStr, p1, p2)
			return This.ContainsBetween(pcSubStr, p1, p2)

	  #------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO GIVEN POSITIONS  #
	#------------------------------------------------------#

	def ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
		if isList(n2) and Q(n2).IsAndNamedParam()
			n2 = n2[2]
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param types! Both n1 and n2 must be numbers.")
		ok

		return This.ContainsBetweenCS(pcSubStr, n1, n2, pCaseSensitive)

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		def ContainsInSectionCS(pcSubStr, n1, n2, pCaseSensitive)
			return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, pCaseSensitive)

		#>

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetweenPositions(pcSubStr, n1, n2)
		return This.ContainsBetweenPositionsCS(pcSubStr, n1, n2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubstringBetweenPositions(pcSubStr, n1, n2)
			return This.ContainsBetweenPositions(pcSubStr, n1, n2)

		def ContainsInSection(pcSubStr, n1, n2)
			return This.ContainsBetweenPositions(pcSubStr, n1, n2)

		#>

	  #--------------------------------------------------------#
	 #  CONTAINING A SUBSTRING BETWEEN TWO GIVEN SUBSTRINGS   #
	#--------------------------------------------------------#

	def ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound1) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		if NOT BothAreStrings(pcBound1, pcBound2)
			StzRais("Incorrect param types! Both pcBound1 and pcBound2 must be numbers.")
			# NOTE that this is a misspelled form of StzRaise()
		ok

		return This.ContainsBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def ContainsSubStringBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WTHOUT CASESENSITIVITY

	def ContainsBetweenSubStrings(pcSubStr, pcBound1, pcBound2)
		return This.ContainsBetweenSubStringsCS(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def ContainsSubstringBetweenSubStrings(pcSubStr, pcBound1, pcBound2)
			return This.ContainsBetweenSubStrings(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS A GIVEN NUMBER OF BOUNDED SUBSTRINGS  #
	#------------------------------------------------------------------------#

	def ContainsNSubStringsBoundedByCS(n, pacBounds, pCaseSensitive)
		if n = This.NumberOfubStringsBoundedByCS(pacBounds, pCaseSensitive)
			return TRUE
		else
			return FALSE
		ok

		def ContainsNSubStringsBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
			return This.ContainsNSubStringsBoundedByCS(n, [pcBound1, pcBound2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNSubStringsBoundedBy(n, pacBounds)
		return This.ContainsNSubStringsBoundedByCS(n, pacBounds, :CaseSensitive = TRUE)

		def ContainsNSubStringsBetween(n, pcBound1, pcBound2)
			return This.ContainsNSubStringsBoundedBy(n, [pcBound1, pcBound2])

	  #----------------------------------------------#
	 #    CONTAINING ONE OF THE GIVEN SUBSTRINGS    #
	#----------------------------------------------#

	def ContainsOneOfTheseCS(paSubStr, pCaseSensitive)
		bResult = FALSE
		nLen = len(paSubStr)

		for i = 1 to nLen
			if This.ContainsCS( paSubStr[i],  pCaseSensitive)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsAnyOfTheseCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#--

		def ContainsOneOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheseSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsOneOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		def ContainsAnyOfTheSubStringsCS(paSubStr, pCaseSensitive)
			return This.ContainsOneOfTheseCS(paSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOfThese(paSubStr)
		return This.ContainsOneOfTheseCS(paSubStr, :Casesensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsAnyOfThese(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOf(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfThe(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#--

		def ContainsOneOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheseSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsOneOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		def ContainsAnyOfTheSubStrings(paSubStr)
			return This.ContainsOneOfThese(paSubStr)

		#>

	  #-------------------------#
	 #    CONTAINING SPACES    #
	#-------------------------#

	def ContainsSpaces()
		return This.Contains(" ")

		#< @FunctionNegativeForm

		def ContainsNoSpaces()
			return NOT This.ContainsSpaces()

		#>

	  #------------------------------------------------#
	 #    CONTAINING BOTH OF THE GIVEN SUBSTRINGS     #
	#------------------------------------------------#

	def ContainsBothCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and Q(pcStr2).IsAndNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.ContainsEachCS( [pcStr1, pcStr2], pCaseSensitive )

	#-- WITHOUT CASESENSITIVITY

	def ContainsBoth(pcStr1, pcStr2)
		return This.ContainsBothCS(pcStr1, pcStr2, :CaseSensitive = TRUE)
	
	  #==============================================#
	 #   REMOVING A SUBSTRING AT A GIVEN POSITION   #
	#==============================================#

	def RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		if This.ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			nRange = StzStringQ(pcSubStr).NumberOfChars()
			This.RemoveRange(n, nRange)
		ok

		#< @FunctionFluentForm

		def RemoveSubStringAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		#>

	def SubStringAtPositionNRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveSubsStringAtPositionCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAt(n, pcSubStr)
		This.RemoveSubStringAtPositionCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtQ(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringAtPosition(n, pcSubStr)
			This.RemoveSubStringAt(n, pcSubStr)

		#>

	def SubStringAtPositionNRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveSubsStringAtPositionQ(n, pcSubStr).Content()
		return cResult

	  #-----------------------------------------------------#
	 #   REMOVING A SUBSTRING AT A SOME GIVEN POSITIONS    #
	#-----------------------------------------------------#

	def RemoveSubStringAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		/* EXAMPLE
		o1 = new stzString("ring php ring ruby ring python rping cshar ring")
		o1.RemoveSubstringAtPositions([ 10, 20, 32, 44 ], "ring")

		? o1.Content() #--> "ring php ruby python csharp"
		*/

		if NOT isList(panPositions) and Q(panPositions).IsListOfNumbers()
			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		anPositions = Q(panPositions).SortedInAscending()

		# Doing the job

		for i = len(anPositions) to 1 step -1
			n = anPositions[i]

			This.RemoveSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
		next

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive)
			This.RemoveSubStringAtPositionsCS(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemovedCS(panPos, pcSubStr, pCaseSensitive)

		cResult = This.
			  Copy().
			  RemoveSubStringAtPositionsCSQ(panPos, pcSubStr, pCaseSensitive).
			  Content()

		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringAtPositions(panPositions, pcSubStr)
		This.RemoveSubStringAtPositionsCS(panPositions, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveSubStringAtPositionsQ(panPos, pcSubStr)
			This.RemoveSubStringAtPositions(panPos, pcSubStr, pCaseSensitive)
			return This

		#>

	def SubStringAtPositionsRemoved(panPos, pcSubStr)
		return This.SubStringAtPositionsRemovedCS(panPos, pcSubStr, :CaseSensitive = TRUE)

	  #================================================#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if ( (isNumber(n)) and (isString(pcSubStr)) ) or
		   ( (isString(n)) and (isNumber(pcSubStr)) )

			return This.ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		but ( isList(n) and Q(n).IsListOfNumbers() and isString(pcSubStr) ) or
		    ( isString(n) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers() )

			return This.ContainsAtPositionsCS(n, pcSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param types! n must be a number and pcSubStr must be a string or vice versa.")
		ok

		def ContainsSubStringAtCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

	def ContainsAt(n, pcSubStr)
		return This.ContainsAtCS(n, pcSubStr, :CaseSensitive = TRUE)

		def ContainsSubStringAt(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

	  #------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT A GIVEN POSITION   #
	#================================================#

	def ContainsAtPositionCS(n, pcSubStr, pCaseSensitive)

		if isList(n) and Q(n).IsOneOfTheseNamedParams([ :Position, :SubString ])
			n = n[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOneOfTheseNamedParams([ :Position, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(n) and isNumber(pcSubStr)
			temp = pcSubStr
			pcSubStr = n
			n = temp
		ok

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		if NOT isString(pcSubStr)
			stzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		# ? Q("^^^^").ContainsAt(2, "")

		bResult = FALSE
		bContinue = TRUE
		i = 1

		anPos = This.FindAllCS(pcSubStr, pCaseSensitive)
		bResult = ring_find(anPos, n)

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		def SubStringExistsAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsAtCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPosition(n, pcSubStr)
		return This.ContainsAtPositionCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		def SubStringExistsAtPosition(n, pcSubStr)
			return This.ContainsAt(n, pcSubStr)

		#>

	  #------------------------------------------------------#
	 #   CONTAINING A SUBSTRING AT GIVEN (MANY) POSITIONS   #
	#======================================================#

	def ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		if isList(panPositions) and
		   Q(panPositions).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			panPositions = panPositions[2]
		ok

		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Positions, :SubString ])
			pcSubStr = pcSubStr[2]
		ok

		if isString(panPositions) and isList(pcSubStr) and Q(pcSubStr).IsListOfNumbers()
			temp = pcSubStr
			pcSubStr = panPositions
			panPositions = temp
		ok

		if NOT ( isList(panPositions) and Q(panPositions).IsListOfNumbers() )

			stzRaise("Incorrect param type! panPositions must be a list of numbers.")
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsListOfStrings()
			return This.ContainsSubStringsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)
		ok

		bResult = TRUE
		nLen = len(panPositions)

		for i = 1 to nLen
			if NOT This.ContainsSubStringAtPositionCS(panPositions[i], pcSubStr, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		def ContainsSubStringAtThesePositionsCS(panPositions, pcSubStr, pCaseSensitive)
			return This.ContainsAtPositionsCS(panPositions, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsAtPositions(panPositions, pcSubStr)
		return This.ContainsAtPositionsCS(panPositions, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringAtPositions(panPositions, pcSubStr)
			return This.ContainsAtPositions(panPositions, pcSubStr)

		def ContainsSubStringAtThesePositions(panPositions, pcSubStr)
			return This.ContainsAtPositions(panPositions, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   CONTAINING SUBSTRINGS AT GIVEN POSITIONS    #
	#-----------------------------------------------#

	def ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		if NOT ( isList(panPositions) and Q(panPositions).IsListOFNumbers() )

			stzRaise("Incorrect param type! panPositions must be a list of numbers.")
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )

			stzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		if NOT ( len(panPositions) = len(pacSubStr) )
			stzRaise("Incorrect values! panPositions and pacSubStr lists must have same number of items.")
		ok

		bResult = TRUE

		# TODO: change for in with for loop --> better performance
		i = 0
		for n in panPositions
			i++
			if NOT This.ContainsSubStringAtPosition(n, pacSubStr[i])
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositionsCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		def ContainsSubStringsAtCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		def ContainsManyAtCS(panPositions, pacSubStr, pCaseSensitive)
			return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsSubStringsAtPositions(panPositions, pacSubStr)
		return This.ContainsSubStringsAtPositionsCS(panPositions, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsSubStringsAtThesePositions(n, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		def ContainsSubStringsAt(panPositions, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		def ContainsManyAt(panPositions, pacSubStr)
			return This.ContainsSubStringsAtPositions(panPositions, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   CONTAINING SOME (ONE OR MORE) SUBSTRINGS   #
	#----------------------------------------------#

	def ContainsOneOrMoreCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfString() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		bResult = FALSE

		nLen = len(pacSubStr)
		n = 0
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				n++
				if n > 1
					bResult = TRUE
					exit
				ok
			ok
		next

		return bResult
		
	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMore(paSubStr)
		return This.ContainsOneOrMoreCS(paSubStr, :CS = TRUE)

	  #------------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A SUBSTRING     #
	#------------------------------------------------#

	def ContainsNTimesCS(n, pcSubstr, pCaseSensitive)
		return This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive) = n

		def ContainsNTimesTheSubstringCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNTimesCS(n, pcSubstr, pCaseSensitive)


	#-- WITHOUT CASESENSITIVITY

	def ContainsNTimes(n, pcSubStr)
		return This.ContainsNTimesCS(n, pcSubstr, :CaseSensitive = TRUE)

		def ContainsNTimesTheSubstring(n, pcSubstr)
			return This.ContainsNTimes(n, pcSubstr)

	  #-------------------------------------------#
	 #    CONTAINING N OCCURRENCES OF A CHAR     #
	#-------------------------------------------#

	def ContainsNTimesTheChar(n, pcChar)
		if NOT IsChar(pcChar)
			return FALSE
		ok
		
		return This.ContainsNTimesCS(n, pcChar, :CaseSensitive = FALSE)

	  #-------------------------------------------------#
	 #    CONTAINING ONE OCCURRENCE OF A SUBSTRING     #
	#-------------------------------------------------#

	def ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)
		return This.ContainsNTimesCS(1, pcSubStr, pCaseSensitive)
	
		#< @FunctionAlternativeForms

		def ContainsOnlyOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		def ContainsOneCS(pcSubStr, pCaseSensitive)
			return This.ContainsOneOccurrenceCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOccurrence(pcSubStr)
		return This.ContainsOneOccurrenceCS(pcSubstr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsOnlyOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		def ContainsOne(pcSubStr)
			return This.ContainsOneOccurrence(pcSubStr)

		#>
	  #----------------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS SOME (MORE THAN ONE OCCURRENCE) OF A SUBSTRING  #
	#----------------------------------------------------------------------------------#

	def ContainsSomeCS(pcSubstr, pCaseSensitive)
		return This.ContainsMoreThanNOccurrencesCS(1, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsSome(pcSubstr)
		return This.ContainsMoreThanOneOccurrenceCS(pcSubstr, :CaseSensitive = TRUE)
			
	  #--------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS MORE THAN N OCCURRENCES OF A SUBSTRING  #
	#--------------------------------------------------------------------------#

	def ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

		bResult = FALSE

		bContinue = TRUE
		i = 0
		nPos = 0

		while bContinue
	
			nPos = This.FindFirstCSXT(pcSubStr, :StartingAt = nPos + 1, pCaseSensitive)
			if nPos = 0
				bContinue = FALSE
			else
				i++
				if i > n
					bResult   = TRUE
					bContinue = FALSE
				ok
			ok
		end

		return bResult

		def ContainsMoreThenNCS(n, pcSubStr, pCaseSensitive)
			return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsMoreThanNOccurrences(n, pcSubstr)
		return This.ContainsMoreThanNOccurrencesCS(n, pcSubstr, :CaseSensitive = TRUE)

		def ContainsMoreThenN(n, pcSubStr)
			return This.ContainsMoreThanNOccurrences(n, pcSubstr)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS N OR MORE OCCURRENCES OF A SUBSTRING  #
	#------------------------------------------------------------------------#

	def ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)
		bResult = This.ContainsMoreThenNOccurrencesCS(n - 1, pcSubStr, pCaseSensitive)
		return bResult

		def ContainsNOrMoreCS(n, pcSubstr, pCaseSensitive)
			return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsNOrMoreOccurrences(n, pcSubstr)
		return This.ContainsNOrMoreOccurrencesCS(n, pcSubstr, :CaseSensitive = TRUE)
	
		def ContainsNOrMore(n, pcSubStr)
			return This.ContainsNOrMoreOccurrences(n, pcSubstr)

	  #----------------------------------------------------------------#
	 #  CHECKING IF THE STRING CONTAINS EACH OF THE GIVEN SUBSTRINGS  #
	#----------------------------------------------------------------#

	def ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
		bResult = TRUE
		nLen = len(pacSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(pacSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def ContainsTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsManyCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsEachOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachOneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsEachSubStringOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

		#< @FunctionNegativeForms

		def ContainsNoneOfTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoneCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoOneOfCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([ :These, :TheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)
	
		def ContainsNoSubStringOfTheseCS(pacSubStr, pCaseSensitive)
			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		def ContainsNoSubStringCS(pacSubStr, pCaseSensitive)
			if isList(pacSubStr) and
			   Q(pacSubStr).IsOneOfTheseNamedParams([
				:Of, :OfThese, :OfTheseSubStrings ])

				pacSubStr = pacSubStr[2]
			ok

			return NOT This.ContainsTheseSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ContainsTheseSubStrings(pacSubStr)
		return This.ContainsTheseSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ContainsThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsMany(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEach(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOne(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachOneOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOf(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfThese(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		def ContainsEachSubStringOfTheseSubStrings(pacSubStr)
			return This.ContainsTheseSubStrings(pacSubStr)

		#>

		#< @FunctionNegativeForm

		def ContainsNoneOfTheseSubStrings(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoneOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNone(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoOneOf(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubStringOfThese(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		def ContainsNoSubString(pacSubStr)
			return NOT This.ContainsTheseSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #    CONTAINING CHARS IN A GIVEN SCRIPT   #
	#-----------------------------------------#

	def ContainsCharsInScript(pcScript)
		return This.ToStzText().ContainsScript(pcScript)

		#< @FunctionNegativeForm

		def ContainsNocharsInScript(pcScript)
			return NOT This.ContainsCharsInScript(pcScript)

		#>

	  #---------------------------#
	 #    CONTAINING LETTERS     #
	#---------------------------#

	def ContainsLetter(pcLetter)

		if Q(pcLetter).IsAChar() and
		   StzCharQ(pcLetter).IsLetter()

		  	return This.ContainsCS( pcLetter, :CS = FALSE )
		else
			return FALSE
		ok

	def ContainsLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()
		
		for i = 1 to nLen
			if This.CharQ(i).IsLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLetters()
			return NOT This.ContainsNumbers()

		#>

	def ContainsTheLetters(pacLetters)
		if Q(pacLetters).IsListOfLetters()
			bResult = TRUE
			oStr = This.UppercaseQ()

			pacLetters = StzListOfCharsQ(pacLetters).Uppercased()
			for cLetter in pacLetters
				if oStr.ContainsNo(cLetter)
					bResult = FALSE
					exit
				ok
			next

			return bResult
		ok

	def ContainsArabicLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsArabicLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoArabicLetters()
			return NOT This.ContainsArabicNumbers()

		#>

	def ContainsLatinLetters()
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsLatinLetter()
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLatinLetters()
			return NOT This.ContainsLatinNumbers()

		#>

	def ContainsLettersInScript(pcScript)
		bResult = FALSE
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if This.CharQ(i).IsLetterInScript(pcScript)
				bResult = TRUE
				exit
			ok
		next
		return bResult

		#< @FunctionNegativeForm

		def ContainsNoLettersInScript(pcScript)
			return NOT This.ContainsNumbers(pcScript)

		#>

	  #=========================================#
	 #   SPLITTING THE STRING -- XT/EXTENDED   #
	#=========================================#

	def SplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtW(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeW(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterW(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitCSXTQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitCSXTQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitCSXTQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitCSXT(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedCSXT(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXT(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXT(pSubStrOrPos)
		return This.SplitCSXT(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SplitXTQ(pSubStrOrPos)
			return This.SplitXTQR(pSubStrOrPos, :stzList)

		def SplitXTQR(pSubStrOrPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitXT(pSubStrOrPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitXT(pSubStrOrPos) )

			on :stzListOfChars
				return new stzListOfChars( This.Split(pSubStrOrPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedXT(pSubStrOrPos)
		return This.SplitXT(pSubStrOrPos)

	  #----------------------------------------#
	 #  SPLITTING THE STRING -- XTZ/EXTENDED  #
	#----------------------------------------#

	def SplitCSXTZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAtSectionsZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

	def SplittedCSXTZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZ(pSubStrOrPos)
		return This.SplitCSXTZ(pSubStrOrPos, :CaseSensitive = TRUE)

	def SplittedXTZ(pSubStrOrPos)
		return This.SplitXTZ(pSubStrOrPos)


	  #-----------------------------------------#
	 #  SPLITTING THE STRING -- XTZZ/EXTENDED  #
	#-----------------------------------------#

	def SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.SplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.SplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.SplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.SplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.SplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.SplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.SplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.SplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.SplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.SplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.SplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.SplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.SplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.SplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.SplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.SplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.SplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.SplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.SplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.SplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.SplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.SplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.SplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.SplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.SplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.SplitAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.SplitBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.SplitAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

	def SplittedCSXTZZ(pSubStrOrPos, pCaseSensitive)
		return This.SplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitXTZZ(pSubStrOrPos)
		return This.SplitCSXTZZ(pSubStrOrPos, :CaseSensitive = TRUE)

	def SplittedXTZZ(pSubStrOrPos)
		return This.SplitXTZZ(pSubStrOrPos)

	  #-----------------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING OR POSITION  #
	#===============================================#

	def SplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitAsSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForm

		def SplitAtCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAtCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAtCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedAtCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAtCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAt(pSubStrOrPos)
		return This.SplitAtCS(pSubStrOrPos, :CaseSensitive = TRUE)

		def SplitAtQ(pSubStrOrPos)
			return This.SplitAtQR(pSubStrOrPos, :stzList)

		def SplitAtQR(pSubStrOrPos, pcReturnType)
			return This.SplitAtCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

	def SplittedAt(pSubStrOrPos)
		return This.SplitAt(pSubStrOrPos)

	  #-----------------------------------#
	 #   SPLITTING AT A GIVEN POSITION   #
	#===================================#

	def SplitAtPosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtPosition(n)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionQ(n)
			return This.SplitAtPositionQR(n, :stzList)

		def SplitAtPositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisPosition(n)
			return This.SplitAtPosition(n)

			def SplitAtThisPositionQ(n)
				return This.SplitAtThisPositionQR(n, :stzList)

			def SplitAtThisPositionQR(n, pcReturnType)
				return This.SplitAtPositionQR(n, pcReturnType)

		#>

	def SplittedAtPosition(n)
		return This.SplitAtPositions(n)

		def SplittedAtThisPosition(n)
			return This.SplitAtPositions(n)

	  #---------------------------------#
	 #   SPLITTING AT MANY POSITIONS   #
	#---------------------------------#

	def SplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ(This.NumberOfChars()).SplitAtPositions(anPos)
		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForm

		def SplitAtPositionsQ(anPos)
			return This.SplitAtPositionsQR(anPos, :stzList)

		def SplitAtPositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtThesePositionsQ(anPos)
				return This.SplitAtThesePositionsQR(anPos, :stzList)
	
			def SplitAtThesePositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		def SplitAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

			def SplitAtManyPositionsQ(anPos)
				return This.SplitAtManyPositionsQR(anPos, :stzList)
	
			def SplitAtManyPositionsQR(anPos, pcReturnType)
				return This.SplitAtPositionsQR(anPos, pcReturnType)

		#>

	def SplittedAtPositions(anPos)
		return This.SplitAtPositions(anPos)

		#< @FunctionAlternativeForms

		def SplittedAtThesePositions(anPos)
			return This.SplitAtPositions(anPos)

		def SplittedAtManyPositions(anPos)
			return This.SplitAtPositions(anPos)

		#>

	  #------------------------------------#
	 #   SPLITTING AT A GIVEN SUBSTRING   #
	#====================================#

	def SplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		acResult = QStringListToList( QStringObject().split(pcSubStr, 0, pCaseSensitive) )
		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def SplitCSQ(pcSubStr, pCaseSensitive)
				return This.SplitCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

			def AtThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.AtThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def AtThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedCS(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAtThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAtSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubString(pcSubStr)
		return This.SplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SplitAtSubStringQ(pcSubStr)
			return This.SplitAtSubStringQR(pcSubStr, :stzList)

		def SplitAtSubStringQR(pcSubStr, pcReturnType)
			return This.SplitAtSubStringCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def Split(pcSubStr)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubString(pcSubStr)

			def SplitQ(pcSubStr)
				return This.SplitQR(pcSubStr, :stzList)
	
			def SplitQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringQR(pcSubStr, pcReturnType)

		def SplitAtThisSubString(pcSubStr)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.SplitAtSubString(pcSubStr)

			def SplitAtThisSubStringQ(pcSubStr)
				return This.SplitAtThisSubStringQR(pcSubStr, :stzList)
	
			def SplitAtThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAtSubStringCSQR(pcSubStr, pcReturnType)

		#>

	def SplittedAtSubString(pcSubStr)
		return This.SplitAtSubString(pcSubStr)

		def Splitted(pcSubStr)
			return This.SplitAtSubString(pcSubStr)

		def SplittedAtThisSubString(pcSubStr)
			return This.SplittedAtSubString(pcSubStr)

	  #-----------------------------------#
	 #   SPLITTING AT GIVEN SUBSTRINGS   #
	#-----------------------------------#

	def SplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		acResult = This.SplitAtPositions(anPos)
		return acResult

		#< @FunctionFluentForm

		def SplitAtSubStringsCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSubStringsCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtTheseSubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtTheseSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def SplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAtManySubStringsCSQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsCSQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtManySubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAtSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SplitAtSubStrings(pacSubStr)
		return This.SplitAtSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SplitAtSubStringsQ(pcSubStr, pCaseSensitive)
			return This.SplitAtSubStringsQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAtSubStringsQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.SplitAtSubStringsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtTheseSubStringsQ(pcSubStr, pCaseSensitive)
				return This.SplitAtTheseSubStringsQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtTheseSubStringsQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)
	
		def SplitAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

			def SplitAtManySubStringsQ(pcSubStr, pCaseSensitive)
				return This.SplitAtManySubStringsQR(pcSubStr, pCaseSensitive, :stzList)
	
			def SplitAtManySubStringsQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAtSubStringsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

	def SplittedAtSubStrings(pacSubStr)
		return This.SplitAtSubStrings(pacSubStr)

		#< @FunctionAlternativeForms

		def SplittedAtTheseSubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		def SplittedAtManySubStrings(pacSubStr)
			return This.SplitAtSubStrings(pacSubStr)

		#>

	  #----------------------------------#
	 #   SPLITTING AT A GIVEN SECTION   #
	#==================================#

	def SplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionQ(n1, n2)
			return This.SplitAtSectionQR(n1, n2, :stzList)

		def SplitAtSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSection(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSection(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSection(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSection(n1, n2)
			return This.SplitAtSection(n1, n2)

			def SplitAtThisSectionQ(n1, n2)
				return This.SplitAtThisSectionQR(n1, n2, :stzList)

			def SplitAtThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAtSectionQR(n1, n2, pcReturnType)

		#>


	def SplittedAtSection(n1, n2)
		return This.SplitAtSection(n1, n2)

		def SplittedAtThisSection(n1, n2)
			return This.SplittedAtSection(n1, n2)

	  #-----------------------------------------------------#
	 #   SPLITTING AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-----------------------------------------------------#

	def SplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionIBQ(n1, n2)
			return This.SplitAtSectionIBQR(n1, n2, :stzList)

		def SplitAtSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

			def SplitAtThisSectionIBQ(n1, n2)
				return This.SplitAtThisSectionIBQR(n1, n2, :stzList)

			def SplitAtThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAtSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAtSectionIB(n1, n2)
		return This.SplitAtSectionIB(n1, n2)

		def SplittedAtThisSectionIB(n1, n2)
			return This.SplittedAtSectionIB(n1, n2)

	  #--------------------------------#
	 #   SPLITTING AT MANY SECTIONS   #
	#--------------------------------#

	def SplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSections(paSections)
		acResult = This.AntiSections( paSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsQ(n1, n2)
			return This.SplitAtSectionsQR(n1, n2, pcReturnType)

		def SplitAtSectionsQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSections(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSections(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSections(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSections(paSections)
			return This.SplitAtSections(paSections)

			def SplitAtTheseSectionsQ(paSections)
				return This.SplitAtTheseSectionsQR(paSections, :stzList)

			def SplitAtTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAtSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAtSections(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSections(paSections)
			return This.SplittedAtSections(paSections)

	  #---------------------------------------------------#
	 #   SPLITTING AT MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------#

	def SplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAtSectionsIB(paSections)
		acResult = This.AntiSections( paSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAtSectionsIBQ(n1, n2)
			return This.SplitAtSectionsIBQR(n1, n2, pcReturnType)

		def SplitAtSectionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtSectionsIB(n1, n2) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtSectionsIB(n1, n2) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitAtTheseSectionsIB(paSections)
			return This.SplitAtSectionsIB(paSections)

			def SplitAtTheseSectionsIBQ(paSections)
				return This.SplitAtTheseSectionsIBQR(paSections, :stzList)

			def SplitAtTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAtSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAtSectionsIB(paSections)
		return This.SplitAtSections(paSections)

		def SplittedAtTheseSectionsIB(paSections)
			return This.SplittedAtSections(paSections)

	  #----------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION OR SUBSTRING   #
	#----------------------------------------------------#

	def SplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.SplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.SplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.SplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.SplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.SplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.SplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitBeforeCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitBeforeCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBeforeCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitBeforeCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBefore(pSubStrOrPos)
		return This.SplitBeforeCS(pSubStrOrPos, :CaseSensitive = TRUE)

		def SplitBeforeQ(pSubStrOrPos)
			return This.SplitBeforeQR(pSubStrOrPos, :stzList)

		def SplitBeforeQR(pSubStrOrPos, pcReturnType)
			return This.SplitBeforeCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

	def SplittedBefore(pSubStrOrPos)
		return This.SplitBefore(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitBeforePosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforePositionQ(n)
			return This.SplitBeforePositionQR(n, :stzList)

		def SplitBeforePositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

			def SplitBeforeThisPositionQ(n)
				return This.SplitBeforeThisPositionQR(n, :stzList)

			def SplitBeforeThisPositionQR(n, pcReturnType)
				return This.SplitBeforePositionQR(n, pcReturnType)

		#>

	def SplittedBeforePosition(n)
		return This.SplitBeforePosition(n)

		def SplittedBeforeThisPosition(n)
			return This.SplitBeforePosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult			

		#< @FunctionFluentForms

		def SplitBeforePositionsQ(anPos)
			return This.SplitBeforePositionsQR(anPos, :stzList)

		def SplitBeforePositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforePositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforePositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforePositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeThesePositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeThesePositionsQ(anPos)
				return This.SplitBeforThesePositionsQR(anPos, :stzList)

			def SplitBeforeThesePositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		def SplitBeforeManyPositions(anPos)
			return This.SplitBeforePositions(anPos)

			def SplitBeforeManyPositionsQ(anPos)
				return This.SplitBeforeManyPositionsQR(anPos, :stzList)

			def SplitBeforeManyPositionsQR(anPos, pcReturnType)
				return This.SplitBeforePositionsQR(anPos, pcReturnType)

		#>

	def SplittedBeforePositions(anPos)
		return This.SplitBeforePositions(anPos)

		def SplittedBeforeThesePoitions(anPos)
			return This.SplittedBeforePositions(anPos)

		def SplittedBeforeManyPoitions(anPos)
			return This.SplittedBeforePositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

			def SplitBeforeThisSubStringCSQ(pcSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

			def SplitBeforeThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>
				
	def SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubString(pcSubStr)
		return This.SplitBeforeSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitBeforeSubStringQ(pcSubStr)
			return This.SplitBeforeSubStringQR(pcSubStr, :stzList)

		def SplitBeforeSubStringQR(pcSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubString(pcSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubString(pcSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSubString(pcSubStr)
			return This.SplitBeforeSubString(pcSubStr)

			def SplitBeforeThisSubStringQ(pcSubStr)
				return This.SplitBeforeThisSubStringQR(pcSubStr, :stzList)

			def SplitBeforeThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitBeforeSubStringQR(pcSubStr, pcReturnType)

		#>

	def SplittedBeforeSubString(pcSubStr)
		return This.SplitBeforeSubString(pcSubStr)

		def SplittedBeforeThisSubString(pcSubStr)
			return This.SplittedBeforeSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforePositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeThisSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBeforeManySubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBeforeManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitBeforeSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedBeforeSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionFluentForms

		def SplitBeforeSubStringsQ(pacSubStr)
			return This.SplitBeforeSubStringsQR(pacSubStr, :stzList)

		def SplitBeforeSubStringsQR(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubStringsCS(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeTheseSubStringsQ(pacSubStr)
				return This.SplitBeforeThisSubStringsQR(pacSubStr, :stzList)

			def SplitBeforeTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		def SplitBeforeManySubStrings(pacSubStr)
			return This.SplitBeforeSubStrings(pacSubStr)

			def SplitBeforeManySubStringsQ(pacSubStr)
				return This.SplitBeforeManySubStringsQR(pacSubStr, :stzList)

			def SplitBeforeManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitBeforeSubStringsQR(pacSubStr, pcReturnType)

		#>

	def SplittedBeforeSubStrings(pacSubStr)
		return This.SplitBeforeSubStrings(pacSubStr)

		def SplittedBeforeTheseSubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

		def SplittedBeforeManySubStrings(pacSubStr)
			return This.SplittedBeforeSubStrings(pacSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION   #
	#--------------------------------------#

	def SplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSection(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionQ(n1, n2)
			return This.SplitBeforeSectionQR(n1, n2, :stzList)

		def SplitBeforeSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSection(n1, n2)
			return This.SplitBeforeSection(n1, n2)

			def SplitBeforeThisSectionQ(n1, n2)
				return This.SplitBeforeThisSectionQR(n1, n2, :stzList)

			def SplitBeforeThisSectionQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionQR(n1, n2, pcReturnType)

		#>

	def SplittedBeforeSection(n1, n2)
		return This.SplitBeforeSection(n1, n2)

		def SplittedBeforeThisSection(n1, n2)
			return This.SplittedBeforeSection(n1, n2)

	  #--------------------------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------#

	def SplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIB(n1, n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionIBQ(n1, n2)
			return This.SplitBeforeSectionIBQR(n1, n2, :stzList)

		def SplitBeforeSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBeforeThisSectionIB(n1, n2)
			return This.SplitBeforeSectionIB(n1, n2)

			def SplitBeforeThisSectionIBQ(n1, n2)
				return This.SplitBeforeThisSectionIBQR(n1, n2, :stzList)

			def SplitBeforeThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitBeforeSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedBeforeSectionIB(n1, n2)
		return This.SplitBeforeSectionIB(n1, n2)

		def SplittedBeforeThisSectionIB(n1, n2)
			return This.SplittedBeforeSectionIB(n1, n2)

	  #------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS   #
	#------------------------------------#

	def SplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsQ(paSections)
			return This.SplitBeforeSectionsQR(paSections, :stzList)

		def SplitBeforeSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def SplitBeforeTheseSections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeTheseSectionsQ(paSections)
				return This.SplitBeforeThesesSectionsQR(paSections, :stzList)

			def SplitBeforeTheseSectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		def SplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

			def SplitBeforeManySectionsQ(paSections)
				return This.SplitBeforeTheseSectionsQR(paSections, :stzList)

			def SplitBeforeManySectionsQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsQR(paSections, pcReturnType)

		#>

	def SplittedBeforeSections(paSections)
		return This.SplitBeforeSections(paSections)

		def SplittedBeforeTheseSections(paSections)
			return This.SplittedBeforeSections(paSections)

		def SplittedBeforeManySections(paSections)
			return This.SplittedBeforeSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#------------------------------------------------------#

	def SplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitBeforeSectionsIBQ(paSections)
			return This.SplitBeforeSectionsIBQR(paSections, :stzList)

		def SplitBeforeSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeSubSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>


		#< @FunctionAlternativeForms

		def SplitBeforeTheseSectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeTheseSectionsIBQ(paSections)
				return This.SplitBeforeThesesSectionsIBQR(paSections, :stzList)

			def SplitBeforeTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		def SplitBeforeManySectionsIB(paSections)
			return This.SplitBeforeSectionsIB(paSections)

			def SplitBeforeManySectionsIBQ(paSections)
				return This.SplitBeforeTheseSectionsIBQR(paSections, :stzList)

			def SplitBeforeManySectionsIBQR(paSections, pcReturnType)
				return This.SplitBeforeSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedBeforeSectionsIB(paSections)
		return This.SplitBeforeSectionsIB(paSections)

		def SplittedBeforeTheseSectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

		def SplittedBeforeManySectionsIB(paSections)
			return This.SplittedBeforeSectionsIB(paSections)

	  #--------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN POSITION OR SUBSTRING  #
	#--------------------------------------------------#

	def SplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.SplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.SplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.SplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.SplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.SplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.SplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.SplitAfterSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.SplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.SplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.SplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.SplitAfterSections(pSubStrOrPos)


			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionFluentForms

		def SplitAfterCSQ(pSubStrOrPos, pCaseSensitive)
			return This.SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, :stzList)

		def SplitAfterCSQR(pSubStrOrPos, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterCS(pSubStrOrPos, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedAfterCS(pSubStrOrPos, pCaseSensitive)
		return This.SplitAfterCS(pSubStrOrPos, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfter(pSubStrOrPos)
		return This.SplitAfterCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SplitAfterQ(pSubStrOrPos)
			return This.SplitAfterQR(pSubStrOrPos, :stzList)

		def SplitAfterQR(pSubStrOrPos, pcReturnType)
			return This.SplitAfterCSQR(pSubStrOrPos, :CaseSensitive = TRUE, pcReturnType)

		#>

	def SplittedAfter(pSubStrOrPos)
		return This.SplitAfter(pSubStrOrPos)

	  #---------------------------------------#
	 #   SPLITTING BEFORE A GIVEN POSITION   #
	#---------------------------------------#

	def SplitAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPosition(n)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionQ(n)
			return This.SplitAfterPositionQR(n, :stzList)

		def SplitAfterPositionQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPosition(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPosition(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPosition(n) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisPosition(n)
			return This.SplitAfterPosition(n)

			def SplitAfterThisPositionQ(n)
				return This.SplitAfterThisPositionQR(n, :stzList)

			def SplitAfterThisPositionQR(n, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPosition(n)
		return This.SplitAfterPosition(n)

		def SplittedAfterThisPosition(n)
			return This.SplittedAfterPosition(n)

	  #-------------------------------------#
	 #   SPLITTING BEFORE MANY POSITIONS   #
	#-------------------------------------#

	def SplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterPositionsQ(anPos)
			return This.SplitAfterPositionsQR(anPos, :stzList)

		def SplitAfterPositionsQR(anPos, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterPositions(anPos) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterPositions(anPos) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterPositions(anPos) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThesePositions(anPos)
			return This.SplitAfterThesePositions(anPos)

			def SplitAfterThesePositionsQ(anPos)
				return This.SplitAfterThesePositionsQR(anPos, :stzList)

			def SplitAfterThesePositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		def SplitAfterManyPositions(anPos)
			return This.SplitAfterManyPositions(anPos)

			def SplitAfterManyPositionsQ(anPos)
				return This.SplitAfterManyPositionsQR(anPos, :stzList)

			def SplitAfterManyPositionsQR(anPos, pcReturnType)
				return This.SplitAfterPositionQR(n, pcReturnType)

		#>

	def SplittedAfterPositions(anPos)
		return This.SplitAfterPositions(anPos)

		def SplittedAfterThesePositions(anPos)
			return This.SplittedAfterPositions(anPos)

		def SplittedAfterManyPositions(anPos)
			return This.SplittedAfterPositions(anPos)

	  #----------------------------------------#
	 #   SPLITTING BEFORE A GIVEN SUBSTRING   #
	#----------------------------------------#

	def SplitAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

			def SplitAfterThisSubStringQCS(pcSubStr, pCaseSensitive)
				return This.SplitAfterThisSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)

			def SplitAfterThisSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)
		return This.SplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def SplittedAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubString(pcSubStr)
		return This.SplitAfterSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringQ(pcSubStr)
			return This.SplitAfterSubStringQR(pcSubStr)

		def SplitAfterSubStringQR(pcSubStr)
			return This.SplitAfterThisSubStringCSQR(pcSubStr, :pCaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSubString(pcSubStr)
			return This.SplitAfterSubString(pcSubStr)

			def SplitAfterThisSubStringQ(pcSubStr)
				return This.SplitAfterThisSubStringQR(pcSubStr, :stzList)

			def SplitAfterThisSubStringQR(pcSubStr, pcReturnType)
				return This.SplitAfterSubStringQR(pcSubStr, pcReturnType)

		#>

	def SplittedAfterSubString(pcSubStr)
		return This.SplitAfterSubString(pcSubStr)

		def SplittedAfterThisSubString(pcSubStr)
			return This.SplittedAfterSubString(pcSubStr)

	  #--------------------------------------#
	 #   SPLITTING BEFORE MANY SUBSTRINGS   #
	#--------------------------------------#

	def SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterPositions(anPos)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterTheseSubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterTheseSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		def SplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitAfterManySubStringsQCS(pacSubStr, pCaseSensitive)
				return This.SplitAfterManySubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitAfterManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
				return This.SplitAfterSubStringsCSQR(pacSubStr, pCaseSensitive)

		#>

	def SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)
		return This.SplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def SplittedAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplittedAfterSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitAfterSubStringsQ(pacSubStr)
			return This.SplitAfterSubStringsQR(pacSubStr, :stzList)

		def SplitAfterSubStringsQR(pacSubStr, pcReturnType)
			return This.SplitAfterSubStringsCSQR(pacSubStr, :CaseSensitive, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterTheseSubStringsQ(pacSubStr)
				return This.SplitAfterTheseSubStringsQR(pacSubStr, :stzList)

			def SplitAfterTheseSubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		def SplitAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

			def SplitAfterManySubStringsQ(pacSubStr)
				return This.SplitAfterManySubStringsQR(pacSubStr, :stzList)

			def SplitAfterManySubStringsQR(pacSubStr, pcReturnType)
				return This.SplitAfterSubStringsQR(pacSubStr, pcReturnType)

		#>

	def SplittedAfterSubStrings(pacSubStr)
		return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterTheseSubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

		def SplittedAfterManySubStrings(pacSubStr)
			return This.SplitAfterSubStrings(pacSubStr)

	  #-------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION   #
	#-------------------------------------#

	def SplitAfterSection(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSection(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionQ(n1, n2)
			return This.SplitAfterSectionQR(n1, n2)

		def SplitAfterSectionQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSection(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSection(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSection(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSection(n1, n2)
			return This.SplitAfterSection(n1, n2)

			def SplitAfterThisSectionQ(n1, n2)
				return This.SplitAfterThisSectionQR(n1, n2, :stzList)

			def SplitAfterThisSectionQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionQR(n1, n2, pcReturnType)

		#>

	def SplittedAfterSection(n1, n2)
		return This.SplitAfterSection(n1, n2)

		def SplittedAfterThisSection(n1, n2)
			return This.SplittedAfterSection(n1, n2)

	  #-------------------------------------------------------#
	 #   SPLITTING AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-------------------------------------------------------#

	def SplitAfterSectionIB(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionIB(n1 , n2)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionIBQ(n1, n2)
			return This.SplitAfterSectionIBQR(n1, n2, :stzList)

		def SplitAfterSectionIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterThisSectionIB(n1, n2)
			return This.SplitAfterSectionIB(n1, n2)

			def SplitAfterThisSectionIBQ(n1, n2)
				return This.SplitAfterThisSectionIBQR(n1, n2, :stzList)

			def SplitAfterThisSectionIBQR(n1, n2, pcReturnType)
				return This.SplitAfterSectionIBQR(n1, n2, pcReturnType)

		#>

	def SplittedAfterSectionIB(n1, n2)
		return This.SplitAfterSectionIB(n1, n2)

		def SplittedAfterThisSectionIB(n1, n2)
			return This.SplittedAfterSectionIB(n1, n2)

	  #-----------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS   #
	#-----------------------------------#

	def SplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSections(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsQ(paSections)
			return This.SplitAfterSectionsQR(paSections, :stzList)

		def SplitAfterSectionsQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSections(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSections(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSections(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSections(paSections)
			return This.SplitAfteSections(paSections)

			def SplitAfterTheseSectionsQ(paSections)
				return This.SplitAfterTheseSectionsQR(paSections, :stzList)

			def SplitAfterTheseSectionsQR(paSections, pcReturnType)
				return This.SplitAfterSectionsQR(paSections, pcReturnType)

		#>

	def SplittedAfterSections(paSections)
		return This.SplitAfterSections(paSections)

		def SplittedAfterTheseSections(paSections)
			return This.SplittedAfterSections(paSections)

	  #------------------------------------------------------#
	 #   SPLITTING AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------#

	def SplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aSections = StzSplitterQ( This.NumberOfChars() ).SplitAfterSectionsIB(paSections)
		acResult = This.Sections( aSections )

		return acResult

		#< @FunctionFluentForms

		def SplitAfterSectionsIBQ(paSections)
			return This.SplitAfterSectionsIBQR(paSections, :stzList)

		def SplitAfterSectionsIBQR(paSections, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterSectionsIB(paSections) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterSectionsIB(paSections) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitAfterTheseSectionsIB(paSections)
			return This.SplitAfteSectionsIB(paSections)

			def SplitAfterTheseSectionsIBQ(paSections)
				return This.SplitAfterTheseSectionsIBQR(paSections, :stzList)

			def SplitAfterTheseSectionsIBQR(paSections, pcReturnType)
				return This.SplitAfterSectionsIBQR(paSections, pcReturnType)

		#>

	def SplittedAfterSectionsIB(paSections)
		return This.SplitAfterSectionsIB(paSections)

		def SplittedAfterTheseSectionsIB(paSections)
			return This.SplittedAfterSectionsIB(paSections)

	  #-------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=================================================#

	def SplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSQR(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSQR(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCS(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCS(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetween(pBound1, pBound2)
		return This.SplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitBetweenQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenQR(Bound1, pBound2, :stzList)

		def SplitBetweenQR(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetween(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetween(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetween(pBound1, pBound2)
		return This.SplitBetween(pBound1, pBound2)

	  #---------------------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------#

	def SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aSections = StzSplitterQ( This.NumberOfChars() ).SplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)
		ok

		acResult = This.Sections(aSections)

		return acResult

		#< @FunctionFluentForms

		def SplitBetweenCSIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenCSIBQR(Bound1, pBound2, pCaseSensitive, :stzList)

		def SplitBetweenCSIBQR(Bound1, pBound2, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		return This.SplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenIB(pBound1, pBound2)
		return This.SplitBetweenCSIB(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitBetweenIBQ(Bound1, pBound2, pCaseSensitive)
			return This.SplitBetweenIBQR(Bound1, pBound2, :stzList)

		def SplitBetweenIBQR(Bound1, pBound2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenIB(pBound1, pBound2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenIB(pBound1, pBound2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

	def SplittedBetweenIB(pBound1, pBound2)
		return This.SplitBetweenIB(pBound1, pBound2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS   #
	#------------------------------------#

	def SplitBetweenPositions(n1, n2)
		This.SplitAtSection(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsQ(n1, n2)
			return This.SplitBetweenPositionsQR(n1, n2, :stzList)

		def SplitBetweenPositionsQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositions(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositions(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositions(n1, n2)
			return This.SplitBetweenPositions(n1, n2)

			def SplitBetweenThesePositionsQ(n1, n2)
				return This.SplitBetweenThesePositionsQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositions(n1, n2)
		return This.SplitBetweenPositions(n1, n2)

		def SplittedBetweenThesePositions(n1, n2)
			return This.SplittedBetweenPositions(n1, n2)

	  #-------------------------------------------------------#
	 #  SPLITTING BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------#

	def SplitBetweenPositionsIB(n1, n2)
		This.SplitAtSectionIB(n1, n2)

		#< @FunctionFluentForms

		def SplitBetweenPositionsIBQ(n1, n2)
			return This.SplitBetweenPositionsIBQR(n1, n2, :stzList)

		def SplitBetweenPositionsIBQR(n1, n2, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenPositionsIB(n1, n2) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenPositionsIB(n1, n2) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenThesePositionsIB(n1, n2)
			return This.SplitBetweenPositionsIB(n1, n2)

			def SplitBetweenThesePositionsIBQ(n1, n2)
				return This.SplitBetweenThesePositionsIBQR(n1, n2, :stzList)

			def SplitBetweenThesePositionsIBQR(n1, n2, pcReturnType)
				return This.SplitBetweenPositionsIBQR(n1, n2, pcReturnType)

		#>

	def SplittedBetweenPositionsIB(n1, n2)
		return This.SplitBetweenPositionsIB(n1, n2)

		def SplittedBetweenThesePositionsIB(n1, n2)
			return This.SplittedBetweenPositionsIB(n1, n2)

	  #------------------------------------#
	 #  SPLITTING BETWEEN TWO SUBSTRINGS  #
	#------------------------------------#

	def SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		acResult = This.SplitBetweenSections(aSections)
		return acResult

		#< @FunctionFluentForms

		def SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

		def SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.SplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

			def SplitBetweenTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				return This.SplitBetweenTheseSubStringsCSQR(pacSubStr, pCaseSensitive, :stzList)

			def SplitBetweenTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturntype)
				return This.SplitBetweenSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)

		#>

	def SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		acResult = This.Copy().SplitBetweenSubStringsCSQ(pacSubStr, pCaseSensitive).Content()
		return acResult

		def SplittedBetweenTheseSubStringsCs(pacSubStr, pCaseSensitive)
			return This.SplittedBetweenSubStringsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SplitBetweenSubStrings(pacSubStr)
		return This.SplitBetweenSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForms

		def SplitBetweenSubStringsQ(pacSubStr)
			return This.SplitBetweenSubStringsQR(pacSubStr, :stzList)

		def SplitBetweenSubStringsQR(pacSubStr, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBetweenSubStrings(pacSubStr) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitBetweenSubStrings(pacSubStr) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitBetweenTheseSubStrings(pacSubStr)
			return This.SplitBetweenSubStrings(pacSubStr)

			def SplitBetweenTheseSubStringsQ(pacSubStr)
				return This.SplitBetweenTheseSubStringsQR(pacSubStr, :stzList)

			def SplitBetweenTheseSubStringsQR(pacSubStr, pcReturntype)
				return This.SplitBetweenSubStringsQR(pacSubStr, pcReturnType)

		#>


	def SplittedBetweenSubStrings(pacSubStr)
		return This.SplittedBetweenSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		def SplittedBetweenTheseSubStrings(pacSubStr)
			return This.SplittedBetweenSubStrings(pacSubStr)

	  #----------------------------#
	 #    SPLITTING TO N PARTS    #
	#============================#

	def SplitToNParts(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToNParts(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToNPartsQ(n)
			return This.SplitToNPartsQR(n, :stzList)

		def SplitToNPartsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToNParts(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToNParts(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToNParts(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToNParts(n)
		return This.SplitToNParts(n)

	  #---------------------------------------------#
	 #   SPLITTING TO PARTS OF (EXACTLY) N CHARS   #
	#---------------------------------------------#
	# Remaining part less the n chars is not returned

	def SplitToPartsOfNChars(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfExactlyNPositions(n)

		aResult = This.Sections( aSections )
		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsQ(n)
			return This.SplitToPartsOfNCharsQR(n, :stzList)

		def SplitToPartsOfNCharsQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNChars(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNChars(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNChars(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForm

		def SplitToPartsOfExactlyNChars(n)
			return This.SplitToPartsOfNChars(n)

			def SplitToPartsOfExactlyNCharsQ(n)
				return This.SplitToPartsOfExactlyNCharsQR(n, :stzList)

			def SplitToPartsOfExactlyNCharsQR(n, pcReturnType)
				return This.SplitToPartsOfNCharsQR(n, pcReturnType)

		#>

	def SplittedToPartsOfNChars(n)
		return This.SplitToPartsOfNChars(n)

		def SplittedToPartsOfExactlyNChars(n)
			return This.return This.SplitToPartsOfNChars(n)

	  #----------------------------------------------#
	 #   SPLITTING TO PARTS OF N CHARS -- EXTENDED  #
	#----------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def SplitToPartsOfNCharsXT(n)
		aSections = StzSplitterQ( This.NumberOfChars() ).
				SplitToPartsOfNPositions(n)

		aResult = This.Sections(aSections)

		return aResult

		#< @FunctionFluentForms

		def SplitToPartsOfNCharsXTQ(n)
			return This.SplitToPartsOfNCharsXTQR(n, :stzList)

		def SplitToPartsOfNCharsXTQR(n, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfStrings
				return new stzListOfStrings( This.SplitToPartsOfNCharsXT(n) )

			on :stzListOfChars
				return new stzListOfChars( This.SplitToPartsOfNCharsXT(n) )

			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedToPartsOfNCharsXT(n)
		return This.SplitToPartsOfNCharsXT(n)

		def SplittedToPartsOfExactlyNCharsXT(n)
			return This.return This.SplitToPartsOfNCharsXT(n)

	  #---------------------------------------#
	 #    SPLITTING UNDER A GIVEN CONDTION   #
	#=======================================#

	def SplitW(pcCondition)
		/*
		? StzSplitterQ(1:5).SplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.SplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.SplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.SplitAfterW(pcCondition[2])

			ok
		
		else

			return This.SplitAtW(pcCondition)
		ok

		#< @FunctionFluentForms

		def SplitWQ(pcCondition)
			return This.SplitWQR(pcCondition, :stzList)

		def SplitWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitW(pcCondition) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedW(pcConditon)
		return This.SplitW(pcCondition)

	  #------------------------------------#
	 #    SPLITTING AT A GIVEN CONDTION   #
	#------------------------------------#

	def SplitAtW(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.SplitAtSections(aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.SplitAtPositions(anPositions)
		ok

		return aResult

		#< @FunctionFluentForms

		def SplitAtWQ(pcCondition)
			return This.SplitAtWQR(pcCondition, :stzList)

		def SplitAtWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAtW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAtW(pcCondition) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAtW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAtW(pcConditon)
		return This.SplitAtW(pcCondition)

	  #----------------------------------------#
	 #    SPLITTING BEFORE A GIVEN CONDTION   #
	#----------------------------------------#

	def SplitBeforeW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.SplitBeforePositions(anPositions)

		return aResult

		#< @FunctionFluentForms

		def SplitBeforeWQ(pcCondition)
			return This.SplitBeforeWQR(pcCondition, :stzList)

		def SplitBeforeWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitBeforeW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitBeforeW(pcCondition) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitBeforeW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedBeforeW(pcConditon)
		return This.SplitBeforeW(pcCondition)

	  #---------------------------------------#
	 #    SPLITTING AFTER A GIVEN CONDTION   #
	#---------------------------------------#

	def SplitAfterW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.SplitAfterPositions(anPositions)

		return aResult

		#< @FunctionFluentForms

		def SplitAfterWQ(pcCondition)
			return This.SplitAfterWQR(pcCondition, :stzList)

		def SplitAfterWQR(pcCondition, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.SplitAfterW(pcCondition) )
			on :stzListOfStrings
				return new stzListOfStrings( This.SplitAfterW(pcCondition) )
			on :stzListOfChars
				return new stzListOfChars( This.SplitAfterW(pcCondition) )
			other
				StzRaise("Unsupported return type!")
			off

		#>

	def SplittedAfterW(pcConditon)
		return This.SplitAfterW(pcCondition)

	  #----------------------------------------------------------------#
	 #  NTH SUBSTRING AFTER SPLITTING STRING USING A GIVEN SEPARATOR  #
	#================================================================#
	# Utility function used to simplify code in stzListOfStrings

	def NthSubstringAfterSplittingStringUsing(n, cSep)
	# TODO: Remake it using FindNthSplitZZ(n)

		return This.Split(cSep)[n]

		def NthSplit(n, cSep)
			return This.NthSubstringAfterSplittingStringUsing(n, cSep)

	  #========================#
	 #   FINDING THE SPLITS   #
	#========================#

	def FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtW(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindSplitsBeforeW(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindSplitsAfterW(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXT(pSubStrOrPos)
		return This.FindSplitsCSXT(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsXTZ(pSubStrOrPos)
			return This.FindSplitsXT(pSubStrOrPos)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================#

	def FindSplitsAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplits(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAt(pSubStrOrPos)
		return This.FindSplitsAtCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtZ(pSubStrOrPos)
			return This.FindSplitsAtCS(pSubStr)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN POSITION   #
	#========================================#

	def FindSplitsAtPosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtPosition(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPosition(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtPositionZ(n)
			return This.FindSplitsAtPosition(n)

		def FindSplitsAtThisPositionZ(n)
			return This.FindSplitsAtPosition(n)

		#>

	  #--------------------------------------#
	 #   FINDING SPLITS AT MANY POSITIONS   #
	#--------------------------------------#

	def FindSplitsAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositions(anPos)
			return This.FindSplitsAtPositions(anPos)

		#--

		def FindSplitsAtPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtThesePositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		def FindSplitsAtManyPositionsZ(anPos)
			return This.FindSplitsAtPositions(anPos)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SUBSTRING   #
	#=========================================#

	def FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSections(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubString(pcSubStr)
		return This.FindSplitsAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplits(pcSubStr)
			return This.FindSplitsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsAtThisSubString(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindSplitsAtSubStringZ(pcSubStr)
			return This.FindSplitsAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsZ(pcSubStr)
			return This.FindSplitsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsAtThisSubStringZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AT GIVEN SUBSTRINGS   #
	#----------------------------------------#

	def FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindSplitsAtPositions(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStrings(pacSubStr)
		return This.FindSplitsAtSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)
	
		def FindSplitsAtManySubStrings(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#--

		def FindSplitsAtSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		def FindSplitsAtManySubStringsZ(pacSubStr)
			return This.FindSplitsAtSubStrings(pacSubStr)

		#>

	  #---------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION   #
	#=======================================#

	def FindSplitsAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSection(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#--

		def FindSplitsAtSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		def FindSplitsAtThisSectionZ(n1, n2)
			return This.FindSplitsAtSection(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#----------------------------------------------------------#

	def FindSplitsAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindSplitsAtSectionIBZ(n1, n2)
			return This.FindSplitsAtSectionIB(n1, n2)

		def FindSplitsAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS   #
	#-------------------------------------#

	def FindSplitsAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSections(paSections)
			return This.FindSplitsAtSections(paSections)

		#--

		def FindSplitsAtSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		def FindSplitsAtTheseSectionsZ(paSections)
			return This.FindSplitsAtSections(paSections)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS AT MANY SECTIONS -- BOUNDS INCLUDED   #
	#--------------------------------------------------------#

	def FindSplitsAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsIB(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#--

		def FindSplitsAtSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		def FindSplitsAtTheseSectionsIBZ(paSections)
			return This.FindSplitsAtSectionsIB(paSections)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION OR SUBSTRING   #
	#---------------------------------------------------------#

	def FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBefore(pSubStrOrPos)
		return This.FindSplitsBeforeCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeZ(pSubStrOrPos)
			return This.FindSplitsBefore(pSubStrOrPos)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsBeforePosition(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePosition(n)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPosition(n)
			return This.FindSplitsBeforePosition(n)

		#--

		def FindSplitsBeforePositionZ(n)
			return This.FindSplitsBeforePosition(n)

		def FindSplitsBeforeThisPositionZ(n)
			return This.FindSplitsBeforePosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositions(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#--

		def FindSplitsBeforePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeThesePositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		def FindSplitsBeforeManyPositionsZ(anPos)
			return This.FindSplitsBeforePositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubString(pcSubStr)
		return This.FindSplitsBeforeSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubString(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		def FindSplitsBeforeThisSubStringZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)	

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositions(anPos)

		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStrings(pacSubStr)
		return This.FindSplitsBeforeSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStrings(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		def FindSplitsBeforeManySubStringsZ(pacSubStr)
			return This.FindSplitsBeforeSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION   #
	#-------------------------------------------#

	def FindSplitsBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSection(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#--

		def FindSplitsBeforeSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		def FindSplitsBeforeThisSectionZ(n1, n2)
			return This.FindSplitsBeforeSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------#

	def FindSplitsBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIB(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#--

		def FindSplitsBeforeSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		def FindSplitsBeforeThisSectionIBZ(n1, n2)
			return This.FindSplitsBeforeSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS   #
	#-----------------------------------------#

	def FindSplitsBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSections(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindSplitsBeforeSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeTheseSectionsZ(paSections)
			return This.FindSplitsBeforeSections(paSections)

		def FindSplitsBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionsIB(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#--

		def FindSplitsBeforeSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeTheseSectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		def FindSplitsBeforeManySectionsIBZ(paSections)
			return This.FindSplitsBeforeSectionsIB(paSections)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------#

	def FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSection(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindSplitsAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindSplitsAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfter(pSubStrOrPos)
		return This.FindSplitsAfterCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterZ(pSubStrOrPos)
			return This.FindSplitsAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN POSITION   #
	#--------------------------------------------#

	def FindSplitsAfterPosition(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPosition(n)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPosition(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		def FindSplitsAfterThisPositionZ(n)
			return This.FindSplitsAfterPosition(n)

		#>

	  #------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY POSITIONS   #
	#------------------------------------------#

	def FindSplitsAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositions(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositions(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#--

		def FindSplitsAfterPositionsZ(anPos)
			return This.FindSplitsAfterPositions(anPos)

		def FindSplitsAfterThesePositionsZ(anPos)
			return This.FindSplitsAfterThesePositions(anPos)

		def FindSplitsAfterManyPositionsZ(anPos)
			return This.FindSplitsAfterManyPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------#

	def FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubString(pcSubStr)
		return This.FindSplitsAfterSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubString(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#--

		def FindSplitsAfterSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		def FindSplitsAfterThisSubStringZ(pcSubStr)
			return This.FindSplitsAfterSubString(pcSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------#

	def FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositions(anPos)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStrings(pacSubStr)
		return This.FindSplitsAfterSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStrings(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#--

		def FindSplitsAfterSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterTheseSubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		def FindSplitsAfterManySubStringsZ(pacSubStr)
			return This.FindSplitsAfterSubStrings(pacSubStr)

		#>

	  #-----------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION  #
	#-----------------------------------------#

	def FindSplitsAfterSection(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSection(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSection(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#--

		def FindSplitsAfterSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		def FindSplitsAfterThisSectionZ(n1, n2)
			return This.FindSplitsAfterSection(n1, n2)

		#>

	  #------------------------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------#

	def FindSplitsAfterSectionIB(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionIB(n1 , n2)
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIB(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		#--

		def FindSplitsAfterSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)

		def FindSplitsAfterThisSectionIBZ(n1, n2)
			return This.FindSplitsAfterSectionIB(n1, n2)


		#>

	  #----------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS   #
	#----------------------------------------#

	def FindSplitsAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSections(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSections(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#--

		def FindSplitsAfterSectionsZ(paSections)
			return This.FindSplitsAfterSections(paSections)

		def FindSplitsAfterTheseSectionsZ(paSections)
			return This.FindSplitsAfterTheseSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------#

	def FindSplitsAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionsIB(paSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#--

		def FindSplitsAfterSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		def FindSplitsAfterTheseSectionsIBZ(paSections)
			return This.FindSplitsAfterSectionsIB(paSections)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================#

	def FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok
		
		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetween(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenZ(pBound1, pBound2)
			return This.FindSplitsBetween(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			anResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIB(pBound1, pBound2)
		return This.FindSplitsBetweenCSIB(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenIBZ(pBound1, pBound2)
			return This.FindSplitsBetweenIB(pBound1, pBound2)

		#>

	  #----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS  #
	#----------------------------------------#

	def FindSplitsBetweenPositions(n1, n2)
		This.FindSplitsAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositions(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#--

		def FindSplitsBetweenPositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		def FindSplitsBetweenThesePositionsZ(n1, n2)
			return This.FindSplitsBetweenPositions(n1, n2)

		#>
		
	  #------------------------------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------#

	def FindSplitsBetweenPositionsIB(n1, n2)
		This.FindSplitsAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#--

		def FindSplitsBetweenPositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		def FindSplitsBetweenThesePositionsIBZ(n1, n2)
			return This.FindSplitsBetweenPositionsIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #  FINDING SPLITS BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------#

	def FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		anResult = This.FindSplitsBetweenSections(aSections)
		return anResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStrings(pacSubStr)
		return This.FindSplitsBetweenSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStrings(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		def FindSplitsBetweenTheseSubStringsZ(pacSubStr)
			return This.FindSplitsBetweenSubStrings(pacSubStr)

		#>

	  #---------------------------------#
	 #    FINDING SPLITS TO N PARTS    #
	#=================================#

	def FindSplitsToNParts(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsToNParts(n)
		return anResult

		def FindSplitsToNPartsZ(n)
			return This.FindSplitsToNParts(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNChars(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfExactlyNPositions(n)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNChars(n)
			return This.FindSplitsToPartsOfNChars(n)

		#--

		def FindSplitsToPartsOfNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		def FindSplitsToPartsOfExactlyNCharsZ(n)
			return This.FindSplitsToPartsOfNChars(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF N CHARS -- EXTENDED   #
	#----------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsXT(n)
		anResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfNPositionsXT(n)

		return anResult

		def FindSplitsToPartsOfNCharsXTZ(n)
			return This.FindSplitsToPartsOfNCharsXT(n)

	  #-------------------------------------------#
	 #   FINDING SPLITS UNDER A GIVEN CONDTION   #
	#===========================================#

	def FindSplitsW(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindSplitsAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindSplitsBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindSplitsAfterW(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsWZ(pcCondition)
			return This.FindSplitsWZ(pcCondition)

		#>

	  #-----------------------------------------#
	 #   FINSING SPLITS  AT A GIVEN CONDTION   #
	#-----------------------------------------#

	def FindSplitsAtW(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsW(pcCondition)
			anResult = This.FindSplitsAtSectionsZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			anResult = This.FindSplitsAtPositionsZ(anPositions)
		ok

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAtWZ(pcCondition)
			return This.FindSplitsAtW(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINDING SPLITS BEFORE A GIVEN CONDTION   #
	#--------------------------------------------#

	def FindSplitsBeforeW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		anResult = This.FindSplitsBeforePositions(anPositions)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeWZ(pcCondition)
			return This.FindSplitsBeforeW(pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINDING SPLITS AFTER A GIVEN CONDTION   #
	#-------------------------------------------#

	def FindSplitsAfterW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		anResult = This.FindSplitsAfterPositions(anPositions)

		return anResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterWZ(pcCondition)
			return This.FindSplitsAfterW(pcCondition)

		#>

	  #==================================================#
	 #   FINDING THE SPLITS AS SECTIONS -- ZZ/EXTENDED  #
	#==================================================#

	def FindSplitsCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindSplitsAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindSplitsBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindSplitsAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindSplitsBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindSplitsBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindSplitsBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindSplitsToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindSplitsToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindSplitsAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindSplitsBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindSplitsAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAsSectionsCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsXTZZ(pSubStrOrPos)
		return This.FindSplitsCSXTZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsAsSectionsXT(pSubStrOrPos)
			return This.FindSplitsAsSectionsXTZZ(pSubStrOrPos)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING OR POSITION  #
	#==================================================================#

	def FindSplitsAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtZZ(pSubStrOrPos)
		return This.FindSplitsAtCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSections(pSubStrOrPos)
			return This.FindSplitsAtCSZZ(pSubStr)

		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN POSITION   #
	#======================================================#

	def FindSplitsAtPositionZZ(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtPositionZZ(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisPositionAsSections(n)
			return This.FindSplitsAtPositionZZ(n)

		#>

	  #----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY POSITIONS   #
	#----------------------------------------------------#

	def FindSplitsAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindSplitsAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtThesePositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsZZ(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#--

		def FindSplitsAtPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtThesePositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		def FindSplitsAtManyPositionsAsSections(anPos)
			return This.FindSplitsAtPositionsZZ(anPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SUBSTRING   #
	#=======================================================#

	def FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindSplitsAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringZZ(pcSubStr)
		return This.FindSplitsAtSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsZZ(pcSubStr)
			return This.FindSplitsCSZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsAtThisSubStringZZ(pcSubStr)
			return This.FindSplitsAtThisSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindSplitsAtSubStringAsSectionsZZ(pcSubStr)
			return This.FindSplitsAtSubStringAsSectionsCSZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsAsSections(pcSubStr)
			return This.FindSplitsAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSplitsAtThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAtThisSubStringAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		#>


	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT GIVEN SUBSTRINGS   #
	#------------------------------------------------------#

	def FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindSplitsAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAtSubStringsZZ(pacSubStr)
		return This.FindSplitsAtSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)
	
		def FindSplitsAtManySubStringsZZ(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAtSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		def FindSplitsAtManySubStringsAsSections(pacSubStr)
			return This.FindSplitsAtSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION   #
	#=====================================================#

	def FindSplitsAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionZZ(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		def FindSplitsAtThisSectionAsSections(n1, n2)
			return This.FindSplitsAtSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------#

	def FindSplitsAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindSplitsAtSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAtSectionIBZZ(n1, n2)

		def FindSplitsAtThisSectionAsSectionsIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AT MANY SECTIONS   #
	#---------------------------------------------------#

	def FindSplitsAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAtTheseSectionsZZ(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#--

		def FindSplitsAtSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		def FindSplitsAtTheseSectionsAsSections(paSections)
			return This.FindSplitsAtSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-----------------------------------------------------------------------#

	def FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindSplitsBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindSplitsBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeZZ(pSubStrOrPos)
		return This.FindSplitsBeforeCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBeforeAsSections(pSubStrOrPos)
			return This.FindSplitsBeforeZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsBeforePositionZZ(n)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositionZZ(n)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThisPositionZZ(n)
			return This.FindSplitsBeforePositionZZ(n)

		#--

		def FindSplitsBeforePositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		def FindSplitsBeforeThisPositionAsSections(n)
			return This.FindSplitsBeforePositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindSplitsBeforeThesePositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsZZ(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#--

		def FindSplitsBeforePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeThesePositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		def FindSplitsBeforeManyPositionsAsSections(anPos)
			return This.FindSplitsBeforePositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringZZ(pcSubStr)
		return This.FindSplitsBeforeSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSubStringZZ(pcSubStr)
			return This.FindSplitsBeforeSubString(pcSubStr)

		#--

		def FindSplitsBeforeSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)

		def FindSplitsBeforeThisSubStringAsSections(pcSubStr)
			return This.FindSplitsBeforeSubStringZZ(pcSubStr)	

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBeforeSubStringsZZ(pacSubStr)
		return This.FindSplitsBeforeSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsZZ(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBeforeSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		def FindSplitsBeforeManySubStringsAsSections(pacSubStr)
			return This.FindSplitsBeforeSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION   #
	#---------------------------------------------------------#

	def FindSplitsBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionZZ(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSections(n1, n2)
			return This.FindSplitsBeforeSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------------------#

	def FindSplitsBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeThisSectionIBZZ(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#--

		def FindSplitsBeforeSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		def FindSplitsBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsBeforeSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindSplitsBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsZZ(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSections(paSections)
			return This.FindSplitsBeforeSectionsZZ(paSections)

		def FindSplitsBeforeManySectionsAsSections(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#------------------------------------------------------------------------#

	def FindSplitsBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBeforeTheseSectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsIBZZ(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#--

		def FindSplitsBeforeSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		def FindSplitsBeforeManySectionsAsSectionsIB(paSections)
			return This.FindSplitsBeforeSectionsIBZZ(paSections)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN POSITION OR SUBSTRING  #
	#---------------------------------------------------------------------#

	def FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindSplitsAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindSplitsAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindSplitsAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindSplitsAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindSplitsAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindSplitsAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindSplitsAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindSplitsAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsCS(pSubStrOrPos, pCaseSensitive)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterZZ(pSubStrOrPos)
		return This.FindSplitsAfterCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSections(pSubStrOrPos)
			return This.FindSplitsAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN POSITION   #
	#----------------------------------------------------------#

	def FindSplitsAfterPositionZZ(n)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositionZZ(n)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisPositionZZ(n)
			return This.FindSplitsAfterPositionZZ(n)

		def FindSplitsAfterThisPositionAsSections(n)
			return This.FindSplitsAfterPositionZZ(n)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY POSITIONS   #
	#--------------------------------------------------------#

	def FindSplitsAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThesePositionsZZ(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsZZ(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#--

		def FindSplitsAfterPositionsAsSections(anPos)
			return This.FindSplitsAfterPositionsZZ(anPos)

		def FindSplitsAfterThesePositionsAsSections(anPos)
			return This.FindSplitsAfterThesePositionsZZ(anPos)

		def FindSplitsAfterManyPositionsAsSections(anPos)
			return This.FindSplitsAfterManyPositionsZZ(anPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN SUBSTRING   #
	#-----------------------------------------------------------#

	def FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindSplitsAfterThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringZZ(pcSubStr)
		return This.FindSplitsAfterSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSubStringZZ(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#--

		def FindSplitsAfterSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		def FindSplitsAfterThisSubStringAsSections(pcSubStr)
			return This.FindSplitsAfterSubStringZZ(pcSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) BEFORE MANY SUBSTRINGS   #
	#---------------------------------------------------------#

	def FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsAfterSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsAfterManySubStringsAsSectionsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsAfterSubStringsZZ(pacSubStr)
		return This.FindSplitsAfterSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsAfterTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#--

		def FindSplitsAfterSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		def FindSplitsAfterManySubStringsAsSectionsZZ(pacSubStr)
			return This.FindSplitsAfterSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION   #
	#--------------------------------------------------------#

	def FindSplitsAfterSectionZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionZZ(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSections(n1, n2)
			return This.FindSplitsAfterSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindSplitsAfterSectionIBZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterThisSectionIBZZ(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		#--

		def FindSplitsAfterSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)

		def FindSplitsAfterThisSectionAsSectionsIB(n1, n2)
			return This.FindSplitsAfterSectionIBZZ(n1, n2)


		#>

	  #------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS   #
	#------------------------------------------------------#

	def FindSplitsAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsZZ(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSections(paSections)
			return This.FindSplitsAfterSectionsZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSections(paSections)
			return This.FindSplitsAfterTheseSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------#

	def FindSplitsAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsAfterTheseSectionsIBZZ(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#--

		def FindSplitsAfterSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		def FindSplitsAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindSplitsAfterSectionsIBZZ(paSections)

		#>

	  #--------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#====================================================================#

	def FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCS(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSections(pBound1, pBound2)
			return This.FindSplitsBetweenZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------------------#

	def FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindSplitsBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenIBZZ(pBound1, pBound2)
		return This.FindSplitsBetweenCSIBZZ(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindSplitsBetweenAsSectionsIB(pBound1, pBound2)
			return This.FindSplitsBetweenIBZZ(pBound1, pBound2)

		#>

	  #------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS  #
	#------------------------------------------------------#

	def FindSplitsBetweenPositionsZZ(n1, n2)
		This.FindSplitsAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsZZ(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSections(n1, n2)
			return This.FindSplitsBetweenPositionsZZ(n1, n2)

		#>
		
	  #--------------------------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindSplitsBetweenPositionsIBZZ(n1, n2)
		This.FindSplitsAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenThesePositionsIBZZ(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#--

		def FindSplitsBetweenPositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		def FindSplitsBetweenThesePositionsAsSectionsIB(n1, n2)
			return This.FindSplitsBetweenPositionsIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #  FINDING SPLITS (AS SECTIONS) BETWEEN TWO SUBSTRINGS  #
	#-------------------------------------------------------#

	def FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindSplitsBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindSplitsBetweenSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindSplitsBetweenTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindSplitsBetweenSubStringsZZ(pacSubStr)
		return This.FindSplitsBetweenSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindSplitsBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#--

		def FindSplitsBetweenSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		def FindSplitsBetweenTheseSubStringsAsSections(pacSubStr)
			return This.FindSplitsBetweenSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) TO N PARTS    #
	#===============================================#

	def FindSplitsToNPartsZZ(n)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindSplitsToNPartsZZ(n)
		return aResult

		def FindSplitsToNPartsAsSections(n)
			return This.FindSplitsToNPartsZZ(n)

	  #--------------------------------------------------#
	 #   FINDING SPLITS TO PARTS OF (EXACTLY) N CHARS   #
	#--------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindSplitsToPartsOfNCharsZZ(n)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfExactlyNPositionsZZ(n)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfExactlyNCharsZZ(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#--

		def FindSplitsToPartsOfNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		def FindSplitsToPartsOfExactlyNCharsAsSections(n)
			return This.FindSplitsToPartsOfNCharsZZ(n)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING SPLITS (AS SECTIONS) TO PARTS OF N CHARS -- EXTENDED   #
	#------------------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindSplitsToPartsOfNCharsXTZZ(n)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindSplitsToPartsOfNPositionsXTZZ(n)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsToPartsOfNCharsAsSectionsXT(n)
			return This.FindSplitsToPartsOfNCharsXTZZ(n)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) UNDER A GIVEN CONDTION   #
	#==========================================================#

	def FindSplitsWZZ(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindSplitsAtWZZ(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindSplitsAtWZZ(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindSplitsBeforeWZZ(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindSplitsAfterWZZ(pcCondition[2])

			ok
		
		else

			return This.FindSplitsAtWZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindSplitsAsSectionsW(pcCondition)
			return This.FindSplitsWZZ(pcCondition)

		#>

	  #-------------------------------------------------------#
	 #    FINSING SPLITS (AS SECTIONS) AT A GIVEN CONDTION   #
	#-------------------------------------------------------#

	def FindSplitsAtWZZ(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.FindSplitsAtSectionsZZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.FindSplitsAtPositionsZZ(anPositions)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAtAsSectiosnW(pcCondition)
			return This.FindSplitsAtWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#-----------------------------------------------------------#

	def FindSplitsBeforeWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindSplitsBeforePositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsBeforeAsSectionsW(pcCondition)
			return This.FindSplitsBeforeWZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINDING SPLITS (AS SECTIONS) AFTER A GIVEN CONDTION   #
	#----------------------------------------------------------#

	def FindSplitsAfterWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindSplitsAfterPositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindSplitsAfterAsSectionsW(pcCondition)
			return This.FindSplitsAfterWZZ(pcCondition)

		#>

	  #===========================#
	 #   FINDING THE NTH SPLIT   #
	#===========================#

	def FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositions(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSection(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSections(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSections(n, pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSection(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSections(n, pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSection(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSections(n, pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositions(n, pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCS(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNParts(n, pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNChars(n, pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtW(n, pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeW(n, pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterW(n, pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXT(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXT(n, pSubStrOrPos)
		return This.FindNthSplitCSXT(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitXTZ(n, pSubStrOrPos)
			return This.FindNthSplitXT(n, pSubStrOrPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#=======================================================#

	def FindNthSplitAtCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositions(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSection(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplit(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPosition(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositions(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSection(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSections(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCS(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAt(n, pSubStrOrPos)
		return This.FindNthSplitAtCS(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtZ(n, pSubStrOrPos)
			return This.FindNthSplitAtCS(n, pSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN POSITION   #
	#===========================================#

	def FindNthSplitAtPosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n, nPos)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPosition(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		def FindNthSplitAtThisPositionZ(n, nPos)
			return This.FindNthSplitAtPosition(n, nPos)

		#>

	  #-----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY POSITIONS   #
	#-----------------------------------------#

	def FindNthSplitAtPositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfChars()).FindNthSplitAtPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositions(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#--

		def FindNthSplitAtPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtThesePositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		def FindNthSplitAtManyPositionsZ(n, anPos)
			return This.FindNthSplitAtPositions(n, anPos)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SUBSTRING   #
	#============================================#

	def FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCS(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubString(n, pcSubStr)
		return This.FindNthSplitAtSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplit(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitAtThisSubString(n, pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindNthSplitAtSubStringZ(n, pcSubStr)
			return This.FindNthSplitAtSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitZ(n, pcSubStr)
			return This.FindNthSplitCS(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitAtThisSubStringZ(pcSubStr)
			return This.FindNthSplitAtThisSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)

		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AT GIVEN SUBSTRINGS   #
	#-------------------------------------------#

	def FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)
		nResult = This.FindNthSplitAtPositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStrings(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCS(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)
	
		def FindNthSplitAtManySubStrings(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		def FindNthSplitAtManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAtSubStrings(n, pacSubStr)

		#>

	  #------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION   #
	#==========================================#

	def FindNthSplitAtSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSection(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSection(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#--

		def FindNthSplitAtSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		def FindNthSplitAtThisSectionZ(n, n1, n2)
			return This.FindNthSplitAtSection(n, n1, n2)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------#

	def FindNthSplitAtSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionIB(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIB(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#--

		def FindNthSplitAtSectionIBZ(n, n1, n2)
			return This.FindNthSplitAtSectionIB(n, n1, n2)

		def FindNthSplitAtThisSectionIBZ(n, n1, n2)
			return This.SplitAtSectionIB(n, n1, n2)

		#>

	  #----------------------------------------#
	 #   FINDING NTH SPLIT AT MANY SECTIONS   #
	#----------------------------------------#

	def FindNthSplitAtSections(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSections(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#--

		def FindNthSplitAtSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		def FindNthSplitAtTheseSectionsZ(n, paSections)
			return This.FindNthSplitAtSections(n, paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------#

	def FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositions(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSection(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSections(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePosition(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositions(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSection(n, pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSections(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBefore(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCS(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeZ(n, pSubStrOrPos)
			return This.FindNthSplitBefore(n, pSubStrOrPos)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitBeforePosition(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePosition(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPosition(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#--

		def FindNthSplitBeforePositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		def FindNthSplitBeforeThisPositionZ(n, nPos)
			return This.FindNthSplitBeforePosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitBeforePositions(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositions(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#--

		def FindNthSplitBeforePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeThesePositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		def FindNthSplitBeforeManyPositionsZ(n, anPos)
			return This.FindNthSplitBeforePositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubString(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubString(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)	

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositions(n, anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStrings(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCS(n, pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStrings(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStrings(n, pacSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION   #
	#----------------------------------------------#

	def FindNthSplitBeforeSection(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSection(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSection(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		def FindNthSplitBeforeThisSectionZ(n, n1, n2)
			return This.FindNthSplitBeforeSection(n, n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-----------------------------------------------------------------#

	def FindNthSplitBeforeSectionIB(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIB(n, n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		def FindNthSplitBeforeThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SECTIONS   #
	#--------------------------------------------#

	def FindNthSplitBeforeSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSections(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSections(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySections(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#--

		def FindNthSplitBeforeSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeTheseSectionsZ(n, paSections)
			return This.FindNthSplitBeforeSections(n, paSections)

		def FindNthSplitBeforeManySectionsZ(n, paSections)
			return This.SplitBeforeSections(n, paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINING NTH SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIB(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIB(paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#--

		def FindNthSplitBeforeSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		def FindNthSplitBeforeManySectionsIBZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIB(n, paSections)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#----------------------------------------------------------#

	def FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPosition(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPosition(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCS(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCS(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSection(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSections(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindNthSplitAfterPositions(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindNthSplitAfterSubStrings(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSections(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterCSZ(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfter(n, pSubStrOrPos)
		return This.FindNthSplitAfterCS(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterZ(n, pSubStrOrPos)
			return This.FindNthSplitAfterCS(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN POSITION   #
	#-----------------------------------------------#

	def FindNthSplitAfterPosition(n, nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPosition(n, nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPosition(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		def FindNthSplitAfterThisPositionZ(n, nPos)
			return This.FindNthSplitAfterPosition(n, nPos)

		#>

	  #---------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY POSITIONS   #
	#---------------------------------------------#

	def FindNthSplitAfterPositions(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositions(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositions(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#--

		def FindNthSplitAfterPositionsZ(n, anPos)
			return This.FindNthSplitAfterPositions(n, anPos)

		def FindNthSplitAfterThesePositionsZ(n, anPos)
			return This.FindNthSplitAfterThesePositions(n, anPos)

		def FindNthSplitAfterManyPositionsZ(n, anPos)
			return This.FindNthSplitAfterManyPositions(n, anPos)

		#>

	  #------------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN SUBSTRING   #
	#------------------------------------------------#

	def FindNthSplitAfterSubStringCS(n, cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringCSZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubString(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubString(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		def FindNthSplitAfterThisSubStringZ(n, pcSubStr)
			return This.FindNthSplitAfterSubString(n, pcSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE MANY SUBSTRINGS   #
	#----------------------------------------------#

	def FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositions(n, anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStrings(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCS(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStrings(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStrings(n, pacSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION  #
	#--------------------------------------------#

	def FindNthSplitAfterSection(n, n1, n2)

		if NOT BothAreNumbers(n, n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSection(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSection(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#--

		def FindNthSplitAfterSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		def FindNthSplitAfterThisSectionZ(n, n1, n2)
			return This.FindNthSplitAfterSection(n, n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindNthSplitAfterSectionIB(n, n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIB(n, n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		#--

		def FindNthSplitAfterSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)

		def FindNthSplitAfterThisSectionIBZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIB(n, n1, n2)


		#>

	  #-------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS   #
	#-------------------------------------------#

	def FindNthSplitAfterSections(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSections(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSections(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#--

		def FindNthSplitAfterSectionsZ(n, paSections)
			return This.FindNthSplitAfterSections(n, paSections)

		def FindNthSplitAfterTheseSectionsZ(n, paSections)
			return This.FindNthSplitAfterTheseSections(n, paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING NTH SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindNthSplitAfterSectionsIB(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIB(n, paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#--

		def FindNthSplitAfterSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		def FindNthSplitAfterTheseSectionsIBZ(n, paSections)
			return This.FindNthSplitAfterSectionsIB(n, paSections)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=========================================================#

	def FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetween(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCS(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetween(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenZ(n, pBound1, pBound2)
			return This.FindNthSplitBetween(n, pBound1, pBound2)

		#>

	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIB(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSections(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenCSIBZ(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIB(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIB(n, pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenIBZ(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIB(n, pBound1, pBound2)

		#>

	  #-------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS  #
	#-------------------------------------------#

	def FindNthSplitBetweenPositions(n, n1, n2)
		This.FindNthSplitAtSection(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositions(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		def FindNthSplitBetweenThesePositionsZ(n, n1, n2)
			return This.FindNthSplitBetweenPositions(n, n1, n2)

		#>
		
	  #---------------------------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIB(n, n1, n2)
		This.FindNthSplitAtSectionIB(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		def FindNthSplitBetweenThesePositionsIBZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIB(n, n1, n2)

		#>

	  #--------------------------------------------#
	 #  FINDING NTH SPLIT BETWEEN TWO SUBSTRINGS  #
	#--------------------------------------------#

	def FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindNthSplitBetweenSections(n, aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsCSZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStrings(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCS(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStrings(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStrings(n, pacSubStr)

		#>

	  #------------------------------------#
	 #    FINDING NTH SPLIT TO N PARTS    #
	#====================================#

	def FindNthSplitToNParts(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNParts(n, nPos)
		return nResult

		def FindNthSplitToNPartsZ(n, nPos)
			return This.FindNthSplitToNParts(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNChars(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositions(n, nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNChars(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsZ(n, nPos)
			return This.FindNthSplitToPartsOfNChars(n, nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF N CHARS -- EXTENDED   #
	#-------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsXT(n, nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsXT(n, nPos)

		return nResult

		def FindNthSplitToPartsOfNCharsXTZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsXT(n, nPos)

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT UNDER A GIVEN CONDTION   #
	#==============================================#

	def FindNthSplitW(n, pcCondition)
		/*
		? StzSplitterQ(1:5).FindNthSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindNthSplitAtW(n, pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindNthSplitBeforeW(n, pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindNthSplitAfterW(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitWZ(n, pcCondition)
			return This.FindNthSplitWZ(n, pcCondition)

		#>

	  #-------------------------------------------#
	 #   FINSING NTH SPLIT AT A GIVEN CONDTION   #
	#-------------------------------------------#

	def FindNthSplitAtW(n, pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok


		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsW(pcCondition)
			nResult = This.FindNthSplitAtSectionsZ(n, aSections)

		else

			anPositions = This.FindW(pcCondition)
			nResult = This.FindNthSplitAtPositionsZ(n, anPositions)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtWZ(n, pcCondition)
			return This.FindNthSplitAtW(n, pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING NTH SPLIT BEFORE A GIVEN CONDTION   #
	#-----------------------------------------------#

	def FindNthSplitBeforeW(n, pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindNthSplitBeforePositions(n, anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeWZ(n, pcCondition)
			return This.FindNthSplitBeforeW(n, pcCondition)

		#>

	  #----------------------------------------------#
	 #   FINDING NTH SPLIT AFTER A GIVEN CONDTION   #
	#----------------------------------------------#

	def FindNthSplitAfterW(n, pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindNthSplitAfterPositions(n, anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterWZ(pcCondition)
			return This.FindNthSplitAfterW(pcCondition)

		#>

	  #====================================================#
	 #   FINDING THE NTH SPLIT AS SECTION -- ZZ/EXTENDED  #
	#====================================================#

	def FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindNthSplitAtCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindNthSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindNthSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindNthSplitBetweenCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindNthSplitBetweenPositionsZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindNthSplitBetweenSubStringsCSZZ(n, pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindNthSplitToNPartsZZ(n, pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindNthSplitToPartsOfNCharsZZ(n, pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionCSXT(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitCSXTZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitXTZZ(n, pSubStrOrPos)
		return This.FindNthSplitCSXTZZ(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionXT(n, pSubStrOrPos)
			return This.FindNthSplitXTZZ(n, pSubStrOrPos)

		#>

	  #--------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#====================================================================#

	def FindNthSplitAtCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitAsSectionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitAtPositionZZ(n, pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAtPositionsZZ(n, pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAtSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAtSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAtSectionZZ(n, pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAtSectionsZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAtCSZZ(n, pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtZZ(n, pSubStrOrPos)
		return This.FindNthSplitAtCSZZ(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAtCSZZ(n, pSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#========================================================#

	def FindNthSplitAtPositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisPositionAsSection(n, nPos)
			return This.FindNthSplitAtPositionZZ(n, nPos)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-----------------------------------------------------#

	def FindNthSplitAtPositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtThesePositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsZZ(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#--

		def FindNthSplitAtPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		def FindNthSplitAtManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAtPositionsZZ(n, anPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#========================================================#

	def FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringZZ(pcSubStr)
		return This.FindNthSplitAtSubStringCSZZ(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitAtThisSubStringZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindNthSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, :CaseSensitive = TRUE)

		def FindNthSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindNthSplitAtSubStringZZ(n, pcSubStr, :CaseSensitive = TRUE)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#--------------------------------------------------------#

	def FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindNthSplitAtPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAtSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAtManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAtSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAtSubStringsCSZZ(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)
	
		def FindNthSplitAtManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAtSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtTheseSubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		def FindNthSplitAtManySubStringsAsSections(n, pacSubStr)
			return This.FindNthSplitAtSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=======================================================#

	def FindNthSplitAtSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitAtSectionZZ(n, n1, n2)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------#

	def FindNthSplitAtSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtThisSectionIBZZ(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAtSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		def FindNthSplitAtThisSectionAsSectionIB(n, n1, n2)
			return This.SplitAtSectionIBZZ(n, n1, n2)

		#>

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-----------------------------------------------------#

	def FindNthSplitAtSectionsZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAtSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAtTheseSectionsZZ(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#--

		def FindNthSplitAtSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		def FindNthSplitAtTheseSectionsAsSection(paSections)
			return This.FindNthSplitAtSectionsZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING NTH SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#------------------------------------------------------------------------#

	def FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindNthSplitBeforePositionZZ(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitBeforePositionsZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitBeforeSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitBeforeSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitBeforeSectionZZ(n, pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitBeforeSectionsZZ(n, pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeZZ(n, pSubStrOrPos)
		return This.FindNthSplitBeforeCSZZ(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeAsSection(n, pSubStrOrPos)
			return This.FindNthSplitBeforeZZ(n, pSubStrOrPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#------------------------------------------------------------#

	def FindNthSplitBeforePositionZZ(n, nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThisPositionZZ(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#--

		def FindNthSplitBeforePositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		def FindNthSplitBeforeThisPositionAsSection(n, nPos)
			return This.FindNthSplitBeforePositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitBeforePositionsZZ(n, anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeThesePositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsZZ(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#--

		def FindNthSplitBeforePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeThesePositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		def FindNthSplitBeforeManyPositionsAsSection(n, anPos)
			return This.FindNthSplitBeforePositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitBeforeThisSubStringAsSectionsCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringZZ(n, pcSubStr)
		return This.FindNthSplitBeforeSubStringCSZZ(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitBeforeSubString(n, pcSubStr)

		#--

		def FindNthSplitBeforeSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)

		def FindNthSplitBeforeThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitBeforeSubStringZZ(n, pcSubStr)	

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforePositionsZZ(n, anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBeforeSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeTheseSubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBeforeManySubStringsAsSectionsCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBeforeSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBeforeSubStringsCSZZ(n, pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBeforeSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		def FindNthSplitBeforeManySubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBeforeSubStringsZZ(n, pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindNthSplitBeforeSectionZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSection(n, n1, n2)
			return This.FindNthSplitBeforeSectionZZ(n, n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionIBZZ(n, n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitBeforeSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		def FindNthSplitBeforeThisSectionAsSectionsIB(n, n1, n2)
			return This.FindNthSplitBeforeSectionIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindNthSplitBeforeSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBeforeSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsZZ(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#--

		def FindNthSplitBeforeSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitBeforeSectionsZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSection(n, paSections)
			return This.SplitBeforeSectionsZZ(n, paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINING NTH SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#--------------------------------------------------------------------------#

	def FindNthSplitBeforeSectionsIBZZ(n, paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBeforeTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsIBZZ(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindNthSplitBeforeSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionsIBZZ(n, paSections)

		def FindNthSplitBeforeTheseSectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		def FindNthSplitBeforeManySectionsAsSectionIB(n, paSections)
			return This.FindNthSplitBeforeSectionIBZZ(n, paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------------------#

	def FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindNthSplitAfterPositionZZ(n, pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindNthSplitAfterSubStringCSZZ(n, pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindNthSplitAfterSubStringsCSZZ(n, pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindNthSplitAfterSectionZZ(n, pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindNthSplitAfterPositionsZZ(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindNthSplitAfterSubStringsZZ(n, pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindNthSplitAfterSectionsZZ(n, pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionCS(n, pSubStrOrPos, pCaseSensitive)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterZZ(n, pSubStrOrPos)
		return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSection(n, pSubStrOrPos)
			return This.FindNthSplitAfterCSZZ(n, pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterPositionZZ(n, Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionZZ(n, nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisPositionZZ(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		def FindNthSplitAfterThisPositionAsSection(n, nPos)
			return This.FindNthSplitAfterPositionZZ(n, nPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#----------------------------------------------------------#

	def FindNthSplitAfterPositionsZZ(n, anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThesePositionsZZ(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsZZ(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#--

		def FindNthSplitAfterPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterPositionsZZ(anPos)

		def FindNthSplitAfterThesePositionsAsSection(n, anPos)
			return This.FindNthSplitAfterThesePositionsZZ(n, anPos)

		def FindNthSplitAfterManyPositionsAsSection(n, anPos)
			return This.FindNthSplitAfterManyPositionsZZ(n, anPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------------------#

	def FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringCSZZ(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		def FindNthSplitAfterThisSubStringAsSectionCS(n, pcSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringZZ(n, pcSubStr)
		return This.FindNthSplitAfterSubStringCSZZ(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSubStringZZ(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#--

		def FindNthSplitAfterSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		def FindNthSplitAfterThisSubStringAsSection(n, pcSubStr)
			return This.FindNthSplitAfterSubStringZZ(n, pcSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------------------#

	def FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterPositionsZZ(n, anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitAfterSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitAfterManySubStringsAsSectionCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitAfterSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitAfterSubStringsCSZZ(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitAfterTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitAfterSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(n, pacSubStr)

		def FindNthSplitAfterManySubStringsAsSectionZZ(n, pacSubStr)
			return This.FindNthSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#----------------------------------------------------------#

	def FindNthSplitAfterSectionZZ(n, n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSections(n, n1, n2)
			return This.FindNthSplitAfterSectionZZ(n, n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindNthSplitAfterSectionIBZZ(n, n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionIBZZ(n, n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterThisSectionIBZZ(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		#--

		def FindNthSplitAfterSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n, n1, n2)

		def FindNthSplitAfterThisSectionAsSectionIB(n, n1, n2)
			return This.FindNthSplitAfterSectionIBZZ(n1, n2)

		#>

	  #--------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#--------------------------------------------------------#

	def FindNthSplitAfterSectionsZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsZZ(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterSectionsZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSection(n, paSections)
			return This.FindNthSplitAfterTheseSectionsZZ(n, paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindNthSplitAfterSectionsIBZZ(n, paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitAfterSectionsIBZZ(n, paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitAfterTheseSectionsIBZZ(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#--

		def FindNthSplitAfterSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		def FindNthSplitAfterTheseSectionsAsSectionsIB(n, paSections)
			return This.FindNthSplitAfterSectionsIBZZ(n, paSections)

		#>

	  #----------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#======================================================================#

	def FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCS(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCS(n, pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSection(n, pBound1, pBound2)
			return This.FindNthSplitBetweenZZ(n, pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------------------#

	def FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindNthSplitBetweenSectionsZZ(n, aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionCSIB(n, pBound1, pBound2, pCaseSensitive)
			return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenIBZZ(n, pBound1, pBound2)
		return This.FindNthSplitBetweenCSIBZZ(n, pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindNthSplitBetweenAsSectionIB(n, pBound1, pBound2)
			return This.FindNthSplitBetweenIBZZ(n, pBound1, pBound2)

		#>

	  #--------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#--------------------------------------------------------#

	def FindNthSplitBetweenPositionsZZ(n, n1, n2)
		This.FindNthSplitAtSectionZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSection(n, n1, n2)
			return This.FindNthSplitBetweenPositionsZZ(n, n1, n2)

		#>
		
	  #-----------------------------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindNthSplitBetweenPositionsIBZZ(n, n1, n2)
		This.FindNthSplitAtSectionIBZZ(n, n1, n2)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenThesePositionsIBZZ(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#--

		def FindNthSplitBetweenPositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		def FindNthSplitBetweenThesePositionsAsSectionIB(n, n1, n2)
			return This.FindNthSplitBetweenPositionsIBZZ(n, n1, n2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING NTH SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindNthSplitBetweenSectionsZZ(n, aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsCSZZ(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#--

		def FindNthSplitBetweenSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		def FindNthSplitBetweenTheseSubStringsAsSectionCS(n, pacSubStr, pCaseSensitive)
			return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindNthSplitBetweenSubStringsZZ(n, pacSubStr)
		return This.FindNthSplitBetweenSubStringsCSZZ(n, pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindNthSplitBetweenTheseSubStringsZZ(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#--

		def FindNthSplitBetweenSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		def FindNthSplitBetweenTheseSubStringsAsSection(n, pacSubStr)
			return This.FindNthSplitBetweenSubStringsZZ(n, pacSubStr)

		#>

	  #-------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) TO N PARTS    #
	#=================================================#

	def FindNthSplitToNPartsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindNthSplitToNPartsZZ(n, nPos)
		return aResult

		def FindNthSplitToNPartsAsSection(n, nPos)
			return This.FindNthSplitToNPartsZZ(n, nPos)

	  #-----------------------------------------------------#
	 #   FINDING NTH SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-----------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindNthSplitToPartsOfNCharsZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfExactlyNPositionsZZ(n, nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitToPartsOfExactlyNCharsZZ(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#--

		def FindNthSplitToPartsOfNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		def FindNthSplitToPartsOfExactlyNCharsAsSection(n, nPos)
			return This.FindNthSplitToPartsOfNCharsZZ(n, nPos)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING NTH SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindNthSplitToPartsOfNCharsIBZZ(n, nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindNthSplitToPartsOfNPositionsIBZZ(n, nPos)

		return aResult

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) UNDER A GIVEN CONDTION   #
	#============================================================#

	def FindNthSplitWZZ(n, pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindNthSplitAtWZZ(n, pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindNthSplitBeforeWZZ(n, pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindNthSplitAfterWZZ(n, pcCondition[2])

			ok
		
		else

			return This.FindNthSplitAtWZZ(n, pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindNthSplitAsSectionW(n, pcCondition)
			return This.FindNthSplitWZZ(n, pcCondition)

		#>

	  #---------------------------------------------------------#
	 #    FINSING NTH SPLIT (AS SECTION) AT A GIVEN CONDTION   #
	#---------------------------------------------------------#

	def FindNthSplitAtWZZ(n, pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.FindNthSplitAtSectionsZZ(n, aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.FindNthSplitAtPositionsZZ(n, anPositions)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAtAsSectionW(n, pcCondition)
			return This.FindNthSplitAtWZZ(n, pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#--------------------------------------------------------------#

	def FindNthSplitBeforeWZZ(n, pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindNthSplitBeforePositionsZZ(n, anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitBeforeAsSectionW(n, pcCondition)
			return This.FindNthSplitBeforeWZZ(n, pcCondition)

		#>

	  #------------------------------------------------------------#
	 #    FINDING NTH SPLIT (AS SECTION) AFTER A GIVEN CONDTION   #
	#------------------------------------------------------------#

	def FindNthSplitAfterWZZ(n, pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindNthSplitAfterPositionsZZ(n, anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindNthSplitAfterAsSectionW(n, pcCondition)
			return This.FindNthSplitAfterWZZ(n, pcCondition)

		#>

	  #=============================#
	 #   FINDING THE FIRST SPLIT   #
	#=============================#

	def FindFirstSplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindFirstSplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindFirstSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindFirstSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindFirstSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindFirstSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindFirstSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindFirstSplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindFirstSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindFirstSplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindFirstSplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindFirstSplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindFirstSplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindFirstSplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindFirstSplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindFirstSplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindFirstSplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindFirstSplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindFirstSplitBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindFirstSplitBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindFirstSplitBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindFirstSplitToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindFirstSplitToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindFirstSplitAtW(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindFirstSplitBeforeW(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindFirstSplitAfterW(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitXT(pSubStrOrPos)
		return This.FindFirstSplitCSXT(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitXTZ(pSubStrOrPos)
			return This.FindFirstSplitXT(pSubStrOrPos)

		#>

	  #---------------------------------------------------------#
	 #   FINDING FIRST SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#=========================================================#

	def FindFirstSplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplit(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAt(pSubStrOrPos)
		return This.FindFirstSplitAtCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAtZ(pSubStrOrPos)
			return This.FindFirstSplitAtCS(pSubStr)

		#>

	  #---------------------------------------------#
	 #   FINDING FIRST SPLIT AT A GIVEN POSITION   #
	#=============================================#

	def FindFirstSplitAtPosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(nPos)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisPosition(nPos)
			return This.FindFirstSplitAtPosition(nPos)

		def FindFirstSplitAtPositionZ(nPos)
			return This.FindFirstSplitAtPosition(nPos)

		def FindFirstSplitAtThisPositionZ(nPos)
			return This.FindFirstSplitAtPosition(nPos)

		#>

	  #-------------------------------------------#
	 #   FINDING FIRST SPLIT AT MANY POSITIONS   #
	#-------------------------------------------#

	def FindFirstSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfChars()).FindFirstSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtThesePositions(anPos)
			return This.FindFirstSplitAtPositions(anPos)

		def FindFirstSplitAtManyPositions(anPos)
			return This.FindFirstSplitAtPositions(anPos)

		#--

		def FindFirstSplitAtPositionsZ(anPos)
			return This.FindFirstSplitAtPositions(anPos)

		def FindFirstSplitAtThesePositionsZ(anPos)
			return This.FindFirstSplitAtPositions(anPos)

		def FindFirstSplitAtManyPositionsZ(anPos)
			return This.FindFirstSplitAtPositions(anPos)

		#>

	  #----------------------------------------------#
	 #   FINDING FIRST SPLIT AT A GIVEN SUBSTRING   #
	#==============================================#

	def FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindFirstSplitCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubString(pcSubStr)
		return This.FindFirstSplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplit(pcSubStr)
			return This.FindFirstSplitCS(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitAtThisSubString(pcSubStr)
			return This.FindFirstSplitAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindFirstSplitAtSubStringZ(pcSubStr)
			return This.FindFirstSplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitZ(pcSubStr)
			return This.FindFirstSplitCS(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitAtThisSubStringZ(pcSubStr)
			return This.FindFirstSplitAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #---------------------------------------------#
	 #   FINDING FIRST SPLIT AT GIVEN SUBSTRINGS   #
	#---------------------------------------------#

	def FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)
		nResult = This.FindFirstSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStrings(pacSubStr)
		return This.FindFirstSplitAtSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStrings(pacSubStr)
			return This.FindFirstSplitAtSubStrings(pacSubStr)
	
		def FindFirstSplitAtManySubStrings(pacSubStr)
			return This.FindFirstSplitAtSubStrings(pacSubStr)

		#--

		def FindFirstSplitAtSubStringsZ(pacSubStr)
			return This.FindFirstSplitAtSubStrings(pacSubStr)

		def FindFirstSplitAtTheseSubStringsZ(pacSubStr)
			return This.FindFirstSplitAtSubStrings(pacSubStr)

		def FindFirstSplitAtManySubStringsZ(pacSubStr)
			return This.FindFirstSplitAtSubStrings(pacSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING FIRST SPLIT AT A GIVEN SECTION   #
	#============================================#

	def FindFirstSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSection(n1, n2)
			return This.FindFirstSplitAtSection(n1, n2)

		#--

		def FindFirstSplitAtSectionZ(n1, n2)
			return This.FindFirstSplitAtSection(n1, n2)

		def FindFirstSplitAtThisSectionZ(n1, n2)
			return This.FindFirstSplitAtSection(n1, n2)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindFirstSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindFirstSplitAtSectionIBZ(n1, n2)
			return This.FindFirstSplitAtSectionIB(n1, n2)

		def FindFirstSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #------------------------------------------#
	 #   FINDING FIRST SPLIT AT MANY SECTIONS   #
	#------------------------------------------#

	def FindFirstSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSections(paSections)
			return This.FindFirstSplitAtSections(paSections)

		#--

		def FindFirstSplitAtSectionsZ(paSections)
			return This.FindFirstSplitAtSections(paSections)

		def FindFirstSplitAtTheseSectionsZ(paSections)
			return This.FindFirstSplitAtSections(paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#------------------------------------------------------------#

	def FindFirstSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSectionsIB(paSections)
			return This.FindFirstSplitAtSectionsIB(paSections)

		#--

		def FindFirstSplitAtSectionsIBZ(paSections)
			return This.FindFirstSplitAtSectionsIB(paSections)

		def FindFirstSplitAtTheseSectionsIBZ(paSections)
			return This.FindFirstSplitAtSectionsIB(paSections)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#--------------------------------------------------------------#

	def FindFirstSplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindFirstSplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBefore(pSubStrOrPos)
		return This.FindFirstSplitBeforeCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeZ(pSubStrOrPos)
			return This.FindFirstSplitBefore(pSubStrOrPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN POSITION   #
	#-------------------------------------------------#

	def FindFirstSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThisPosition(nPos)
			return This.FindFirstSplitBeforePosition(nPos)

		#--

		def FindFirstSplitBeforePositionZ(nPos)
			return This.FindFirstSplitBeforePosition(nPos)

		def FindFirstSplitBeforeThisPositionZ(nPos)
			return This.FindFirstSplitBeforePosition(nPos)

		#>

	  #-----------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY POSITIONS   #
	#-----------------------------------------------#

	def FindFirstSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThesePositions(anPos)
			return This.FindFirstSplitBeforePositions(anPos)

		def FindFirstSplitBeforeManyPositions(anPos)
			return This.FindFirstSplitBeforePositions(anPos)

		#--

		def FindFirstSplitBeforePositionsZ(anPos)
			return This.FindFirstSplitBeforePositions(anPos)

		def FindFirstSplitBeforeThesePositionsZ(anPos)
			return This.FindFirstSplitBeforePositions(anPos)

		def FindFirstSplitBeforeManyPositionsZ(anPos)
			return This.FindFirstSplitBeforePositions(anPos)

		#>

	  #--------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------#

	def FindFirstSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindFirstSplitBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubString(pcSubStr)
		return This.FindFirstSplitBeforeSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubString(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)

		#--

		def FindFirstSplitBeforeSubStringZ(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)

		def FindFirstSplitBeforeThisSubStringZ(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)	

		#>

	  #------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------#

	def FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStrings(pacSubStr)
		return This.FindFirstSplitBeforeSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStrings(pacSubStr)
			return This.FindFirstSplitBeforeSubStrings(pacSubStr)

		def FindFirstSplitBeforeManySubStrings(pacSubStr)
			return This.FindFirstSplitBeforeSubStrings(pacSubStr)

		#--

		def FindFirstSplitBeforeSubStringsZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStrings(pacSubStr)

		def FindFirstSplitBeforeTheseSubStringsZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStrings(pacSubStr)

		def FindFirstSplitBeforeManySubStringsZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStrings(pacSubStr)

		#>

	  #------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN SECTION   #
	#------------------------------------------------#

	def FindFirstSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSection(n1, n2)
			return This.FindFirstSplitBeforeSection(n1, n2)

		#--

		def FindFirstSplitBeforeSectionZ(n1, n2)
			return This.FindFirstSplitBeforeSection(n1, n2)

		def FindFirstSplitBeforeThisSectionZ(n1, n2)
			return This.FindFirstSplitBeforeSection(n1, n2)

		#>

	  #-------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIB(n1, n2)

		#--

		def FindFirstSplitBeforeSectionIBZ(n1, n2)
			return This.FindFirstSplitBeforeSectionIB(n1, n2)

		def FindFirstSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindFirstSplitBeforeSectionIB(n1, n2)

		#>

	  #----------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY SECTIONS   #
	#----------------------------------------------#

	def FindFirstSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSections(paSections)
			return This.FindFirstSplitBeforeSections(paSections)

		def FindFirstSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindFirstSplitBeforeSectionsZ(paSections)
			return This.FindFirstSplitBeforeSections(paSections)

		def FindFirstSplitBeforeTheseSectionsZ(paSections)
			return This.FindFirstSplitBeforeSections(paSections)

		def FindFirstSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindFirstSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsIB(paSections)
			return This.FindFirstSplitBeforeSectionsIB(paSections)

		def FindFirstSplitBeforeManySectionsIB(paSections)
			return This.FindFirstSplitBeforeSectionsIB(paSections)

		#--

		def FindFirstSplitBeforeSectionsIBZ(paSections)
			return This.FindFirstSplitBeforeSectionsIB(paSections)

		def FindFirstSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindFirstSplitBeforeSectionsIB(paSections)

		def FindFirstSplitBeforeManySectionsIBZ(paSections)
			return This.FindFirstSplitBeforeSectionsIB(paSections)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#------------------------------------------------------------#

	def FindFirstSplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindFirstSplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindFirstSplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAfterSection(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindFirstSplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindFirstSplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindFirstSplitAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfter(pSubStrOrPos)
		return This.FindFirstSplitAfterCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterZ(pSubStrOrPos)
			return This.FindFirstSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN POSITION   #
	#-------------------------------------------------#

	def FindFirstSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisPosition(nPos)
			return This.FindFirstSplitAfterPosition(nPos)

		def FindFirstSplitAfterPositionZ(nPos)
			return This.FindFirstSplitAfterPosition(nPos)

		def FindFirstSplitAfterThisPositionZ(nPos)
			return This.FindFirstSplitAfterPosition(nPos)

		#>

	  #-----------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY POSITIONS   #
	#-----------------------------------------------#

	def FindFirstSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThesePositions(anPos)
			return This.FindFirstSplitAfterThesePositions(anPos)

		def FindFirstSplitAfterManyPositions(anPos)
			return This.FindFirstSplitAfterManyPositions(anPos)

		#--

		def FindFirstSplitAfterPositionsZ(anPos)
			return This.FindFirstSplitAfterPositions(anPos)

		def FindFirstSplitAfterThesePositionsZ(anPos)
			return This.FindFirstSplitAfterThesePositions(anPos)

		def FindFirstSplitAfterManyPositionsZ(anPos)
			return This.FindFirstSplitAfterManyPositions(anPos)

		#>

	  #--------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------#

	def FindFirstSplitAfterSubStringCS(cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindFirstSplitAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubString(pcSubStr)
		return This.FindFirstSplitAfterSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubString(pcSubStr)
			return This.FindFirstSplitAfterSubString(pcSubStr)

		#--

		def FindFirstSplitAfterSubStringZ(pcSubStr)
			return This.FindFirstSplitAfterSubString(pcSubStr)

		def FindFirstSplitAfterThisSubStringZ(pcSubStr)
			return This.FindFirstSplitAfterSubString(pcSubStr)

		#>

	  #------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------#

	def FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStrings(pacSubStr)
		return This.FindFirstSplitAfterSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStrings(pacSubStr)
			return This.FindFirstSplitAfterSubStrings(pacSubStr)

		def FindFirstSplitAfterManySubStrings(pacSubStr)
			return This.FindFirstSplitAfterSubStrings(pacSubStr)

		#--

		def FindFirstSplitAfterSubStringsZ(pacSubStr)
			return This.FindFirstSplitAfterSubStrings(pacSubStr)

		def FindFirstSplitAfterTheseSubStringsZ(pacSubStr)
			return This.FindFirstSplitAfterSubStrings(pacSubStr)

		def FindFirstSplitAfterManySubStringsZ(pacSubStr)
			return This.FindFirstSplitAfterSubStrings(pacSubStr)

		#>

	  #----------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER A GIVEN SECTION  #
	#----------------------------------------------#

	def FindFirstSplitAfterSection(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSection(n1, n2)
			return This.FindFirstSplitAfterSection(n1, n2)

		#--

		def FindFirstSplitAfterSectionZ(n1, n2)
			return This.FindFirstSplitAfterSection(n1, n2)

		def FindFirstSplitAfterThisSectionZ(n1, n2)
			return This.FindFirstSplitAfterSection(n1, n2)

		#>

	  #-----------------------------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------#

	def FindFirstSplitAfterSectionIB(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIB(n1, n2)

		#--

		def FindFirstSplitAfterSectionIBZ(n1, n2)
			return This.FindFirstSplitAfterSectionIB(n1, n2)

		def FindFirstSplitAfterThisSectionIBZ(n1, n2)
			return This.FindFirstSplitAfterSectionIB(n1, n2)


		#>

	  #---------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER MANY SECTIONS   #
	#---------------------------------------------#

	def FindFirstSplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSections(paSections)
			return This.FindFirstSplitAfterTheseSections(paSections)

		#--

		def FindFirstSplitAfterSectionsZ(paSections)
			return This.FindFirstSplitAfterSections(paSections)

		def FindFirstSplitAfterTheseSectionsZ(paSections)
			return This.FindFirstSplitAfterTheseSections(paSections)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindFirstSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIB(paSections)

		#--

		def FindFirstSplitAfterSectionsIBZ(paSections)
			return This.FindFirstSplitAfterSectionsIB(paSections)

		def FindFirstSplitAfterTheseSectionsIBZ(paSections)
			return This.FindFirstSplitAfterSectionsIB(paSections)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING FIRST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#===========================================================#

	def FindFirstSplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetween(pBound1, pBound2)
		return This.FindFirstSplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenZ(pBound1, pBound2)
			return This.FindFirstSplitBetween(pBound1, pBound2)

		#>

	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#

	def FindFirstSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenIB(pBound1, pBound2)
		return This.FindFirstSplitBetweenCSIB(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenIBZ(pBound1, pBound2)
			return This.FindFirstSplitBetweenIB(pBound1, pBound2)

		#>

	  #---------------------------------------------#
	 #  FINDING FIRST SPLIT BETWEEN TWO POSITIONS  #
	#---------------------------------------------#

	def FindFirstSplitBetweenPositions(n1, n2)
		This.FindFirstSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositions(n1, n2)
			return This.FindFirstSplitBetweenPositions(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsZ(n1, n2)
			return This.FindFirstSplitBetweenPositions(n1, n2)

		def FindFirstSplitBetweenThesePositionsZ(n1, n2)
			return This.FindFirstSplitBetweenPositions(n1, n2)

		#>
		
	  #-----------------------------------------------------------------#
	 #  FINDING FIRST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------#

	def FindFirstSplitBetweenPositionsIB(n1, n2)
		This.FindFirstSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIB(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsIBZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsIB(n1, n2)

		def FindFirstSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsIB(n1, n2)

		#>

	  #----------------------------------------------#
	 #  FINDING FIRST SPLIT BETWEEN TWO SUBSTRINGS  #
	#----------------------------------------------#

	def FindFirstSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindFirstSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindFirstSplitBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenSubStrings(pacSubStr)
		return This.FindFirstSplitBetweenSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStrings(pacSubStr)
			return This.FindFirstSplitBetweenSubStrings(pacSubStr)

		#--

		def FindFirstSplitBetweenSubStringsZ(pacSubStr)
			return This.FindFirstSplitBetweenSubStrings(pacSubStr)

		def FindFirstSplitBetweenTheseSubStringsZ(pacSubStr)
			return This.FindFirstSplitBetweenSubStrings(pacSubStr)

		#>

	  #--------------------------------------#
	 #    FINDING FIRST SPLIT TO N PARTS    #
	#======================================#

	def FindFirstSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitToNParts(nPos)
		return nResult

		def FindFirstSplitToNPartsZ(nPos)
			return This.FindFirstSplitToNParts(nPos)

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindFirstSplitToPartsOfNChars(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitToPartsOfExactlyNChars(nPos)
			return This.FindFirstSplitToPartsOfNChars(nPos)

		#--

		def FindFirstSplitToPartsOfNCharsZ(nPos)
			return This.FindFirstSplitToPartsOfNChars(nPos)

		def FindFirstSplitToPartsOfExactlyNCharsZ(nPos)
			return This.FindFirstSplitToPartsOfNChars(nPos)

		#>

	  #---------------------------------------------------------#
	 #   FINDING FIRST SPLIT TO PARTS OF N CHARS -- EXTENDED   #
	#---------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindFirstSplitToPartsOfNCharsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindFirstSplitToPartsOfNCharsXTZ(nPos)
			return This.FindFirstSplitToPartsOfNCharsXT(nPos)

	  #------------------------------------------------#
	 #   FINDING FIRST SPLIT UNDER A GIVEN CONDTION   #
	#================================================#

	def FindFirstSplitW(pcCondition)
		/*
		? StzSplitterQ(1:5).FindFirstSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindFirstSplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindFirstSplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindFirstSplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindFirstSplitAfterW(pcCondition[2])

			ok
		
		else

			return This.FindFirstSplitAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitWZ(pcCondition)
			return This.FindFirstSplitWZ(pcCondition)

		#>

	  #---------------------------------------------#
	 #   FINSING FIRST SPLIT AT A GIVEN CONDTION   #
	#---------------------------------------------#

	def FindFirstSplitAtW(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok


		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsW(pcCondition)
			nResult = This.FindFirstSplitAtSectionsZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			nResult = This.FindFirstSplitAtPositionsZ(anPositions)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtWZ(pcCondition)
			return This.FindFirstSplitAtW(pcCondition)

		#>

	  #-------------------------------------------------#
	 #   FINDING FIRST SPLIT BEFORE A GIVEN CONDTION   #
	#-------------------------------------------------#

	def FindFirstSplitBeforeW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindFirstSplitBeforePositions(anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeWZ(pcCondition)
			return This.FindFirstSplitBeforeW(pcCondition)

		#>

	  #------------------------------------------------#
	 #   FINDING FIRST SPLIT AFTER A GIVEN CONDTION   #
	#------------------------------------------------#

	def FindFirstSplitAfterW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindFirstSplitAfterPositions(anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterWZ(pcCondition)
			return This.FindFirstSplitAfterW(pcCondition)

		#>

	  #======================================================#
	 #   FINDING THE FIRST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#======================================================#

	def FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindFirstSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindFirstSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindFirstSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindFirstSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindFirstSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindFirstSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindFirstSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindFirstSplitAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindFirstSplitBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindFirstSplitAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitXTZZ(pSubStrOrPos)
		return This.FindFirstSplitCSXTZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionXT(pSubStrOrPos)
			return This.FindFirstSplitXTZZ(pSubStrOrPos)

		#>

	  #----------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#======================================================================#

	def FindFirstSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtZZ(pSubStrOrPos)
		return This.FindFirstSplitAtCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSection(pSubStrOrPos)
			return This.FindFirstSplitAtCSZZ(pSubStr)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#==========================================================#

	def FindFirstSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisPositionAsSection(nPos)
			return This.FindFirstSplitAtPositionZZ(nPos)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#-------------------------------------------------------#

	def FindFirstSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtThesePositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsZZ(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#--

		def FindFirstSplitAtPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtThesePositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		def FindFirstSplitAtManyPositionsAsSection(anPos)
			return This.FindFirstSplitAtPositionsZZ(anPos)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#==========================================================#

	def FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringZZ(pcSubStr)
		return This.FindFirstSplitAtSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitAtThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindFirstSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindFirstSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindFirstSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAtSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAtSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)
	
		def FindFirstSplitAtManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAtSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		def FindFirstSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindFirstSplitAtSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#=========================================================#

	def FindFirstSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionZZ(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSection(n1, n2)
			return This.FindFirstSplitAtSectionZZ(n1, n2)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAtSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAtSectionIBZZ(n1, n2)

		def FindFirstSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#-------------------------------------------------------#

	def FindFirstSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAtTheseSectionsZZ(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#--

		def FindFirstSplitAtSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		def FindFirstSplitAtTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAtSectionsZZ(paSections)

		#>

	  #--------------------------------------------------------------------------#
	 #   FINDING FIRST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#--------------------------------------------------------------------------#

	def FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindFirstSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeZZ(pSubStrOrPos)
		return This.FindFirstSplitBeforeCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeAsSection(pSubStrOrPos)
			return This.FindFirstSplitBeforeZZ(pSubStrOrPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThisPositionZZ(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#--

		def FindFirstSplitBeforePositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		def FindFirstSplitBeforeThisPositionAsSection(nPos)
			return This.FindFirstSplitBeforePositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeThesePositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsZZ(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#--

		def FindFirstSplitBeforePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeThesePositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		def FindFirstSplitBeforeManyPositionsAsSection(anPos)
			return This.FindFirstSplitBeforePositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringZZ(pcSubStr)
		return This.FindFirstSplitBeforeSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitBeforeSubString(pcSubStr)

		#--

		def FindFirstSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)

		def FindFirstSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBeforeSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		def FindFirstSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#-------------------------------------------------------------#

	def FindFirstSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindFirstSplitBeforeSectionZZ(n1, n2)

		#>

	  #--------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#--------------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		def FindFirstSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindFirstSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#-----------------------------------------------------------#

	def FindFirstSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsZZ(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindFirstSplitBeforeSectionsZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINING FIRST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#----------------------------------------------------------------------------#

	def FindFirstSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsIBZZ(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindFirstSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionsIBZZ(paSections)

		def FindFirstSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		def FindFirstSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindFirstSplitBeforeSectionIBZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#-------------------------------------------------------------------------#

	def FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindFirstSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindFirstSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindFirstSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindFirstSplitAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindFirstSplitAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindFirstSplitAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindFirstSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterZZ(pSubStrOrPos)
		return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSection(pSubStrOrPos)
			return This.FindFirstSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#--------------------------------------------------------------#

	def FindFirstSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisPositionZZ(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		def FindFirstSplitAfterThisPositionAsSection(nPos)
			return This.FindFirstSplitAfterPositionZZ(nPos)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThesePositionsZZ(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsZZ(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#--

		def FindFirstSplitAfterPositionsAsSection(anPos)
			return This.FindFirstSplitAfterPositionsZZ(anPos)

		def FindFirstSplitAfterThesePositionsAsSection(anPos)
			return This.FindFirstSplitAfterThesePositionsZZ(anPos)

		def FindFirstSplitAfterManyPositionsAsSection(anPos)
			return This.FindFirstSplitAfterManyPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#---------------------------------------------------------------#

	def FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindFirstSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringZZ(pcSubStr)
		return This.FindFirstSplitAfterSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindFirstSplitAfterSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		def FindFirstSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindFirstSplitAfterSubStringZZ(pcSubStr)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#-------------------------------------------------------------#

	def FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitAfterSubStringsZZ(pacSubStr)
		return This.FindFirstSplitAfterSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		def FindFirstSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindFirstSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindFirstSplitAfterSectionZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionZZ(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSections(n1, n2)
			return This.FindFirstSplitAfterSectionZZ(n1, n2)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#------------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionIBZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindFirstSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		def FindFirstSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindFirstSplitAfterSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindFirstSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsZZ(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSection(paSections)
			return This.FindFirstSplitAfterSectionsZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSection(paSections)
			return This.FindFirstSplitAfterTheseSectionsZZ(paSections)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#-----------------------------------------------------------------------------#

	def FindFirstSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#--

		def FindFirstSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		def FindFirstSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindFirstSplitAfterSectionsIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#========================================================================#

	def FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSection(pBound1, pBound2)
			return This.FindFirstSplitBetweenZZ(pBound1, pBound2)

		#>

	  #--------------------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------------------------------------#

	def FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anFirstBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anFirstBounds, anSecondBounds ]).ReducedToSmallestSize()
			anFirstBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anFirstBounds)
			for i = 1 to nLen
				anFirstBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anFirstBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindFirstSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindFirstSplitBetweenCSIBZZ(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindFirstSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindFirstSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#----------------------------------------------------------#

	def FindFirstSplitBetweenPositionsZZ(n1, n2)
		This.FindFirstSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindFirstSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #-------------------------------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------#

	def FindFirstSplitBetweenPositionsIBZZ(n1, n2)
		This.FindFirstSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindFirstSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		def FindFirstSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindFirstSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #-----------------------------------------------------------#
	 #  FINDING FIRST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#-----------------------------------------------------------#

	def FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindFirstSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindFirstSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindFirstSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindFirstSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindFirstSplitBetweenSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindFirstSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindFirstSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		def FindFirstSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindFirstSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #---------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTION) TO N PARTS    #
	#===================================================#

	def FindFirstSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindFirstSplitToNPartsZZ(nPos)
		return aResult

		def FindFirstSplitToNPartsAsSection(nPos)
			return This.FindFirstSplitToNPartsZZ(nPos)

	  #-------------------------------------------------------#
	 #   FINDING FIRST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#-------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindFirstSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindFirstSplitToPartsOfNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		def FindFirstSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindFirstSplitToPartsOfNCharsZZ(nPos)

		#>

	  #------------------------------------------------------------------------------#
	 #   FINDING FIRST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#------------------------------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindFirstSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindFirstSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult

	  #--------------------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTION) UNDER A GIVEN CONDTION   #
	#==============================================================#

	def FindFirstSplitWZZ(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindFirstSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindFirstSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindFirstSplitBeforeWZZ(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindFirstSplitAfterWZZ(pcCondition[2])

			ok
		
		else

			return This.FindFirstSplitAtWZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindFirstSplitAsSectionW(pcCondition)
			return This.FindFirstSplitWZZ(pcCondition)

		#>

	  #-----------------------------------------------------------#
	 #    FINSING FIRST SPLIT (AS SECTION) AT A GIVEN CONDTION   #
	#-----------------------------------------------------------#

	def FindFirstSplitAtWZZ(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.FindFirstSplitAtSectionsZZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.FindFirstSplitAtPositionsZZ(anPositions)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAtAsSectionW(pcCondition)
			return This.FindFirstSplitAtWZZ(pcCondition)

		#>

	  #----------------------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#----------------------------------------------------------------#

	def FindFirstSplitBeforeWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindFirstSplitBeforePositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitBeforeAsSectionW(pcCondition)
			return This.FindFirstSplitBeforeWZZ(pcCondition)

		#>

	  #--------------------------------------------------------------#
	 #    FINDING FIRST SPLIT (AS SECTION) AFTER A GIVEN CONDTION   #
	#--------------------------------------------------------------#

	def FindFirstSplitAfterWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindFirstSplitAfterPositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindFirstSplitAfterAsSectionW(pcCondition)
			return This.FindFirstSplitAfterWZZ(pcCondition)

		#>

	  #============================#
	 #   FINDING THE LAST SPLIT   #
	#============================#

	def FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSections(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositions(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCS(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNParts(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNChars(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindLastSplitAtW(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindLastSplitBeforeW(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindLastSplitAfterW(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitCSXTZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXT(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXT(pSubStrOrPos)
		return This.FindLastSplitCSXT(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitXTZ(pSubStrOrPos)
			return This.FindLastSplitXT(pSubStrOrPos)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING OR POSITION  #
	#========================================================#

	def FindLastSplitAtCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplit(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPosition(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositions(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSection(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCS(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAt(pSubStrOrPos)
		return This.FindLastSplitAtCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtZ(pSubStrOrPos)
			return This.FindLastSplitAtCS(pSubStr)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN POSITION   #
	#============================================#

	def FindLastSplitAtPosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(nPos)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPosition(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		def FindLastSplitAtThisPositionZ(nPos)
			return This.FindLastSplitAtPosition(nPos)

		#>

	  #------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY POSITIONS   #
	#------------------------------------------#

	def FindLastSplitAtPositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositions(anPos)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositions(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#--

		def FindLastSplitAtPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtThesePositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		def FindLastSplitAtManyPositionsZ(anPos)
			return This.FindLastSplitAtPositions(anPos)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SUBSTRING   #
	#=============================================#

	def FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubString(pcSubStr)
		return This.FindLastSplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplit(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitAtThisSubString(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindLastSplitAtSubStringZ(pcSubStr)
			return This.FindLastSplitAtSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitZ(pcSubStr)
			return This.FindLastSplitCS(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitAtThisSubStringZ(pcSubStr)
			return This.FindLastSplitAtThisSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AT GIVEN SUBSTRINGS   #
	#--------------------------------------------#

	def FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitAtPositions(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStrings(pacSubStr)
		return This.FindLastSplitAtSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)
	
		def FindLastSplitAtManySubStrings(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#--

		def FindLastSplitAtSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		def FindLastSplitAtManySubStringsZ(pacSubStr)
			return This.FindLastSplitAtSubStrings(pacSubStr)

		#>

	  #-------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION   #
	#===========================================#

	def FindLastSplitAtSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSection(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#--

		def FindLastSplitAtSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		def FindLastSplitAtThisSectionZ(n1, n2)
			return This.FindLastSplitAtSection(n1, n2)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#--------------------------------------------------------------#

	def FindLastSplitAtSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIB(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIB(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#--

		def FindLastSplitAtSectionIBZ(n1, n2)
			return This.FindLastSplitAtSectionIB(n1, n2)

		def FindLastSplitAtThisSectionIBZ(n1, n2)
			return This.SplitAtSectionIB(n1, n2)

		#>

	  #-----------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS   #
	#-----------------------------------------#

	def FindLastSplitAtSections(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSections(paSections)
			return This.FindLastSplitAtSections(paSections)

		#--

		def FindLastSplitAtSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		def FindLastSplitAtTheseSectionsZ(paSections)
			return This.FindLastSplitAtSections(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AT MANY SECTIONS -- BOUNDS INCLUDED  #
	#-----------------------------------------------------------#

	def FindLastSplitAtSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsIB(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#--

		def FindLastSplitAtSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		def FindLastSplitAtTheseSectionsIBZ(paSections)
			return This.FindLastSplitAtSectionsIB(paSections)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePosition(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositions(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSection(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSections(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSection(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSections(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBefore(pSubStrOrPos)
		return This.FindLastSplitBeforeCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeZ(pSubStrOrPos)
			return This.FindLastSplitBefore(pSubStrOrPos)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitBeforePosition(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePosition(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPosition(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#--

		def FindLastSplitBeforePositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		def FindLastSplitBeforeThisPositionZ(nPos)
			return This.FindLastSplitBeforePosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitBeforePositions(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositions(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#--

		def FindLastSplitBeforePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeThesePositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		def FindLastSplitBeforeManyPositionsZ(anPos)
			return This.FindLastSplitBeforePositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCS(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubString(pcSubStr)
		return This.FindLastSplitBeforeSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubString(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		def FindLastSplitBeforeThisSubStringZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)	

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositions(anPos)

		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStrings(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCS(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStrings(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		def FindLastSplitBeforeManySubStringsZ(pacSubStr)
			return This.FindLastSplitBeforeSubStrings(pacSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION   #
	#-----------------------------------------------#

	def FindLastSplitBeforeSection(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSection(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSection(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#--

		def FindLastSplitBeforeSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		def FindLastSplitBeforeThisSectionZ(n1, n2)
			return This.FindLastSplitBeforeSection(n1, n2)

		#>

	  #------------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIB(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIB(n1, n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIB(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#--

		def FindLastSplitBeforeSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		def FindLastSplitBeforeThisSectionIBZ(n1, n2)
			return This.FindLastSplitBeforeSectionIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS   #
	#---------------------------------------------#

	def FindLastSplitBeforeSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSections(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSections(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySections(paSections)
			return This.SplitBeforeSections(paSections)

		#--

		def FindLastSplitBeforeSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeTheseSectionsZ(paSections)
			return This.FindLastSplitBeforeSections(paSections)

		def FindLastSplitBeforeManySectionsZ(paSections)
			return This.SplitBeforeSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIB(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIB(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#--

		def FindLastSplitBeforeSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeTheseSectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		def FindLastSplitBeforeManySectionsIBZ(paSections)
			return This.FindLastSplitBeforeSectionsIB(paSections)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN POSITION OR SUBSTRING  #
	#-----------------------------------------------------------#

	def FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCS(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPosition(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPosition(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositions(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCS(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCS(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSection(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSections(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindLastSplitAfterPositions(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindLastSplitAfterSubStrings(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSections(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterCSZ(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfter(pSubStrOrPos)
		return This.FindLastSplitAfterCS(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterZ(pSubStrOrPos)
			return This.FindLastSplitAfterCS(pSubStrOrPos, pCaseSensitive)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN POSITION   #
	#------------------------------------------------#

	def FindLastSplitAfterPosition(nPos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPosition(nPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPosition(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		def FindLastSplitAfterThisPositionZ(nPos)
			return This.FindLastSplitAfterPosition(nPos)

		#>

	  #----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY POSITIONS   #
	#----------------------------------------------#

	def FindLastSplitAfterPositions(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositions(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositions(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#--

		def FindLastSplitAfterPositionsZ(anPos)
			return This.FindLastSplitAfterPositions(anPos)

		def FindLastSplitAfterThesePositionsZ(anPos)
			return This.FindLastSplitAfterThesePositions(anPos)

		def FindLastSplitAfterManyPositionsZ(anPos)
			return This.FindLastSplitAfterManyPositions(anPos)

		#>

	  #-------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN SUBSTRING   #
	#-------------------------------------------------#

	def FindLastSplitAfterSubStringCS(cSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringCSZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubString(pcSubStr)
		return This.FindLastSplitAfterSubStringCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubString(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#--

		def FindLastSplitAfterSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		def FindLastSplitAfterThisSubStringZ(pcSubStr)
			return This.FindLastSplitAfterSubString(pcSubStr)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE MANY SUBSTRINGS   #
	#-----------------------------------------------#

	def FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositions(anPos)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStrings(pacSubStr)
		return This.FindLastSplitAfterSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStrings(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		def FindLastSplitAfterManySubStringsZ(pacSubStr)
			return This.FindLastSplitAfterSubStrings(pacSubStr)

		#>

	  #---------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION  #
	#---------------------------------------------#

	def FindLastSplitAfterSection(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSection(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSection(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#--

		def FindLastSplitAfterSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		def FindLastSplitAfterThisSectionZ(n1, n2)
			return This.FindLastSplitAfterSection(n1, n2)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#----------------------------------------------------------------#

	def FindLastSplitAfterSectionIB(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIB(n1 , n2)
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		#--

		def FindLastSplitAfterSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)

		def FindLastSplitAfterThisSectionIBZ(n1, n2)
			return This.FindLastSplitAfterSectionIB(n1, n2)


		#>

	  #--------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS   #
	#--------------------------------------------#

	def FindLastSplitAfterSections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSections(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSections(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#--

		def FindLastSplitAfterSectionsZ(paSections)
			return This.FindLastSplitAfterSections(paSections)

		def FindLastSplitAfterTheseSectionsZ(paSections)
			return This.FindLastSplitAfterTheseSections(paSections)

		#>

	  #---------------------------------------------------------------#
	 #   FINDING LAST SPLIT AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------#

	def FindLastSplitAfterSectionsIB(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIB(paSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#--

		def FindLastSplitAfterSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		def FindLastSplitAfterTheseSectionsIBZ(paSections)
			return This.FindLastSplitAfterSectionsIB(paSections)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#==========================================================#

	def FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetween(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok
		
		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCS(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetween(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenZ(pBound1, pBound2)
			return This.FindLastSplitBetween(pBound1, pBound2)

		#>

	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIB(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			nResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSections(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenCSIBZ(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIB(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIB(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIB(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenIBZ(pBound1, pBound2)
			return This.FindLastSplitBetweenIB(pBound1, pBound2)

		#>

	  #--------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS  #
	#--------------------------------------------#

	def FindLastSplitBetweenPositions(n1, n2)
		This.FindLastSplitAtSection(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositions(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#--

		def FindLastSplitBetweenPositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		def FindLastSplitBetweenThesePositionsZ(n1, n2)
			return This.FindLastSplitBetweenPositions(n1, n2)

		#>
		
	  #----------------------------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIB(n1, n2)
		This.FindLastSplitAtSectionIB(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#--

		def FindLastSplitBetweenPositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		def FindLastSplitBetweenThesePositionsIBZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIB(n1, n2)

		#>

	  #---------------------------------------------#
	 #  FINDING LAST SPLIT BETWEEN TWO SUBSTRINGS  #
	#---------------------------------------------#

	def FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)
		aSections = This.Find(pacSubStr, pCaseSensitive)
		nResult = This.FindLastSplitBetweenSections(aSections)
		return nResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsCSZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCS(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStrings(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStrings(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsZ(pacSubStr)
			return This.FindLastSplitBetweenSubStrings(pacSubStr)

		#>

	  #-------------------------------------#
	 #    FINDING LAST SPLIT TO N PARTS    #
	#=====================================#

	def FindLastSplitToNParts(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNParts(nPos)
		return nResult

		def FindLastSplitToNPartsZ(nPos)
			return This.FindLastSplitToNParts(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNChars(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositions(nPos)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNChars(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#--

		def FindLastSplitToPartsOfNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		def FindLastSplitToPartsOfExactlyNCharsZ(nPos)
			return This.FindLastSplitToPartsOfNChars(nPos)

		#>

	  #----------------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#----------------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsXT(nPos)
		nResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsXT(nPos)

		return nResult

		def FindLastSplitToPartsOfNCharsXTZ(nPos)
			return This.FindLastSplitToPartsOfNCharsXT(nPos)

+ def FindLastSplitToPartsOfNCHarsWTZZ(nPos)
	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT UNDER A GIVEN CONDTION   #
	#===============================================#

	def FindLastSplitW(pcCondition)
		/*
		? StzSplitterQ(1:5).FindLastSplitW('Q(@item).IsMultipleOf(2)')
		*/

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtW(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeW(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterW(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitWZ(pcCondition)
			return This.FindLastSplitWZ(pcCondition)

		#>

	  #--------------------------------------------#
	 #   FINSING LAST SPLIT AT A GIVEN CONDTION   #
	#--------------------------------------------#

	def FindLastSplitAtW(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok


		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsW(pcCondition)
			nResult = This.FindLastSplitAtSectionsZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			nResult = This.FindLastSplitAtPositionsZ(anPositions)
		ok

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtWZ(pcCondition)
			return This.FindLastSplitAtW(pcCondition)

		#>

	  #------------------------------------------------#
	 #   FINDING LAST SPLIT BEFORE A GIVEN CONDTION   #
	#------------------------------------------------#

	def FindLastSplitBeforeW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindLastSplitBeforePositions(anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeWZ(pcCondition)
			return This.FindLastSplitBeforeW(pcCondition)

		#>

	  #-----------------------------------------------#
	 #   FINDING LAST SPLIT AFTER A GIVEN CONDTION   #
	#-----------------------------------------------#

	def FindLastSplitAfterW(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		nResult = This.FindLastSplitAfterPositions(anPositions)

		return nResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterWZ(pcCondition)
			return This.FindLastSplitAfterW(pcCondition)

		#>

	  #=====================================================#
	 #   FINDING THE LAST SPLIT AS SECTION -- ZZ/EXTENDED  #
	#=====================================================#

	def FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isList(pSubStrOrPos) and Q(pSubStrOrPos).IsUsingNamedParam()
			pSubStrOrPos = pSubStrOrPos[2]
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAtSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- SPLITTING AT / USING

			if oParam.IsOneOfTheseNamedParams([ :At, :Using ])
				return This.FindLastSplitAtCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtPosition, :AtThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AtPositions, :AtThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([
						:AtSubString, :AtThisSubString,
						:UsingSubString, :UsingThisSubString ]) 

				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([
						:AtSubStrings, :AtTheseSubStrings,
						:UsingSubStrings, :UsingTheseSubStrings ]) 

				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AtSection, :AtThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AtSections, :AtTheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING BEFORE

			but oParam.IsBeforeNamedParam()
				return This.FindLastSplitBeforeCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforePosition, :BeforeThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :BeforePositions, :BeforeThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :BeforeSubString, :BeforeThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSubStrings, :BeforeTheseSubStrings ]) 
				return This.SplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :BeforeSection, :BeforeThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :BeforeSections, :BeforeTheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			#-- SPLITTING AFTER

			but oParam.IsAfterNamedParam()
				return This.FindLastSplitAfterCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterPosition, :AfterThisPosition ]) 
				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :AfterPositions, :AfterThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :AfterSubString, :AfterThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSubStrings, :AfterTheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :AfterSection, :AfterThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :AfterSections, :AfterTheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			# SPLITTING BETWEEN

			but oParam.IsBetweenNamedParam() and
				isList(pcSubStrOrPos) and len(pcSubStrOrPos) = 2
				
				if isList(pcSubStrOrPos[2]) and Q(pcSubStrOrPos[2]).IsAndNamedParam()
					pcSubStrOrPos[2] = pcSubStrOrPos[2][2]
				ok

				return This.FindLastSplitBetweenCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			but oParam.IsBetweenPositionsNamedParam()
				return This.FindLastSplitBetweenPositionsZZ(pcSubStrOrPos[1], pcSubStrOrPos[2])

			but oParam.IsBetweenSubStringsNamedParam()
				return This.FindLastSplitBetweenSubStringsCSZZ(pcSubStrOrPos[1], pcSubStrOrPos[2], pCaseSensitive)

			# SPLITTING TO PARTS

			but oParam.IsToNPartsNamedParam()
				return This.FindLastSplitToNPartsZZ(pcSubStrOrPos[2])

			but oParam.IsToPartsOfNCharsNamedParam()
				return This.FindLastSplitToPartsOfNCharsZZ(pcSubStrOrPos[2])

			# SPLITTING WHERE

			but oParam.IsWhereOrAtWhereNamedParam()
				return This.FindLastSplitAtWZZ(pcSubStrOrPos[2])

			but oParam.IsBeforeWhereNamedParam()
				return This.FindLastSplitBeforeWZZ(pcSubStrOrPos[2])

			but oParam.IsAfterWhereNamedParam()
				return This.FindLastSplitAfterWZZ(pcSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionCSXT(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitCSXTZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitXTZZ(pSubStrOrPos)
		return This.FindLastSplitCSXTZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionXT(pSubStrOrPos)
			return This.FindLastSplitXTZZ(pSubStrOrPos)

		#>

	  #---------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING OR POSITION  #
	#=====================================================================#

	def FindLastSplitAtCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAtPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitAtPositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitAtSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitAsSectionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			oParam = Q(pSubStrOrPos)

			#-- Case when named params are provided

			if oParam.IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitAtPositionZZ(pSubStrOrPos[2])
	
			but oParam.IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAtPositionsZZ(pSubStrOrPos[2])

			but oParam.IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAtSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but oParam.IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAtSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but oParam.IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAtSectionZZ(pSubStrOrPos[2])
		
			but oParam.IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAtSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAtCSZZ(pSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtZZ(pSubStrOrPos)
		return This.FindLastSplitAtCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSection(pSubStrOrPos)
			return This.FindLastSplitAtCSZZ(pSubStr)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN POSITION   #
	#=========================================================#

	def FindLastSplitAtPositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect pram type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisPositionAsSection(nPos)
			return This.FindLastSplitAtPositionZZ(nPos)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY POSITIONS  #
	#------------------------------------------------------#

	def FindLastSplitAtPositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ(This.NumberOfChars()).FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtThesePositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsZZ(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#--

		def FindLastSplitAtPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtThesePositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		def FindLastSplitAtManyPositionsAsSection(anPos)
			return This.FindLastSplitAtPositionsZZ(anPos)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SUBSTRING  #
	#=========================================================#

	def FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if NOT IsBoolean(pCaseSensitive)
			StzRaise("Incorrect param type! pCaseSensitive must be a boolean (TRUE or FALSE).")
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringAsSectionsCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAtThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubstr).IsAtOrAtSubStringNamedParam()
				pcSubStr = pcSubstr[2]
			ok

			return This.FindLastSplitAtSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringZZ(pcSubStr)
		return This.FindLastSplitAtSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitAtThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)
		#--

		def FindLastSplitAtSubStringAsSectionZZ(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		def FindLastSplitAtThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAtSubStringZZ(pcSubStr, :CaseSensitive = TRUE)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTIONS) AT GIVEN SUBSTRINGS  #
	#---------------------------------------------------------#

	def FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		anPos = This.FindCS(pacSubStr, pCaseSensitive)

		aResult = This.FindLastSplitAtPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAtSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAtManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAtSubStringsZZ(pacSubStr)
		return This.FindLastSplitAtSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)
	
		def FindLastSplitAtManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAtSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtTheseSubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		def FindLastSplitAtManySubStringsAsSections(pacSubStr)
			return This.FindLastSplitAtSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION   #
	#========================================================#

	def FindLastSplitAtSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionZZ(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSection(n1, n2)
			return This.FindLastSplitAtSectionZZ(n1, n2)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT A GIVEN SECTION -- INCLUDING BOUNDS  #
	#---------------------------------------------------------------------------#

	def FindLastSplitAtSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtThisSectionIBZZ(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAtSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAtSectionIBZZ(n1, n2)

		def FindLastSplitAtThisSectionAsSectionIB(n1, n2)
			return This.SplitAtSectionIBZZ(n1, n2)

		#>

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AT MANY SECTIONS   #
	#------------------------------------------------------#

	def FindLastSplitAtSectionsZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAtSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAtTheseSectionsZZ(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#--

		def FindLastSplitAtSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		def FindLastSplitAtTheseSectionsAsSection(paSections)
			return This.FindLastSplitAtSectionsZZ(paSections)

		#>

	  #-------------------------------------------------------------------------#
	 #   FINDING LAST SPIT (AS SECTION) BEFORE A GIVEN POSITION OR SUBSTRING   #
	#-------------------------------------------------------------------------#

	def FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if isString(pSubStrOrPos)
			return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfStrings()
			return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitBeforePositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfNumbers()
			return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos)

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsPairOfNumbers()
			return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos) and Q(pSubStrOrPos).IsListOfPairsOfNumbers()
			return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[1], pSubStrOrPos[2])

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ]) 
				return This.FindLastSplitBeforePositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitBeforePositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitBeforeSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitBeforeSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitBeforeSectionZZ(pSubStrOrPos[2])
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitBeforeSectionsZZ(pSubStrOrPos[2])

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeZZ(pSubStrOrPos)
		return This.FindLastSplitBeforeCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeAsSection(pSubStrOrPos)
			return This.FindLastSplitBeforeZZ(pSubStrOrPos)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitBeforePositionZZ(nPos)
		if This.IsEmpty()
			return []
		ok

		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThisPositionZZ(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#--

		def FindLastSplitBeforePositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		def FindLastSplitBeforeThisPositionAsSection(nPos)
			return This.FindLastSplitBeforePositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitBeforePositionsZZ(anPos)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)
		return aResult			

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeThesePositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsZZ(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#--

		def FindLastSplitBeforePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeThesePositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		def FindLastSplitBeforeManyPositionsAsSection(anPos)
			return This.FindLastSplitBeforePositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitBeforeThisSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>
				
	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringZZ(pcSubStr)
		return This.FindLastSplitBeforeSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSubStringZZ(pcSubStr)
			return This.FindLastSplitBeforeSubString(pcSubStr)

		#--

		def FindLastSplitBeforeSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)

		def FindLastSplitBeforeThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitBeforeSubStringZZ(pcSubStr)	

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforePositionsZZ(anPos)

		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBeforeSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBeforeManySubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBeforeSubStringsZZ(pacSubStr)
		return This.FindLastSplitBeforeSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)
	
		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsZZ(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBeforeSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		def FindLastSplitBeforeManySubStringsAsSection(pacSubStr)
			return This.FindLastSplitBeforeSubStringsZZ(pacSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION   #
	#------------------------------------------------------------#

	def FindLastSplitBeforeSectionZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionZZ(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSection(n1, n2)
			return This.FindLastSplitBeforeSectionZZ(n1, n2)

		#>

	  #-------------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SECTION -- INCLUDING BOUND   #
	#-------------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionIBZZ(n1, n2)
		if This.IsEmpty()
			return []
		ok

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must be both numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionIBZZ(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeThisSectionIBZZ(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#--

		def FindLastSplitBeforeSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		def FindLastSplitBeforeThisSectionAsSectionsIB(n1, n2)
			return This.FindLastSplitBeforeSectionIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS   #
	#----------------------------------------------------------#

	def FindLastSplitBeforeSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBeforeSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsZZ(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsZZ(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSection(paSections)
			return This.FindLastSplitBeforeSectionsZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSection(paSections)
			return This.SplitBeforeSectionsZZ(paSections)

		#>

	  #---------------------------------------------------------------------------#
	 #   FINING LAST SPLIT (AS SECTION) BEFORE MANY SECTIONS -- INCLUDING BOUND  #
	#---------------------------------------------------------------------------#

	def FindLastSplitBeforeSectionsIBZZ(paSections)
		if This.IsEmpty()
			return []
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).SplitBeforeSectionIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBeforeTheseSectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeManySectionsIBZZ(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		#--

		def FindLastSplitBeforeSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionsIBZZ(paSections)

		def FindLastSplitBeforeTheseSectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		def FindLastSplitBeforeManySectionsAsSectionIB(paSections)
			return This.FindLastSplitBeforeSectionIBZZ(paSections)

		#>

	  #------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN POSITION OR SUBSTRING  #
	#------------------------------------------------------------------------#

	def FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)
		if isString(pSubStrOrPos)
			return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos, pCaseSensitive)

		but isNumber(pSubStrOrPos)
			return This.FindLastSplitAfterPositionZZ(pSubStrOrPos)

		but isList(pSubStrOrPos)

			#-- Case when named params are provided

			if Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Position, :ThisPosition ])

				return This.FindLastSplitAfterPositionZZ(pSubStrOrPos[2])
	
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Positions, :ThesePositions ]) 
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubString, :ThisSubString ]) 
				return This.FindLastSplitAfterSubStringCSZZ(pSubStrOrPos[2], pCaseSensitive)
		
			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :SubStrings, :TheseSubStrings ]) 
				return This.FindLastSplitAfterSubStringsCSZZ(pSubStrOrPos[2], pCaseSensitive)

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Section, :ThisSection ]) 
				return This.FindLastSplitAfterSectionZZ(pSubStrOrPos[2])

			but Q(pSubStrOrPos).IsOneOfTheseNamedParams([ :Sections, :TheseSections ]) 
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos[2])

			#-- Providing numbers, strings, or pairs of numbers,
			#   directly without named params

			but Q(pSubStrOrPos).IsListOfNumbers()
				return This.FindLastSplitAfterPositionsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfStrings()
				return This.FindLastSplitAfterSubStringsZZ(pSubStrOrPos)

			but Q(pSubStrOrPos).IsListOfPairsOfNumbers()
				return This.FindLastSplitAfterSectionsZZ(pSubStrOrPos)

			ok
		else
			StzRaise("Incorrect param type! pSubStrOrPos must be position(s), string(s), or section(s).")
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionCS(pSubStrOrPos, pCaseSensitive)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterZZ(pSubStrOrPos)
		return This.FindLastSplitAfterCSZZ(pSubStrOrPos, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSection(pSubStrOrPos)
			return This.FindLastSplitAfterCSZZ(pSubStrOrPos, pCaseSensitive)

		#>

	  #-------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN POSITION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterPositionZZ(Pos)
		if NOT isNumber(n)
			StzRaise("Incorrect param type! n must be a number.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionZZ(nPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisPositionZZ(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		def FindLastSplitAfterThisPositionAsSection(nPos)
			return This.FindLastSplitAfterPositionZZ(nPos)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY POSITIONS   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterPositionsZZ(anPos)
		if NOT ( isList(anPos) and Q(anPos).IsListOfNumbers() )
			StzRaise("Incorrect param type! anPos must be a list of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThesePositionsZZ(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsZZ(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#--

		def FindLastSplitAfterPositionsAsSection(anPos)
			return This.FindLastSplitAfterPositionsZZ(anPos)

		def FindLastSplitAfterThesePositionsAsSection(anPos)
			return This.FindLastSplitAfterThesePositionsZZ(anPos)

		def FindLastSplitAfterManyPositionsAsSection(anPos)
			return This.FindLastSplitAfterManyPositionsZZ(anPos)

		#>

	  #--------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE A GIVEN SUBSTRING   #
	#--------------------------------------------------------------#

	def FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anPos = This.FindCS(pcSubStr, pCaseSensitive)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringCSZZ(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		def FindLastSplitAfterThisSubStringAsSectionCS(pcSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringZZ(pcSubStr)
		return This.FindLastSplitAfterSubStringCSZZ(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSubStringZZ(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#--

		def FindLastSplitAfterSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		def FindLastSplitAfterThisSubStringAsSection(pcSubStr)
			return This.FindLastSplitAfterSubStringZZ(pcSubStr)

		#>

	  #------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) BEFORE MANY SUBSTRINGS   #
	#------------------------------------------------------------#

	def FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)
		if NOT ( isList(pacSubStr) and Q(pacSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! pacSubStr must be a list of strings.")
		ok

		anPos = This.FindCS( pacSubStr, pCaseSensitive )
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterPositionsZZ(anPos)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitAfterSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitAfterManySubStringsAsSectionCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitAfterSubStringsZZ(pacSubStr)
		return This.FindLastSplitAfterSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitAfterTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitAfterSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		def FindLastSplitAfterManySubStringsAsSectionZZ(pacSubStr)
			return This.FindLastSplitAfterSubStringsZZ(pacSubStr)

		#>

	  #-----------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION   #
	#-----------------------------------------------------------#

	def FindLastSplitAfterSectionZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionZZ(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSections(n1, n2)
			return This.FindLastSplitAfterSectionZZ(n1, n2)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN SECTION -- INCLUDING BOUND  #
	#-----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionIBZZ(n1, n2)

		if NOT BothAreNumbers(n1, n2)
			StzRaise("Incorrect param type! n1 and n2 must both be numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionIBZZ(n1 , n2)
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterThisSectionIBZZ(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#--

		def FindLastSplitAfterSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		def FindLastSplitAfterThisSectionAsSectionIB(n1, n2)
			return This.FindLastSplitAfterSectionIBZZ(n1, n2)

		#>

	  #---------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS   #
	#---------------------------------------------------------#

	def FindLastSplitAfterSectionsZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsZZ(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSection(paSections)
			return This.FindLastSplitAfterSectionsZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSection(paSections)
			return This.FindLastSplitAfterTheseSectionsZZ(paSections)

		#>

	  #----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) AFTER MANY SECTIONS -- INCLUDING BOUNDS  #
	#----------------------------------------------------------------------------#

	def FindLastSplitAfterSectionsIBZZ(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSectiosn must be a list of pairs of numbers.")
		ok

		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitAfterSectionsIBZZ(paSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitAfterTheseSectionsIBZZ(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#--

		def FindLastSplitAfterSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		def FindLastSplitAfterTheseSectionsAsSectionsIB(paSections)
			return This.FindLastSplitAfterSectionsIBZZ(paSections)

		#>

	  #-----------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS  #
	#=======================================================================#

	def FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok
		
		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCS(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCS(pBound1, pBound2, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSection(pBound1, pBound2)
			return This.FindLastSplitBetweenZZ(pBound1, pBound2)

		#>

	  #-------------------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS OR SUBSTRINGS -- INCLUDING BOUNDS  #
	#-------------------------------------------------------------------------------------------#

	def FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)
		if NOT ( BothAreStringsOrNumbers(pBound1, pBound2) )
			StzRaise("Incorrect params types! pBound1 and pBound2 must be both numbers or strings.")
		ok

		if BothAreNumbers(pBound1, pBound2)
			aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitBetweenIBZZ(pBound1, pBound2)

		else # case if BothAreStrings()
			anLastBounds  = This.FindAllCS(pBound1, pCaseSensitive)
			anSecondBounds = This.FindAllCS(pBound2, pCaseSensitive)

			aListOfBounds  = StzListOfListsQ([ anLastBounds, anSecondBounds ]).ReducedToSmallestSize()
			anLastBounds  = aListOfBounds[1]
			anSecondBounds = aListOfBounds[2]

			nLen = len(anLastBounds)
			for i = 1 to nLen
				anLastBounds[i]--
				anSecondBounds[i]++
			next

			aSections = Q(anLastBounds).AssociatedWith(anSecondBounds)

			aResult = StzSplitterQ( This.NumberOfChars() ).
				   FindLastSplitBetweenSectionsZZ(aSections)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionCSIB(pBound1, pBound2, pCaseSensitive)
			return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenIBZZ(pBound1, pBound2)
		return This.FindLastSplitBetweenCSIBZZ(pBound1, pBound2, :CaseSensitive = TRUE)


		#< @FunctionAlternativeForm

		def FindLastSplitBetweenAsSectionIB(pBound1, pBound2)
			return This.FindLastSplitBetweenIBZZ(pBound1, pBound2)

		#>

	  #---------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO POSITIONS  #
	#---------------------------------------------------------#

	def FindLastSplitBetweenPositionsZZ(n1, n2)
		This.FindLastSplitAtSectionZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSection(n1, n2)
			return This.FindLastSplitBetweenPositionsZZ(n1, n2)

		#>
		
	  #------------------------------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTIONS) BETWEEN TWO POSITIONS -- INCLUDING BOUNDS  #
	#------------------------------------------------------------------------------#

	def FindLastSplitBetweenPositionsIBZZ(n1, n2)
		This.FindLastSplitAtSectionIBZZ(n1, n2)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenThesePositionsIBZZ(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#--

		def FindLastSplitBetweenPositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		def FindLastSplitBetweenThesePositionsAsSectionIB(n1, n2)
			return This.FindLastSplitBetweenPositionsIBZZ(n1, n2)

		#>

	  #----------------------------------------------------------#
	 #  FINDING LAST SPLIT (AS SECTION) BETWEEN TWO SUBSTRINGS  #
	#----------------------------------------------------------#

	def FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)
		aSections = This.FindAsSections(pacSubStr, pCaseSensitive)
		aResult = This.FindLastSplitBetweenSectionsZZ(aSections)
		return aResult

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsCSZZ(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#--

		def FindLastSplitBetweenSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		def FindLastSplitBetweenTheseSubStringsAsSectionCS(pacSubStr, pCaseSensitive)
			return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def FindLastSplitBetweenSubStringsZZ(pacSubStr)
		return This.FindLastSplitBetweenSubStringsCSZZ(pacSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def FindLastSplitBetweenTheseSubStringsZZ(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#--

		def FindLastSplitBetweenSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		def FindLastSplitBetweenTheseSubStringsAsSection(pacSubStr)
			return This.FindLastSplitBetweenSubStringsZZ(pacSubStr)

		#>

	  #--------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) TO N PARTS    #
	#==================================================#

	def FindLastSplitToNPartsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).FindLastSplitToNPartsZZ(nPos)
		return aResult

		def FindLastSplitToNPartsAsSection(nPos)
			return This.FindLastSplitToNPartsZZ(nPos)

	  #------------------------------------------------------#
	 #   FINDING LAST SPLIT TO PARTS OF (EXACTLY) N CHARS   #
	#------------------------------------------------------#
	# Remaining part less the n chars is not returned

	def FindLastSplitToPartsOfNCharsZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfExactlyNPositionsZZ(nPos)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitToPartsOfExactlyNCharsZZ(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#--

		def FindLastSplitToPartsOfNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		def FindLastSplitToPartsOfExactlyNCharsAsSection(nPos)
			return This.FindLastSplitToPartsOfNCharsZZ(nPos)

		#>

	  #-----------------------------------------------------------------------------#
	 #   FINDING LAST SPLIT (AS SECTION) TO PARTS OF N CHARS -- INCLUDING BOUNDS   #
	#-----------------------------------------------------------------------------#
	# The remaing part (if any) less then n chars is also returned

	def FindLastSplitToPartsOfNCharsIBZZ(nPos)
		aResult = StzSplitterQ( This.NumberOfChars() ).
				FindLastSplitToPartsOfNPositionsIBZZ(nPos)

		return aResult

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) UNDER A GIVEN CONDTION   #
	#=============================================================#

	def FindLastSplitWZZ(pcCondition)

		if isList(pcCondition)

			if Q(pcCondition).IsWhereNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsAtNamedParam()
				return This.FindLastSplitAtWZZ(pcCondition[2])

			but Q(pcCondition).IsBeforeNamedParam()
				return This.FindLastSplitBeforeWZZ(pcCondition[2])

			but Q(pcCondition).IsAfterNamedParam()
				return This.FindLastSplitAfterWZZ(pcCondition[2])

			ok
		
		else

			return This.FindLastSplitAtWZZ(pcCondition)
		ok

		#< @FunctionAlternativeForm

		def FindLastSplitAsSectionW(pcCondition)
			return This.FindLastSplitWZZ(pcCondition)

		#>

	  #----------------------------------------------------------#
	 #    FINSING LAST SPLIT (AS SECTION) AT A GIVEN CONDTION   #
	#----------------------------------------------------------#

	def FindLastSplitAtWZZ(pcCondition)
			
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		aResult = []

		pcCondition = Q(pcCondition).TrimQ().BoundsRemoved(["{","}"])

		if Q(pcCondition).ContainsCS("@SubString", :CS = FALSE)

			aSections = This.FindSubStringsAsSectionsW(pcCondition)
			aResult = This.FindLastSplitAtSectionsZZ(aSections)

		else

			anPositions = This.FindW(pcCondition)
			aResult = This.FindLastSplitAtPositionsZZ(anPositions)
		ok

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAtAsSectionW(pcCondition)
			return This.FindLastSplitAtWZZ(pcCondition)

		#>

	  #---------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTIONS) BEFORE A GIVEN CONDTION   #
	#---------------------------------------------------------------#

	def FindLastSplitBeforeWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindLastSplitBeforePositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitBeforeAsSectionW(pcCondition)
			return This.FindLastSplitBeforeWZZ(pcCondition)

		#>

	  #-------------------------------------------------------------#
	 #    FINDING LAST SPLIT (AS SECTION) AFTER A GIVEN CONDTION   #
	#-------------------------------------------------------------#

	def FindLastSplitAfterWZZ(pcCondition)
		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", "@substring", :CaseSensitive = FALSE)
			StzRaise("Incorrect syntax! pcCondition must contain either @Char or @SubString keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring",  :CaseSensitive = FALSE)
			anPositions = This.FindSubStringsW(pcCondition)

		else
			anPositions = This.FindCharsW(pcCondition)
		ok

		aResult = This.FindLastSplitAfterPositionsZZ(anPositions)

		return aResult

		#< @FunctionAlternativeForm

		def FindLastSplitAfterAsSectionW(pcCondition)
			return This.FindLastSplitAfterWZZ(pcCondition)

		#>

	  #======================================================#
	 #  PARTIONONING A STRING BASED ON A GIVEN PARTIONNER   #
	#======================================================#

	/* Note:

	This function analyzes the string, by sequentially partitioning
	its content, using a given "partition expression", a "partionner",
	for short. Hence, it serves in answering this kind of question:

	How is the string composed in term of some char criteria
	(the char beeing, for example, lowercase or uppercase, or
	left-oriented or right-oriented).

	The partionner is what we should provide to the method in
	a param as a conditional code containing the @char keyword.

	For example:

	o1 = new stzString("TUNIS gafsa NABEUL beja")
	? o1.Parts(:Using = 'Q(@char).CharCase()' ) # NOTE: Parts() is the simple
						    # form of PartsAsSubstrings()

	Uses the CharCase() method in stzChar as a partionner.	

	And because this method returns a string equal to :Uppercase or
	:Lowercase or NULL, then the classification done will return:

	[
		"TUNIS" = :Uppercase,
		" " = NULL,
		"gafsa" = :Lowercase,
		" " = NULL,
		"NABEUL" = :Uppercase,
		" " = NULL,
		"beja" = :Lowercase
	]

	*/

	def PartsAsSubstrings(pcPartionner)
		/*
		Example:

		o1 = new stzString("Abc285XY&")

		? o1.PartsAsSubstrings( :Using = 'Q(@char).IsLetter()' )
		--> Gives:
		[ "Abc" = TRUE, "285" = FALSE, "XY" = TRUE, "&" = FALSE, "" = TRUE ]

		? o1.PartsAsSubstrings( :Using = 'Q(@char).Orientation()' )
		--> Gives:
		[ "Abc285XY&" = :LeftToRight, "" = :RightToLeft ]

		? o1.PartsAsSubstrings( :Using = 'Q(@char).IsUppercase()' )
		--> Gives:
		[ "A" = TRUE, "bc285" = FALSE, "XY" = TRUE, "&" = FALSE ]

		? o1.PartsAsSubstrings(:Using = 'Q(@char).CharCase()' )
		--> Gives:
		[ "A" = :Uppercase, "bc" = :Lowercase, "285" = NULL, "XY" = :Uppercase, "&" = NULL ]

		*/


		if isList(pcPartionner) and
		   StzListQ(pcPartionner).IsOneOfTheseNamedParams([ :Using, :By, :With ])

			pcPartionner = pcPartionner[2]

			if NOT isString(pcPartionner)
				stzRaise("Incorrect param type!")
			ok
		ok

		if This.NumberOfChars() = 0
			return []
		ok

		cCode = StzStringQ(pcPartionner).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				ReplaceCSQ("@item", "@char", :CaseSensitive = FALSE).
				Content()

		cCode = "cPartionner = ( '' + " + cCode + " )"

		if This.NumberOfChars() = 1
			@char = This.FirstChar()
			eval(cCode)
			aResult = [ @char, cPartionner ]

			return aResult
		ok

		cPart = This.FirstChar()
		aParts = []

		@char = This.FirstChar()
		@i = 1
		eval(cCode)
		cPrevious = cPartionner

		for @i = 2 to This.NumberOfChars()

			cCurrentChar = This.Char(@i)
			oCurrentChar = new stzChar(cCurrentChar)
			@char = cCurrentChar

			eval(cCode)
			cCurrent = cPartionner

			oPreviousChar = new stzChar(This.Char(@i-1))
			@char = oPreviousChar.Content()
			eval(cCode)
			cPrevious = cPartionner

			if cCurrent = cPrevious
				cPart += cCurrentChar

			else
				aParts + [ cPart, cPrevious ]
				cPart = cCurrentChar
			ok

		end

		oLastChar = This.LastCharQ()
		@char = oLastChar.Content()
		eval(cCode)
		aParts + [ cPart, cPartionner ]

		return aParts

		#< @FunctionFluentForm

		def PartsAsSubstringsQ(pcPractionner)
			return PartsAsSubstringsQ(pcPractionner, :stzList)

		def PartsAsSubstringsQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSubstrings(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSubStrings(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForm

		def Parts(pcPartionner)
			return This.PartsAsSubstrings(pcPartionner)

			def PartsQ(pcPartionner)
				return new stzList( This.Parts(pcPartionner) )

		#>

	def PartsAsSections(pcPartionner)
		/*
		o1 = new stzString("TUNIS1250XT")
		? o1.PartsAsSections( :Using = :IsNumber )
		--> Gives
			[
				[ [ 1,  5], FALSE ],
				[ [ 6,  9], TRUE  ],
				[ [10, 11], FALSE ]
			]
		*/

		aParts = This.PartsAsSubstrings(pcPartionner)
	
		aResult = []
		n1 = 1
		n2 = 1
		aSection = []
	
		i = 0
		for aPair in aParts
			i++
			cPart = aPair[1]
			nLenPart = StzStringQ(cPart).NumberOfChars()

			n2 = n1 + nLenPart - 1
			aSection = [n1, n2]
	
			aResult + [ aSection, aPair[2] ]
			n1 += nLenPart
	
		next
	
		return aResult

		def PartsAsSectionsQ(pcPractionner)
			return PartsAsSectionsQ(pcPractionner, :stzList)

		def PartsAsSectionsQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSections(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSections(pcPartionner) )

			on :stzHashList@C
				return new stzHashList( This.PartsAsSectionsSF(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off

	def PartsAsSectionsClassified(pcPartionner)
		oPartsAsSections = This.PartsAsSectionsQ(:stzHashlList)
		aResult = oPartsAsSections.Classify(pcPartionner)

		return aResult

		def PartsAsSectionsClassifiedQ(pcPractionner)
			return PartsAsSectionsClassifiedQR(pcPractionner, :stzList)

		def PartsAsSectionsClassifiedQR(pcPartionner, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnTyp).IsUsingNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.PartsAsSectionsClassified(pcPartionner) )

			on :stzHashList
				return new stzHashList( This.PartsAsSectionsClassified(pcPartionner) )

			other
				stzRaise("Unsupported return type!")
			off

	#--

	def PartsAsSubstringsAndSections(pcPartionner)
		aSubstrings = This.PartsAsSubstrings(pcPartionner)
		aSections   = This.PartsAsSections(pcPartionner)

		aResult = []

		for i = 1 to len(aSubstrings)
			aResult + [ aSubstrings[i][1], aSections[i][1], aSections[i][2] ]
		next

		return aResult

	def PartsAsSectionsAndSubstrings(pcPartionner)
		aSubstrings = This.PartsAsSubstrings(pcPartionner)
		aSections   = This.PartsAsSections(pcPartionner)

		aResult = []

		for i = 1 to len(aSubstrings)
			aResult + [ aSections[i][1], aSubstrings[i][1], aSubstrings[i][2] ]
		next

		return aResult

	  #------------------------------------#
	 #     UNIQUE PARTS OF THE STRING     #
	#------------------------------------#

	def UniqueParts(pcPartionner)
		aResult = This.PartsQ(pcPartionner).DuplicatesRemoved()
		return aResult

		#< @FunctionFluentForms

		def UniquePartsQ(pcPartionner)
			return This.UniquePartsQR(pcPartionner, :stzList)
	
		def UniquePartsQR(pcPartionner, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList(This.UniqueParts(pcPartionner))

			on :stzListOfStrings
				return new stzListOfStrings(This.UniqueParts(pcPartionner))

			other
				stzRaise("Unsupported return type!")
			off


		#>

		#< @FunctionAlternativeForm

		def PartsU(pcPartitionner)
			return This.UniqueParts(pcPartionner)

			def PartsUQ(pcPartionner)
				return This.UniquePartsQ(pcPartionner)

			def PartsUQR(pcPartionner, pcReturnType)
				return This.UniquePartsQR(pcPartionner, pcReturnType)

		def PartsWithoutDuplication(pcPartitionner)
			return This.UniqueParts(pcPartionner)

			def PartsWithoutDuplicationQ(pcPartionner)
				return This.UniquePartsQ(pcPartionner)

			def PartsWithoutDuplicationQR(pcPartionner, pcReturnType)
				return This.UniquePartsQR(pcPartionner, pcReturnType)

		#>

	  #---------------------------------------#
	 #     PARTS OF THE STRING CLASSIFIED    #
	#---------------------------------------#

	def PartsClassified(pcClassifier)
		if isList(pcClassifier) and Q(pcClassifier).IsUsingNamedParam()
			pcClassifier = pcClassifier[2]
		ok

		if NOT isString(pcClassifier)
			stzRaise("Incorrect param type! pcClassifier must be a string.")
		ok

		aResult = This.UniquePartsQ(pcClassifier).
				ToStzHashList().
				Classify()

		return aResult

		def Classified(pcClassifier)
			return This.PartsClassified()

		def Classify(pcClassifier)
			return This.PartsClassified()

	  #-------------------------------------------------------------#
	 #  GETTINING THE PARTS OF STRING VERIFYING A GIVEN CONDITION  # TODO
	#-------------------------------------------------------------#

	def PartsW(pcCondition)
		/* EXAMPLE

		o1 = new stzString("  ")
		? o1.PartsW('{
			Q(@part).Script() = :Cyrillic
		}')
		#--> [ "", "" ]

		*/

		StzRaise("Function unavailable yet!")
		
	  #=============================#
	 #     DIVIDING THE STRING     #
	#=============================#

	def Divide(paByDividor)
		if isList(paByDividor) and Q(paByDividor).IsByNamedParam()
			paByDividor = paByDividor[2]
		ok

		return This.DivideBy(paDividor)

	def DivideBy(pDividor)
		
		switch ring_type(pDividor)

		on "NUMBER"
			This.SplitToNParts(n)

		on "STRING"
			n = This.NumberOfOccurrence(pDividor)
			oTempStr = StzStringQ(pDividor) * n
			
			if oTempStr.IsEqualTo(This.String())
				return n
			else
				oTempStr = ( This.Copy() - oTempStr.Content() )
				nLen = oTempStr.NumberOfChars()
				if oTempStr.IsEqualTo( This.Section(1, n) )
					nResult = n + nLen / StzStringQ(pDividor).NumberOfChars()
					return nResult
				else
					return n
				ok
			ok
		off

	  #=====================================#
	 #   SORTING THE CHARS OF THE STRING   #
	#=====================================#

	def CharsSortingOrder()
		cResult = :Unsorted

		if This.CharsAreSorted()
			if This.CharsAreSortedInAscending()
				cResult = :Ascending
			else
				cResult = :Descending
			ok
		ok

		return cResult

		def SortingOrder()
			return This.CharsSortingOrder()
			

	def HasSameCharsSortingOrderAs(pcOtherStr)

		oTemp = new stzString(pcOtherStr)
		if oTemp.CharsSortingOrder() = This.CharsSortingOrder()
			return TRUE
		else
			return FALSE
		ok

		def HasSameCharsOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

		def HasSameSortingOrderAs(pcOtherStr)
			return This.HasSameCharsSortingOrderAs(pcOtherStr)

	def CharsAreSorted()
		if This.CharsAreSortedInAscending() or
		   This.CharsAreSortedInDescending()
			return TRUE
		else
			return FALSE
		ok

		def IsSorted()
			return This.CharsAreSorted()

	def CharsAreSortedInAscending()
		/*
		The idea is to sort a copy of the string in ascending order
		and then compare the copy to the original string...
		If they are identical, then the string is sorted in ascending order!
		*/

		oSortedInAscending = This.Copy().SortCharsInAscendingQ()
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			if NOT AreEqual([ oSortedInAscending[i] , This.Char(i) ])
				return FALSE
			ok
		next

		return TRUE

		def IsSortedInAscending()
			return This.CharsAreSortedInAscending()

	def CharsAreSortedInDescending()
		/*
		The idea is to reverse the string, and check if its reversed
		copy is sorted in ASCENDING order. If so, then the string itself
		is actually sorted in DESCENDING order!
		*/
		oTemp = new stzString( This.CharsReversed() )
		if oTemp.CharsAreSortedInAscending()
			return TRUE
		else
			return FALSE
		ok

		def IsSortedInDescending()
			return This.CharsAreSortedInDescending()

	def SortCharsInAscending()
		
		aResult = This.CharsQ().SortInAscendingQ().ToStzListOfStrings().Concatenated()

		This.Update( aResult )

		def SortCharsInAscendingQ()
			This.SortCharsInAscending()
			return This

		def SortInAscending()
			This.SortCharsInAscending()

			def SortInAscendingQ()
				This.SortInAscending()
				return This
			
	def StringWithCharsSortedInAscending()
		cResult = This.Copy().SortCharsInAscendingQ().Content()
		return cResult

		def SortedInAscending()
			return This.StringWithCharsSortedInAscending()

		def Sorted()
			return This.SortedInAscending()

	def SortCharsInDescending()
		aReversed = ListReverse( This.SortCharsInAscendingQ().Chars() )
		cResult = StzListOfStringsQ(aReversed).Concatenated()

		This.Update( cResult )

		def SortCharsInDescendingQ()
			This.SortCharsInDescending()
			return This

		def SortInDescending()
			This.SortCharsInDescending()

			def SortInDescendingQ()
				This.SortInDescending()
				return This
			
	def StringWithCharsSortedInDescending()
		cResult = This.Copy().SortCharsInDescendingQ().Content()
		return cResult

		def SortedInDescending()
			return This.StringWithCharsSortedInDescending()

	  #============================================================#
	 #     COMPARING THE STRING TO OTHER STRINGS USING UNICODE    #
	#============================================================#
	# TODO: add Casesensitivity support

	// Compares the main string with an other string (base on the unicode code table)
	// --> Use this for internal string comparisons and sorting
	// --> For lists presented to the user, use SystemLocaleCompare()

	def UnicodeCompareWithCS(pcOtherStr, pCaseSensitive)
		#< QtBased | Uses QString.compare() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		nQtResult = @oQString.compare(pcOtherStr, pCaseSensitive)

	
		if  nQtResult = 0
			return :Equal	# Be careful :Equal is "equal" and not "Equal" with capital "E"

		but nQtResult < 0
			return :Less

		but  nQtResult > 0
			return :Greater
		ok
		/*
		Returns :Equal, :Less, or :Greater:

		:Equal   --> The 2 strings are equal
		:Less    --> The main string is "less" then the substring
		:Greater --> The main string is "greater" then the substring
		
		"less" and "greater" should be understood at the sense
		provided to them by Qt. Read this:
	
		https://doc.qt.io/qt-5/qstring.html#comparing-strings
		*/

	def UnicodeCompareWith(pcOtherStr)
		return This.CompareWithCS(pcOtherStr, :CaseSensitive = TRUE)

	def UnicodeCompareWithInSystemLocale(pcOtherStr)
		nQtResult = @oQString.localeAwareCompare(pcOtherStr)

		if nQtResult = 0
			return :equal
		but nQtResult < 0
			return :less
		but nQtResult > 0
			return :greater
		ok
		/*
		From Qt documentation:
	
		The comparison is performed in a locale- and also
		platform-dependent manner. Use this function to present
		sorted lists of strings to the user.

		NOTE:
		This works only for the current system locale.

		To compare for a defined locale, softanza should rely on
		the QCollator class in RingQt (which is not implemented yet)

		--> TODO: Add QCollator class to RingQt and make CompareWithInLocale()
		*/

	def UnicodeCompareWithInLocale(pcOtherStr, pLocale) # TODO
		// Needs the implementation of QCollator class in RingQt (read comment
		// in SystemLocaleCompareWith() methof above

	def IsUnicodeEqualTo(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Equal

		def IsUnicodeEqualWith(pcOtherStr)
			return This.IsUnicodeEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsUnicodeDifferentFrom(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsUnicodeDifferentWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualTo(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		def IsNotUnicodeEqualWith(pcOtherStr)
			return NOT This.IsUnicodeEqualTo(pcOtherStr)

		#>

	def IsUnicodeEqualToInLocale(pcOtherStr, pLocale)
		return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Equal

		def IsUnicodeDifferentFromInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

		def IsNotUnicodeEqualToInLocale(pcOtherStr, pLocale)
			return NOT This.IsUnicodeEqualToInLocale(pcOtherStr, pLocale)

	def IsUnicodeLessThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Less

		def IsUnicodeLessThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Less
	
	def IsUnicodeGreaterThan(pcOtherStr)
		return This.UnicodeCompareWith(pcOtherNumber) = :Greater

		def IsUnicodeGreaterThanInLocale(pcOtherStr, pLocale)
			return This.UnicodeCompareWithInLocale(pcOtherNumber, pLocale) = :Greater

	  #-----------------------------------------------#
	 #     COMPARING THE STRING TO OTHER STRINGS     #
	#===============================================#

	def IsEqualToCS(pcOtherStr, pCaseSensitive)

		if NOT isString(pcOtherStr)
			return FALSE
		ok

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		if pCaseSensitive = TRUE
			# We do a double-check for potential performance gain
			if This.NumberOfChars() != Q(pcOtherStr).NumberOfChars()
				return FALSE

			else
				return This.String() = pcOtherStr
			ok

		else // pCaseSensitive = FALSE
			return This.Lowercased() = StzStringQ(pcOtherStr).Lowercased()
		ok
		
		def IsEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionNegativeForm

		def IsNotEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		def IsDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsEqualTo(pcOtherStr)
		return This.IsEqualToCS(pcOtherStr, :CaseSensitive = TRUE)

		def IsEqualWith(pcOtherStr)
			return This.IsEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsNotEqualTo(pcOtherStr)
			return NOT This.IsEqualTo(pcOtherStr)

		def IsNotEqualWith(pcOtherStr)
			return NOT This.IsEqualTo(pcOtherStr)

		def IsDifferentFrom(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)
	
		def IsDifferentTo(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)

		def IsDifferentOf(pcOtherStr)
			return This.IsNotEqualTo(pcOtherStr)

		#>

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS STRICTLY EQUAL TO ANOTHER STRING  #
	#--------------------------------------------------------------#

	def IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
		if This.IsEqualToCS(pcOtherStr, pCaseSensitive) and
		   This.HasSameSortingOrderAs(pcOtherStr)

			return TRUE

		else
			return FALSE
		ok

		def IsStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsNotStrictlyEqualWithCS(pcOtherStr, pCaseSensitive)
			return NOT This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentFromCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)
	
		def IsStrictlyDifferentToCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		def IsStrictlyDifferentOfCS(pcOtherStr, pCaseSensitive)
			return This.IsStrictlyEqualToCS(pcOtherStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsStrictlyEqualTo(pcOtherStr)
		return This.IsStrictlyEqualToCS(pcOtherStr, :CaseSensitive = TRUE)

		def IsStrictlyEqualWith(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#< @FunctionNegativeForm

		def IsNotStrictlyEqualTo(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsNotStrictlyEqualWith(pcOtherStr)
			return NOT This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentFrom(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)
	
		def IsStrictlyDifferentTo(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		def IsStrictlyDifferentOf(pcOtherStr)
			return This.IsStrictlyEqualTo(pcOtherStr)

		#>

	  #------------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS EQUAL TO ONE OF THE PROVIDED STRINGS  #
	#------------------------------------------------------------------#

	def IsEqualToOneOfTheseCS(pacOtherStr, pCaseSensitive)
		bResult = TRUE
		for str in pacOtherStr
			if NOT This.IsEqualToCS(str, pCaseSensitive)
				bResult = FALSE
				exit
			ok
		next
		return bResult

	#-- WITHOUT CASESENSITIVITY

	def IsEqualToOneOfThese(pacOtherStr)
		return This.IsEqualToOneOfTheseCS(pacOtherStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS SMALLER THAN THE PROVIDED STRING  #
	#--------------------------------------------------------------#

	def IsSmaller(pcOtherStr)
		if isList(pcOtherStr) and Q(pcOtherStr).IsThanNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		return This.IsIncludedIn(pcOtherStr)

		#< @FunctionAlternativeForms

		def IsSmallerThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def IsLessThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def HasLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessNumberOfCharsThan(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		def ContainsLessChars(pcOtherStr)
			return This.IsSmaller(pcOtherStr)

		#>

	def IsLarger(pcOtherStr)
		return This.Contains(pcOtherStr)

		#< @FunctionAlternativeForms

		def IsLargerThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def ContainsMoreNumberOfCharsThan(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		def HasMoreChars(pcOtherStr)
			return This.IsLarger(pcOtherStr)

		#>

	def IsQuietEqualTo(pcOtherStr)
		# WARNING: Performance issue is caused by DiacriticsRemoved()

		cThisString = This.LowercaseQ().ToStzText().DiacriticsRemoved()

		cOtherString = StzStringQ(pcOtherStr).LowercaseQ().ToStzText().DiacriticsRemoved()

		if cThisString = cOtherString
			return TRUE
		ok

		nDif = abs(This.NumberOfChars() - StzStringQ(pcOtherStr).NumberOfChars())
		n = nDif / This.NumberOfChars()
		
		if n <= QuietEqualityRatio() # 0.09 by default, can be changed with SetQuietEqualityRatio(n)
			return TRUE
		ok

		return FALSE

	  #-------------------------------------------------#
	 #     STRING IS A MULTIPLE OF AN OTHER STRING     #
	#-------------------------------------------------#

	def IsMultipleOfCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		n = This.NumberOfOccurrenceCS( pcSubStr, pCaseSensitive )

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsMultipleOf(pcSubStr)
		return This.IsMultipleOfCS(pcSubStr, :CaseSensitive = TRUE)

	def IsNTimesMultipleOfCS(n, pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			return FALSE
		ok

		oStr = StzStringQ(pcSubStr) * n

		return oStr.IsEqualToCS(This.String(), pCaseSensitive)

	def IsNTimesMultipleOf(n, pcSubStr)
		return This.IsNTimesMultipleOfCS(n, pcSubStr, :CaseSensitive = TRUE)

	  #------------------------------------------------#
	 #     STRING IS A SPLITTER OF AN OTHER STRING    #
	#------------------------------------------------#

	def IsSplitterOfCS(pcOtherStr, pCaseSensitive)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		bResult = StzStringQ(pcOtherStr).NumberOfOccurrenceCS( This.String(), pCaseSensitive ) > 1
		return bResult

	def IsSplitterOf(pcOtherStr)
		bResult = This.IsSplitterOfCS(pcOtherStr, :CaseSensitive = TRUE)
		return bResult

	  #---------------------------------------------------#
	 #     STRING IS SPLITTABLE USING AN OTHER STRING    #
	#---------------------------------------------------#

	def IsSplittableUsingCS(pcSubStr)
		if Not isString(pcOtherStr)
			return FALSE
		ok

		return Q(pcSubStr).IsSplitterOfCS( This.String(), pCaseSensitive )

	def IsSplittableUsing(pcSubStr)
		return This.IsSplittableUsingCS(pcSubStr, pCaseSensitive)

	  #==============================#
	 #    REMOVING ALL SUBSTRINGS   # 
	#==============================#

	def RemoveCS(pSubStr, pCaseSensitive)
		This.ReplaceCS(pSubstr, "", pCaseSensitive)

		def RemoveCSQ(pSubStr, pCaseSensitive)
			This.RemoveCS(pSubStr, pCaseSensitive)
			return This

	def RemovedCS(pSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveCSQ(pSubStr, pCaseSensitive).Content()
		return cResult
		
	#-- WITHOUT CASESENSITIVITY

	def Remove(pcSubStr) # replace with @oQString.remove() when added to RingQt
		This.ReplaceAll(pcSubStr , "")

		def RemoveQ(pcSubStr)
			This.Remove(pcSubStr)
			return This
	
	def Removed(pSubStr)
		cResult = This.Copy().RemoveCSQ(pSubStr).Content()
		return cResult

	  #----------------------------------------------#
	 #   REMOVING SOME OCCURRENCES OF A SUBSTRING   #
	#----------------------------------------------#

	def RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		/*
		o1 = new stzString("ring __ ring __ ring __ ring")
		o1.RemoveOccurrences([2, 3], "ring")
		? o1.Content() #--> "ring __  __  __ ring"
		*/

		anPos = This.FindOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtPositionsCS(anPos, pcSubStr, pCaseSensitive)

		def RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			return This

		def RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)
			This.RemoveOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

			def RemoveTheseOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive)
				This.RemoveTheseOccurrencesCS(panOccurr, pcSubStr, pCaseSensitive)

	def TheseOccurrencesRemovedCS(panOccurr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveOccurrencesCSQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveOccurrences(panOccurr, pcSubStr)
		This.RemoveOccurrencesCS(panOccurr, pcSubStr, :CaseSensitive = TRUE)

		def RemoveOccurrencesQ(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)
			return This

		def RemoveTheseOccurrences(panOccurr, pcSubStr)
			This.RemoveOccurrences(panOccurr, pcSubStr)

			def RemoveTheseOccurrencesQ(panOccurr, pcSubStr)
				This.RemoveTheseOccurrences(panOccurr, pcSubStr)

	def TheseOccurrencesRemoved(panOccurr, pcSubStr)
		return This.Copy().RemoveOccurrencesQ(panOccurr, pcSubStr, pCaseSensitive).Content()

	  #-------------------------------------------------#
	 #   REMOVING FIRST N OCCURRENCES OF A SUBSTRING   #
	#-------------------------------------------------#

	def RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		This.RemoveTheseOccurrencesCS( 1 : n, pcSubStr, pCaseSensitive )

		def RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.FirstNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstNOccurrences(n, pcSubStr)
		This.RemoveFirstNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveFirstNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNFirstOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNFirstOccurrences(n, pcSubStr, pCaseSensitive)

	def FirstNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveFirstNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NFirstOccurrencesRemoved(n, pcSubStr)
			return This.FirstNOccurrencesRemoved(n, pcSubStr)

	  #------------------------------------------------#
	 #   REMOVING LAST N OCCURRENCES OF A SUBSTRING   #
	#------------------------------------------------#

	def RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)
		nNumberOfOccurr = This.NumberOfOccurrencesCS(pcSubStr, pCaseSensitive)
		n1 = nNumberOfOccurr - n + 1
		This.RemoveTheseOccurrencesCS( n1 : nNumberOfOccurr , pcSubStr, pCaseSensitive )

		def RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesCS(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrencesCS(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastNOccurrencesCSQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.LastNOccurrencesRemovedCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastNOccurrences(n, pcSubStr)
		This.RemoveLastNOccurrencesCS(n, pcSubStr, :CaseSensitive = TRUE)

		def RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive)
			return This

		def RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)
			This.RemoveLastNOccurrences(n, pcSubStr, pCaseSensitive)

			def RemoveNLastOccurrencesQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNLastOccurrences(n, pcSubStr, pCaseSensitive)

	def LastNOccurrencesRemoved(n, pcSubStr)
		return This.Copy().RemoveLastNOccurrencesQ(n, pcSubStr, pCaseSensitive).Content()

		def NLastOccurrencesRemoved(n, pcSubStr)
			return This.LastNOccurrencesRemoved(n, pcSubStr)

	  #----------------------------------------------#
	 #   REMOVING MANY SUBSTRING AT THE SAME TIME   #
	#----------------------------------------------#

	def RemoveManyCS(pacSubStr, pCaseSensitive)
		for cSubstr in paCsubstr
			This.RemoveAllCS(cSubstr, pCaseSensitive)
		next

		def RemoveManyCSQ(pacSubStr, pCaseSensitive, pCaseSensitive)
			This.RemoveManyCS(pacSubStr, pCaseSensitive)
			return This

		def RemoveAllOfTheseCS(pacSubStr, pCaseSensitive)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseCSQ(pacSubStr, pCaseSensitive)
				This.RemoveAllOfTheseCS(pacSubstr, pCaseSensitive)
				return This

		def RemoveManySubstringsCS(pcSubStr, pCaseSensitive)
			This.RemoveAllCS(pcSubStr, pCaseSensitive)

			def RemoveManySubstringsCSQ(pSubStr, pCaseSensitive)
				This.RemoveManySubstringsCS(pSubStr, pCaseSensitive)
				return This

	def ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)
		return This.Copy().RemoveManySubstringsCS(pacSubStr, pCaseSensitive).Content()

		def SubstringsRemovedCS(pacSubStr, pCaseSensitive)
			return This. ManySubstringsRemovedCS(pacSubStr, pCaseSensitive)

	#-- CASESENSITIVE

	def RemoveMany(pacSubStr)
		for cSubstr in paCsubstr
			This.RemoveAll(cSubstr)
		next

		def RemoveManyQ(pacSubStr)
			This.RemoveMany(pacSubstr)
			return This

		def RemoveAllOfThese(pacSubstr)
			This.RemoveMany(pacSubStr)

			def RemoveAllOfTheseQ(pacSubstr)
				This.RemoveAllOfThese(pacSubstr)
				return This

		def RemoveManySubstrings(pcSubStr)
			This.RemoveMany(pacSubStr)

			def RemoveManySubstringsQ(pSubStr)
				This.RemoveManySubstrings(pSubStr, pCaseSensitive)
				return This

	def ManySubstringsRemoved(pacSubStr)
		return This.Copy().RemoveManySubstrings(pacSubStr).Content()

		def SubstringsRemoved(pacSubStr)
			return This. ManySubstringsRemoved(pacSubStr)

	  #========================================================================#
	 #  REMOVING ALL OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS  #
	#========================================================================#

	def RemoveBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This.InBetweenRemovedCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetween(pcSubStr,pcBound1, pcBound2)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, :CaseSensitive = TRUE)
		
		#< @FunctionFluentForm

		def RemoveBetweenQ(pcSubStr,pcBound1, pcBound2)
			This.RemoveBetween(pcSubStr,pcBound1, pcBound2)
			return This

		#>

	def InBetweenRemoved(pcSubStr, pcBound1, pcBound2)
		return This.InBetweenRemovedCS(pcSubStr, pcBound1, pcBound2, :CaseSensitiVE = TRUE)

		def SubStringInBetweenRemoved(pcSubStr,pcBound1, pcBound2)
			return This.InBetweenRemoved(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------------------------------------#
	 #  REMOVING A SUBSTRING BETWEEN TWO BOUNDS STARTING AT A GIVEN POSITION  #
	#------------------------------------------------------------------------#

	def RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		aSections = This.FindBetweenAsSectionsSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		This.RemoveSections(aSections)
	
		#< @FunctionFluentForm

		def RemoveBetweenSCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	def InBetweenRemovedSCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenSCSQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInBetweenRemovedSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.InBetweenRemovedSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVE

	def RemoveBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		This.RemoveBetweenSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)
	
		#< @FunctionFluentForm

		def RemoveBetweenSQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveBetweenS(pcSubStr, pcBound1, pcBound2)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveSubStringBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.RemoveBetweenS(pcSubStr, pcBound1, pcBound2, pnStartingAt)

		#>

	def InBetweenRemovedS(pcSubStr,pcBound1, pcBound2)
		cResult = This.Copy().RemoveBetweenSQ(pcSubStr,pcBound1, pcBound2).Content()
		return cResult

		#< @FunctionAlternativeForm

		def SubStringInBetweenRemovedS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.InBetweenRemovedS(pcSubStr, pcBound1, pcBound2, pnStartingAt)

		#>

	  #-----------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- IB/EXTENDED  #
	#-----------------------------------------------------------------------------------#
	# NOTE: encolsing substrings (bounds) are also removed

	def RemoveBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenCSIBQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			This.RemoveBetweenCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenCSIBQ(pcSubStr,pcBound1, pcBound2, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)
			return This.InBetweenRemovedCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetweenIB(pcSubStr, pcBound1, pcBound2)
		return This.RemoveBetweenCSIB(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveBetweenIBQ(pcSubStr,pcBound1, pcBound2)
			This.RemoveBetweenIB(pcSubStr,pcBound1, pcBound2)
			return This

		#>

	def InBetweenRemovedIB(pcSubStr, pcBound1, pcBound2)
		return This.InBetweenRemovedCSIB(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE)

		def SubStringInBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)
			return This.InBetweenRemovedIB(pcSubStr,pcBound1, pcBound2)

	  #----------------------------------------------------------------------------------#
	 #  REMOVING OCCURRENCES OF A SUBSTRING BETWEEN TWO OTHER SUBSTRINGS -- S/EXTENDED  #
	#----------------------------------------------------------------------------------#

	def RemoveBetweenIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

		aSections = This.FindBetweenAsSectionsSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		nLenSections = len(aSections)

		nLen1 = Q(pcBound1).NumberOfChars()
		nLen2 = Q(pcBound2).NumberOfChars()

		for i = 1 to nLenSections
			n1 = aSections[i][1] - nLen1
			n2 = aSections[i][2] + nLen2
			aSections[i] = [n1, n2]
		next

		This.RemoveSections(aSections)

		#< @FunctionFluentForm

		def RemoveBetweenIBSCSQ(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			This.RemoveBetweenIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This

		#>

	def InBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
		cResult = This.Copy().RemoveBetweenIBSCSQ(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive).Content()
		return cResult

		def SubStringInBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)
			return This.InBetweenRemovedIBSCS(pcSubStr,pcBound1, pcBound2, pnStartingAt, pCaseSensitive)

	#-- WITHOUT CASESENSITIViTY

	def RemoveBetweenIBS(pcSubStr, pcBound1, pnStartingAt, pcBound2)
		return This.RemoveSubStringBetweenIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveBetweenIBSQ(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			This.RemoveBetweenIBS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
			return This

		#>

	def InBetweenRemovedIBS(pcSubStr, pcBound1, pcBound2, pnStartingAt)
		return This.InBetweenRemovedIBSCS(pcSubStr, pcBound1, pcBound2, pnStartingAt, :CaseSensitive = TRUE)

		def SubStringInBetweenRemovedIBS(pcSubStr,pcBound1, pcBound2, pnStartingAt)
			return This.InBetweenRemovedIBS(pcSubStr,pcBound1, pcBound2, pnStartingAt)

	  #====================================#
	 #  REMOVING A SUBSTRING -- EXTENDED  #
	#====================================#

	def RemoveCSXT(p1, p2, pCaseSensitive)

		# Q("/\__/\/\__/\__").RemoveXT("", [])
		if isString(p1) and

			( (isList(p2)   and len(p2) = 0) or
			  (isString(p2) and p2 = "") or
			  (isNumber(p2) and p2 = 0) )

			This.RemoveCS(p1, pCaseSensitive)
			return

		# Q("/\__/\/\__/\__").RemoveXT([], "")
		but isString(p2) and

			( (isList(p1)   and len(p1) = 0) or
			  (isString(p1) and p1 = "") or
			  (isNumber(p1) and p1 = 0) )

			This.RemoveCS(p2, pCaseSensitive)
			return

		# Q("/\__/\__/\__/\__").RemoveXT(:Nth = 4, "")
		but isString(p2) and

		    ( isList(p1) and len(p1) = 2 and
		      isString(p1[1]) and p1[1] = :Nth and
		      isNumber(p1[2]) )

			This.RemoveNthCS(p1[2], p2, pCaseSensitive)
		ok


		if isList(p1) and Q(p1).IsEachNamedParam()
			p1 = p1[2]
		ok


		if isList(p2)
			oP2 = new stzList(p2)

			if oP2.IsAtNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				but isList(p2) and Q(p2).IsListOfNumbers()
					This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number or a list of numbers.")
				ok
					
			# Q("^^^^").RemoveXT( "", :AtPosition = 4)
			but oP2.IsAtPositionNamedParam()
				p2 = p2[2]

				if isNumber(p2)
					This.RemoveSubStringAtPositionCS(p2, p1, pCaseSensitive)

				else
					StzRaise("Incorrect param type! p2 must be a number.")
				ok
	
			#-- Removing at many positions
			# TODO: Add example here for better readability
			but oP2.IsAtPositionsNamedParam()
				p2 = p2[2]
	
				if NOT ( isList(p2) and Q(p2).IsListOfNumbers() )
					stzRaise("Incorrect param type! p2 must be a list of numbers.")
				ok
	
				This.RemoveSubStringAtPositionsCS(p2, p1, pCaseSensitive)

			# Removing from, Nth from, First from, Last from
			# TODO: Add examples here for better readability
			but oP2.IsFromNamedParam()
				p2 = p2[2]

				# Removing from

				if isString(p1)
					cNewSubStr =  ( Q(p2) - p1 ).Content()
	
				# Removing Nth from

				but isList(p1) and Q(p1).IsNthNamedParam()
					n = p1[2][1]
					p1 = p1[2][2]

					cNewSubStr = Q(p2).
							RemoveNthCSQ(n, p1, pCaseSensitive).
							Content()

				# Removing first from

				but isList(p1) and Q(p1).IsFirstNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveFirstCSQ(p1, pCaseSensitive).
							Content()

				but isList(p1) and Q(p1).IslastNamedParam()
					p1 = p1[2]

					cNewSubStr = Q(p2).
							RemoveLastCSQ(p1, pCaseSensitive).
							Content()

				ok

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing after
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :After, :AfterEach  ])

				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing after nth
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterNth ])
				n = p2[2][1]
				p2 = p2[2][2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing after first
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterFirst, :ToFirst ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing atfer last
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :AfterLast, :ToLast ])
				p2 = p2[2] + p1
				cNewSubStr = Q(p2).RemoveFromEndQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing Before
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Before, :BeforeEach  ])

				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before nth
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeNth ])
				n = p2[2][1]
				p2 = p1 + p2[2][2]
				
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceCS(p2, cNewSubStr, pCaseSensitive)

			# Removeing before first
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeFirst, :ToFirst ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceFirstCS(p2, cNewSubStr, pCaseSensitive)

			# Removing before last
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :BeforeLast, :ToLast ])
				p2 = p1 + p2[2]
				cNewSubStr = Q(p2).RemoveFromStartQ(p1).Content()

				This.ReplaceLastCS(p2, cNewSubStr, pCaseSensitive)

			#==

			# Removing around
			# TODO: Add example here for better readability
			but oP2.IsOneOfTheseNamedParams([ :Around, :AroundEach ])
				p2 = p2[2]

				if isList(p1) and Q(p1).IsPairOfStrings()

					This.ReplaceCS(
						(p1[1] + p2 + p1[2]),
						p2,
						pCaseSensitive)

				else	
					This.ReplaceCS(
						(p1 + p2 + p1),
						p2,
						pCaseSensitive)
				ok

			# Removing around nth
			# TODO: Add example here for better readability
			but oP2.IsAroundNthNamedParam()
				
				n = p2[2][1]
				p2 = p2[2][2]

				if isString(n)
					if n = :First
						n = 1

					but n = :Last
						n = This.NumberOfOccurrenceCS(p2, pCaseSensitive)
					ok
				ok

				if NOT isNumber(n)
					StzRaise("Incorrect param! n must be a number.")
				ok

				if NOT isString(p2)
					StzRaise("Incorrect param! p2 must be a string.")
				ok

				# Forcing p1 to be a pair of lists

				if isString(p1)
					aTemp = []
					aTemp + p1 + p1
					p1 = aTemp	
				ok

				if NOT isList(p1) and Q(p1).ISPairOfStrings()
					StzRaise("Incorrect param type! p1 must be a string or a pair of strings.")
				ok

				# Finding the section of the nth substring

				anSection = This.FindNthAsSection(n, p2)
				
				n1 = anSection[1] - Q(p1[1]).NumberOfChars()
				n2 = anSection[2] + Q(p1[2]).NumberOfChars()
				
				# If the substring is really bounded by the substrings to remove
				# then we make the necessary to remove them from the string

				if This.Section(n1, anSection[1] - 1) = p1[1] and
				   This.Section(anSection[2] + 1, n2) = p1[2]
				
					This.ReplaceSection(n1, n2, p2)
				ok

				# Otherwise, we do nothing.

			# Removing around first
			# TODO: Add example for better readability
			but oP2.IsAroundFirstNamedParam()
				RemoveXT(p1, :AroundNth = [1, p2[2]])

			# Removing around last

			but oP2.IsAroundLastNamedParam()
				RemoveXT(p1, :AroundNth = [:Last, p2[2]])

			#-- Removing between

			# Q("__/\/\__/\__").RemoveXT("", :Between = ["/","\"])
			# Q("__/\/\__/\__").RemoveXT("", :BetweenIB = ["/","\"])
			but oP2.IsOneOfTheseNamedParams([
				:Between, :BetweenIB, :BetweenS, :BetweenIBS ])

				cBetween = p2[1]
				p2  = p2[2]

				if isList(p2) and len(p2) = 2 and
				   isList(p2[2]) and p2[2][1] = :And

					p2[2] = p2[2][2]
				ok

				if NOT ( isList(p2) and Q(p2).IsPairOfStrings() )
					stzRaise("Incorrect param type! p2 must be a pair of strings.")
				ok

				if isString(p1) and p1 != ""
					if cBetween = :Between
						This.RemoveBetweenCS(p1, p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveBetweenCSIB(p1, p2[1], p2[2], pCaseSensitive)
		
					ok

				but (isList(p1) and len(p1) = 0) or
				    (isString(p1) and p1 = "") or
				    (isNumber(p1) and p1 = 0)

					if cBetween = :Between
						This.RemoveAnyBetweenCS(p2[1], p2[2], pCaseSensitive)
	
					but cBetween = :BetweenIB
						This.RemoveAnyBetweenCSIB(p2[1], p2[2], pCaseSensitive)
		
					ok
	
				ok

	
			# Q("__/\/\__^^^^__").RemoveXT("", :BoundedBy = "^^")
			# Q("__/\/\__^^^^__").RemoveXT("", :BoundedByIB = "^^")
			but oP2.IsBoundedByNamedParam() or
			    oP2.IsBoundedByIBNamedParam()

				cBounded = p2[1]

				cBound1 = ""
				cBound2 = ""

				if isString(p2[2])
					cBound1 = p2[2]
					cBound2 = p2[2]

				but isList(p2[2]) and Q(p2[2]).IsPairOfStrings()
					cBound1 = p2[2][1]
					cBound2 = p2[2][2]

				but isList(p2[2]) and len(p2[2]) = 2 and
				    isString(p2[2][1]) and
				    isList(p2[2][2]) and Q(p2[2][2]).IsAndNamedParam()

					cBound1 = p2[2][1]
					cBound2 = p2[2][2][2]

				ok

				if cBounded = :BoundedBy
					This.RemoveCSXT( p1, :Between = [ cBound1, cBound2 ], pCaseSensitive)

				but cBounded = :BoundedByIB
					This.RemoveCSXT( p1, :BetweenIB = [ cBound1, cBound2 ], pCaseSensitive)

				ok

			ok
		ok

		def RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive)
			This.RemoveCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
			return This

	def RemovedCSXT(pcNewSubStr, pcSubStr, pCaseSensitive)
		return This.Copy().RemoveCSXTQ(pcNewSubStr, pcSubStr, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveXT(pcNewSubStr, pcSubStr)
		This.RemoveCSXTQ(pcNewSubStr, pcSubStr, :CaseSensitive = TRUE)

		def RemoveXTQ(pcNewSubStr, pcSubStr)
			This.RemoveXT(pcNewSubStr, pcSubStr)
			return This

	def RemovedXT(pcNewSubStr, pcSubStr)
		return This.Copy().RemoveXTQ(pcNewSubStr, pcSubStr).Content()

	  #---------------------------------------#
	 #   REMOVING CHAR AT A GIVEN POSITION   #
	#---------------------------------------#

	def RemoveCharAtPosition(n)
		This.ReplaceNthChar(n, "")

		def RemoveCharAtPositionQ(n)
			This.RemoveCharAtPosition(n)
			return This

		def RemoveCharAt(n)
			This.RemoveCharAtPosition(n)

			def RemoveCharAtQ(n)
				This.RemoveCharAt(n)
				return This

		def RemoveNthChar(n)
			This.RemoveCharAtPosition(n)

			def RemoveNthCharQ(n)
				This.RemoveNthChar(n)
				return This

	def CharAtPositionNRemoved(n)
		return This.Copy().RemoveCharAtPositionQ(n).Content()

		def CharAtNPositionRemoved(n)
			return This.CharAtPositionRemoved(n)

		def NthCharRemoved(n)
			return This.CharAtPositionRemoved(n)

	  #=========================#
	 #   REMOVING FIRST CHAR   #
	#=========================#

	def RemoveFirstChar()
		This.RemoveNthChar(1)

		def RemoveFirstCharQ()
			This.RemoveFirstChar()
			return This

	def FirstCharRemoved()
		return This.Copy().RemoveFirstCharQ().Content()

	  #-----------------------#
	 #   REMOVING LAST CHAR  #
	#-----------------------#

	def RemoveLastChar()
		This.RemoveNthChar(This.NumberOfChars())

		def RemoveLastCharQ()
			This.RemoveLastChar()
			return This

	def LastCharRemoved()
		return This.Copy().RemoveLastCharQ().Content()

	  #----------------------------------#
	 #   REMOVING FIRST AND LAST CHARS  #
	#----------------------------------#

	def RemoveFirstAndLastChars()
		This.RemoveFirstChar()
		This.RemoveLastChar()

		#< @FunctionFluentForm

		def RemoveFirstAndLastCharsQ()
			This.RemoveFirstAndLastChars()
			return This

		#>

		#< @FunctionAlternativeForms

		def RemoveLastAndFirstChars()
			This.RemoveFirstAndLastChars()

			def RemoveLastAndFirstCharsQ()
				This.RemoveLastAndFirstChars()
				return This

		#--

		def RemoveFirstCharAndLastChar()
			This.RemoveFirstAndLastChars()

			def RemoveFirstCharAndLastCharQ()
				This.RemoveFirstCharAndLastChar()
				return This

		def RemoveLastCharAndFirstChar()
			This.RemoveFirstAndLastChars()

			def RemoveLastCharAndFirstCharQ()
				This.RemoveLastCharAndFirstChar()
				return This

		#>

	def FirstAndLastCharsRemoved()
		return This.Copy().RemoveFirstAndLastCharsQ().Content()

		def LastAndFirstCharsRemoved()
			return This.FirstAndLastCharsRemoved()

		#--

		def FirstCharAndLastCharRemoved()
			return This.FirstAndLastCharsRemoved()

		def LastCharAndFirstCharRemoved()
			return This.FirstAndLastCharsRemoved()

	  #-----------------------------------------------------------------------------#
	 #  REMOVING A GIVEN CHAR AT A GIVEN POSITION (IF ANY) WITH A GIVEN SUBSTRING  #
	#-----------------------------------------------------------------------------#

	def RemoveThisNthCharCS(n, cChar, pCaseSensitive)
		if isString(cChar) and This.NthCharQ(n).IsEqualToCS(cChar, pCaseSensitive)
			This.RemoveNthChar(n)
		ok

		def RemoveThisNthCharCSQ(n, cChar, pCaseSensitive)
			This.RemoveThisNthCharCS(n, cChar, pCaseSensitive)
			return This

	def ThisNthCharRemovedCS(n, cChar, pCaseSensitive)
		return This.Copy().RemoveThisNthCharCSQ(n, cChar, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisNthChar(n, cChar)
		This.RemoveThisNthCharCS(n, cChar, :CaseSensitive = TRUE)

		def RemoveThisNthCharQ(n, cChar)
			This.RemoveThisNthChar(n, cChar)
			return This

	def ThisNthCharRemoved(n, cChar)
		return This.Copy().RemoveThisNthCharQ(n, cChar).Content()

	  #---------------------------------#
	 #   REMOVING A GIVEN FIRST CHAR   #
	#---------------------------------#

	def RemoveThisFirstCharCS(c, pCaseSensitive)
		if This.FirstCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveFirstChar()
		ok

		def RemoveThisFirstCharCSQ(c, pCaseSensitive)
			This.RemoveThisFirstCharCS(c, pCaseSensitive)
			return This

	def ThisFirstCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisFirstCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisFirstChar(c)
		This.RemoveThisFirstCharCS(c, :CaseSensitive = TRUE)

		def RemoveThisFirstCharQ(c)
			This.RemoveThisFirstChar(c)
			return This

	def ThisFirstCharRemoved(c)
		return This.Copy().RemoveThisFirstCharQ(c).Content()

	  #--------------------------------#
	 #   REMOVING A GIVEN LAST CHAR   #
	#--------------------------------#

	def RemoveThisLastCharCS(c, pCaseSensitive)
		if This.LastCharQ().IsEqualToCS(c, pCaseSensitive)
			This.RemoveLastChar()
		ok

		def RemoveThisLastCharCSQ(c, pCaseSensitive)
			This.RemoveThisLastCharCS(c, pCaseSensitive)
			return This

	def ThisLastCharRemovedCS(c, pCaseSensitive)
		return This.Copy().RemoveThisLastCharCSQ(c, pCaseSensitive).Content()

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisLastChar(c)
		This.RemoveThisLastCharCS(c, :CaseSensitive = TRUE)

		def RemoveThisLastCharQ(c)
			This.RemoveThisLastChar(c)
			return This

	def ThisLastCharRemoved(c)
		return This.Copy().RemoveThisLastCharQ(c).Content()

	  #---------------------------------------------------------#
	 #   REMOVING FIRST & LAST CHARS UPAON A GIVEN CONDITION   #
	#---------------------------------------------------------#

	def RemoveFirstCharW(pcCondition)
		cCode = StzStringQ(pcCondition).RemoveSpacesQ().BoundsRemoved("{","}")
		cCode = 'bOk = ' + cCode
		eval(cCode)

		if bOk
			This.RemoveFirstChar()
		ok

		def RemoveFirstCharWQ(pcCondition)
			This.RemoveFirstCharW(pcCondition)
			return This

	def FirstCharRemovedW(pcCondition)
		return This.Copy().RemoveFirstCharWQ(pcCondition).Content()

	#--

	def RemoveLastCharW(pcCondition)
		@char = @@(This.LastChar())
		cCode = StzStringQ(pcCondition).RemoveSpacesQ().BoundsRemoved(["{","}"])
		cCode = 'bOk = (' + cCode + ')'

		eval(cCode)

		if bOk
			This.RemoveLastChar()
		ok

		def RemoveLastCharWQ(pcCondition)
			This.RemoveLastCharW(pcCondition)
			return This

	def LastCharRemovedW(pcCondition)
		return This.Copy().RemoveLastCharWQ(pcCondition).Content()

	  #---------------------------------#
	 #   REMOVING LEFT & RIGHT CHARS   #
	#---------------------------------#

	def RemoveLeftChar()
		This.RemoveNLeftChars(1)

		def RemoveLeftCharQ()
			This.RemoveLeftChar()
			return This

	def LeftCharRemoved()
		cResult = This.Copy().RemoveLeftCharQ().Content()
		return cResult

	def RemoveRightChar()
		This.RemoveNRightChars(1)

		def RemoveRightCharQ()
			This.RemoveRightChar()
			return This

	def RightCharRemoved()
		cResult = This.Copy().RemoveRightCharQ().Content()
		return cResult

	  #----------------------------#
	 #   REMOVING N FIRST CHARS   #
	#----------------------------#

	def RemoveNFirstChars(n)
		if This.IsRightToLeft()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok
		
		#< @FunctionFluentForm

		def RemoveNFirstCharsQ(n)
			This.RemoveNFirstChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveFirstNChars(n)
			This.RemoveNFirstChars(n)

			#< @FuncFluentForm
	
			def RemoveFirstNCharsQ(n)
				This.RemoveNFirstCharsQ(n)
	
			#>

		#>
	
	def NFirstCharsRemoved(n)
		cResult = This.Copy().RemoveNFirstCharsQ(n).Content()
		return cResult

		def FirstNCharsRemoved(n)
			return This.NFirstCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LAST CHARS   #
	#---------------------------#

	def RemoveNLastChars(n)

		if This.IsLeftToRight()
			This.RemoveNRightChars(n)
		else
			This.RemoveNLeftChars(n)
		ok	

		#< @FunctionFluentForm

		def RemoveNLastCharsQ(n)
			This.RemoveNLastChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLastNChars(n)
			This.RemoveNLastChars(n)

			#< @FuncFluentForm
	
			def RemoveLastNCharsQ(n)
				This.RemoveNLastCharsQ(n)
	
			#>

		#>
	
	def NLastCharsRemoved(n)
		cResult = This.Copy().RemoveNLastCharsQ(n).Content()
		return cResult

		def LastNCharsRemoved(n)
			return This.NLastCharsRemoved(n)

	  #---------------------------#
	 #   REMOVING N LEFT CHARS   #
	#---------------------------#

	def RemoveNLeftChars(n)
		if This.IsLeftToRight()
			This.RemoveSection( 1, n )

		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNLeftCharsQ(n)
			This.RemoveNLeftChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveLeftNChars(n)
			This.RemoveNLeftChars(n)

			#< @FuncFluentForm
	
			def RemoveLeftNCharsQ(n)
				This.RemoveNLeftCharsQ(n)
	
			#>
		#>
	
	def NLeftCharsRemoved(n)
		cResult = This.Copy().RemoveNLeftCharsQ(n).Content()
		return cResult

		def LeftNCharsRemoved(n)
			return This.NLeftCharsRemoved(n)


	  #----------------------------#
	 #   REMOVING N RIGHT CHARS   #
	#----------------------------#

	def RemoveNRightChars(n)
		if This.IsRightToLeft()
			This.RemoveSection( 1, n)
		else
			This.RemoveSection( This.NumberOfChars() - n + 1, :LastChar )
		ok

		#< @FunctionFluentForm

		def RemoveNRightCharsQ(n)
			This.RemoveNRightChars(n)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveRightNChars(n)
			This.RemoveNRightChars(n)

			#< @FuncFluentForm
	
			def RemoveRightNCharsQ(n)
				This.RemoveNRightCharsQ(n)
	
			#>
		#>
	
	def NRightCharsRemoved(n)
		cResult = This.Copy().RemoveNRightCharsQ(n).Content()
		return cResult

		def RightNCharsRemoved(n)
			return This.NRightCharsRemoved(n)

	  #---------------------------------------------#
	 #    REMOVING A GIVEN CHAR FROM THE STRING    # 
	#---------------------------------------------#

	def RemoveCharCS(pcChar, pCaseSensitive) # TODO (future): accept also stzChar objects
		if NOT StringIsChar(pcChar)
			stzRaise("Incorrect param type! You must provide a string containing char")
		ok

		This.RemoveCharsCSW('@char = ' + @@(pcChar), pCaseSensitive)

		def RemoveCharCSQ(pcChar, pCaseSensitive)
			This.RemoveCharCS(pcChar, pCaseSensitive)
			return This

	def CharRemovedCS(pcChar, pCaseSensitive)
		cResult = This.Copy().RemoveCharCSQ(pcChar, pCaseSensitive).Content()
		return cResult

	#---

	def RemoveChar(pcChar)
		if NOT StringIsChar(pcChar)
			stzRaise("Incorrect param type! You must provide a string containing char")
		ok

		This.RemoveCharsW('@char = ' + @@(pcChar))

		def RemoveCharQ(pcChar)
			This.RemoveChar(pcChar)
			return This

	def CharRemoved(pcChar)
		cResult = This.Copy().RemoveCharQ(pcChar).Content()
		return cResult

	  #----------------------------------#
	 #    REMOVING A SECTION OF CHARS   # 
	#----------------------------------#
	
	// Removes a portion of the string defined by its start and end positions
	def RemoveSection(n1, n2)
		#< @QtBased = TRUE #>

		if n1 = :FirstChar or n1 = :StartOfString or n1 = :Frist
			n1 = 1
		ok

		if n1 = :LastChar  or n1 = :EndOfString or n1 = :Last
			n1 = This.NumberOfChars()
		ok

		if n2 = :LastChar  or n2 = :EndOfString or n2 = :Last
			n2 = This.NumberOfChars()
		ok

		if n2 = :FirstChar or n2 = :StartOfString or n2 = :First
			n2 = 1
		ok

		cResult = This.QStringObject().replace(n1 - 1, n2 - n1 + 1, "")
		This.Update(cResult)

		def RemoveSectionQ(n1, n2)
			This.RemoveSection(n1, n2)
			return This

	def SectionRemoved(n1, n2)
		cResult = This.Copy().RemoveSectionQ(n1, n2).Content()
		return cResult
	
	  #-------------------------------------------------------#
	 #    REMOVING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#-------------------------------------------------------#

	def RemoveManySections(paSections)
 		/* EXAMPLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.RemoveManySections([
			[1,2], [8, 10], [16, 17], [23, 25]
		])
		
		? o1.Content() #--> "blablablablabla"

		*/

		if isList(paSections)
			oSections = new stzList(paSections)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paSections = oSections.Content()
			
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManySections(paSections)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paSections) is not a list of pairs of numbers."
			])

		ok

		nLen = len(paSections)
		if nLen = 0
			return
		ok

		aSorted = QR(paSections, :stzListOfPairs).Sorted()

		for i = nLen to 1 step -1
			This.RemoveSection(aSorted[i][1], aSorted[i][2])
		next

		def RemoveManySectionsQ(paListOfSections)
			This.RemoveManySections(paListOfSections)
			return This

		def RemoveSections(paListOfSections)
			This.RemoveManySections(paListOfSections)

			def RemoveSectionsQ(paListOfSections)
				This.RemoveSections(paListOfSections)
				return This

	def ManySectionsRemoved(paListOfSections)
		cResult = This.Copy().RemoveManySectionsQ(paListOfSections).Content()
		return This

		def SectionsRemoved(paListOfSections)
			return This.ManySectionsRemoved(paListOfSections)

	  #--------------------------------#
	 #    REMOVING A RANGE OF CHARS   # 
	#--------------------------------#

	// Removes a portion of the string defined by a start position and
	// a range of n chars

	def RemoveRange(nStart, nRange)

		if nStart = :FirstChar or nStart = :StartOfString { nStart = 1 }
		if nRange = :EndOfString { nRange = This.NumberOfChars() - nStart + 1 }

		This.RemoveSection(nStart, nStart + nRange - 1)

		def RemoveRangeQ(nStart, nRange)
			This.RemoveRange(nStart, nNumberOfChars)
			return This

	def RangeRemoved(nStart, nRange)
		cResult = This.RemoveRangeQ(nStart, nRange).Content()
		return cResult

	  #-----------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#-----------------------------------------------------#

	def RemoveManyRanges(paRanges) # Todo: use for loop instead of for/in

		if NOT ( isList(paRanges) and Q(paRanges).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > RemoveManyRanges(paRanges)",
				:What  = "Can't remove many sections from the string.",
				:Why   = "The value is you provided (paRanges) is not a list of pairs of numbers."
			])

		ok

		if isList(paRanges)
			oSections = new stzList(paRanges)
			anPos = oSections.FindAll([])
			oSections.RemoveItemsAtPositions(anPos)
			paRanges = oSections.Content()
			
		ok

		# Tranform ranges to sections and then use RemoveManySections()

		nLen = len(paRanges)
		aSections = []

		for i = 1 to nLen
			n1 = paRanges[i][1]
			n2 = paRanges[i][1] + paRanges[i][2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.RemoveManySections(aSections)

		def RemoveManyRangesQ(paRanges)
			This.RemoveManySections(paRanges)

		def RemoveRanges(paRanges)
			This.RemoveManyRanges(paRanges)

			def RemoveRangesQ(paRanges)
				This.RemoveRanges(paRanges)
				return This

	def ManyRangesRemoved(paRanges)
		cResult = This.Copy().RemoveManyRangesQ(paRanges).Content()
		return This

		def RangedRemoved(paRanges)
			return This.ManyRangesRemoved(paRanges)

	  #-------------------------------------------------------------#
	 #    REMOVING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#-------------------------------------------------------------#

	def RemoveSectionsW(paSections, pcCondition)

		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.RemoveSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:Wehre = '{ Q(This(@section)).IsLowercase() }'
		)

		#--> "..AA....BB.."
		*/

		if isString(pcCondition)
			cCondition = pcCondition

		but isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			cCondition = pcCondition[2]

		else
			// TODO: add this check everywhere in the library!
			stzRaise("Incorrect condition format!")
		ok

		cCondition = StzStringQ(cCondition).
				SimplifyQ().
				RemoveTheseBoundsQ(["{","}"]).
				Content()

		cCode = "bOk = ( " + cCondition + " )"

		aSubStrings = This.Sections(paSections)

		aSectionsToRemove = []
		for i = 1 to len( paSections )
			@n1 = paSections[i][1]
			@n2 = paSections[i][2]

			@section = aSubStrings[i]

			eval(cCode)

			if bOk
				aSectionsToRemove + [ @n1, @n2 ]
			ok
		next

		This.RemoveManySections(aSectionsToRemove)

		#< @FunctionFluentForm

		def RemoveSectionsWQ(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
			return This

		def RemoveSectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveSectionsWhereQ(paSections, pcCondition)
				This.RemoveSectionsWhere(paSections, pcCondition)
				return This

		def RemoveManySectionsW(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)
	
			def RemoveManySectionsWQ(paSections, pcCondition)
				This.RemoveManySectionsW(paSections, pcCondition)
				return This

		def RemoveManySectionsWhere(paSections, pcCondition)
			This.RemoveSectionsW(paSections, pcCondition)

			def RemoveManySectionsWhereQ(paSections, pcCondition)
				This.RemoveManySectionsWhere(paSections, pcCondition)
				return This

	def ManySectionsRemovedW(paSections, pcCondition)
		cResult = This.Copy().RemoveManySectionsQ(paSections, pcCondition).Content()
		return cResult

		def ManySectionsRemovedWhere(paSections, pcCondition)
			return This.ManySectionsRemovedW(paSections, pcCondition)

	  #----------------------------------------------------------------#
	 #    REMOVING MANY RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#----------------------------------------------------------------#

	def RemoveManyRangesW(paListOfRanges, pcCondition)

		# Tranform ranges to sections and then use RemoveManySectionsW()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
	

	
		if isString(pcCondition)
			cCondition = pcCondition

		but isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			cCondition = pcCondition[2]
		ok

		if NOT isString(cCondition)
			stzRaise("Incorrect param! pcCondition must be a string.")
		ok

		cCondition = StzStringQ(cCondition).
				ReplaceCSQ("@range", "@section", :CS = FALSE).
				Content()

		This.RemoveManySectionsW(aSections, cCondition)

		def RemoveManyRangesWQ(paListOfRanges, pcCondition)
			This.RemoveManyRangesW(paListOfRanges, pcCondition)

		def RemoveRangesW(paListOfRanges, pcCondition)
			This.RemoveManyRangesW(paListOfRanges, pcCondition)

			def RemoveRangesWQ(paListOfRanges, pcCondition)
				This.RemoveRangesW(paListOfRanges, pcCondition)
				return This

	def ManyRangesRemovedW(paListOfRanges, pcCondition)
		cResult = This.Copy().RemoveManyRangesWQ(paListOfRanges, pcCondition).Content()
		return cResult

		def RangedRemovedW(paListOfRanges, pcCondition)
			return This.ManyRangesRemovedW(paListOfRanges, pcCondition)

	  #------------------------------------------------------------#
	 #    REMOVING CHARS/SUBSTRINGS VERIFYING A GIVEN CONDITION   # 
	#------------------------------------------------------------#

	def RemoveW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam(pcCondition)
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCondition = new stzString(pcCondition)

		if oCondition.ContainsBothCS("@char", :And = "@substring", :CS = FALSE)

			StzRaise("Incorrect syntax! pcCondition must contains @char or @substring keywords but not both.")
		ok

		if oCondition.ContainsCS("@substring", :CS = FALSE)
			return This.RemoveSubstringsW(pcCondition)

		else
			return This.RemoveCharsW(pcCondition)
		ok

	  #-------------------------------------------------#
	 #    REMOVING CHARS VERIFYING A GIVEN CONDITION   # 
	#-------------------------------------------------#

	def RemoveCharsWhere(pcCondition)

		if isList(pcCondition) and stzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]

			if NOT isString(pcCondition)
				stzRaise("Incorrect param type! pcCondition mus tbe a string.")
			ok
		ok

		anPositions = This.FindCharsWhereQ( pcCondition ).SortedInDescending()

		for for n in anPositions
			This.RemoveCharAtPosition(n)
		next

		#< @FunctionFluentForm

		def RemoveCharsWhereQ(pcCondition)
			This.RemoveCharsWhere(pcCondition)
			return This

		#>

		def RemoveCharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveCharsWQ(pcCondition)
				This.RemoveCharsW(pcCondition)
				return This

		def RemoveAllcharsWhere(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWhereQ(pcCondition)
				This.RemoveAllcharsWhere(pcCondition)
				return This

		def RemoveAllcharsW(pcCondition)
			This.RemoveCharsWhere(pcCondition)

			def RemoveAllcharsWQ(pcCondition)
				This.RemoveAllCharsWhere(pcCondition)
				return This

	  #-----------------------------------#
	 #    REPLACING A SECTION OF CHARS   # 
	#-----------------------------------#
	
	// Replaces a portion of the string defined by its start and end positions

	def ReplaceSection(n1, n2, pcNewSubStr)
		#< @MotherFunction = YES | @QtBased #>

		# Checking the correctness of n1 and n2 params

		if isList(n1) and Q(n1).IsFromNamedParam()
			n1 = n1[2]
		ok

		if isList(n2) and Q(n2).IsToNamedParam()
			n2 = n2[2]
		ok

		if isString(n1)
			if n1 = :First or n1 = :FirstChar or n1 = :StartOfString
				n1 = 1
			ok
		ok

		if isString(n2)
			if n2 = :Last or n2 = :LastChar  or n2 = :EndOfString
				n2 = This.NumberOfChars()
			ok
		ok

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect param types! n1 and n2 must be numbers.")
		ok

		# Checking the pcNewSubStr param

		if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithOrByNamedParam()

			if Q(pcNewSubStr[1]).LastChar() = "@"

				acTemp = eval@( pcNewSubStr[2], :On = This.SectionQ(n1, n2).Chars() )
				pcNewSubStr = QR(acTemp, :stzListOfStrings).Concatenated()

			else
				pcNewSubStr = pcNewSubStr[2]
			ok
		ok

		nQtStart = n1 - 1
		nQtRange = n2 - n1 + 1

		cResult = QStringObject().replace(nQtStart, nQtRange, pcNewSubStr)
		This.Update(cResult)

		#< @FunctionFluentForm

		def ReplaceSectionQ(n1, n2, pcNewSubStr)
			This.ReplaceSection(n1, n2, pcNewSubStr)
			return This

		#>

	def SectionReplaced(n1, n2, pcNewSubStr)
		cResult = This.Copy().ReplaceSectionQ(n1, n2, pcNewSubStr).Content()
		return cResult
	
	  #--------------------------------------------------------#
	 #    REPLACING MANY SECTIONS OF CHARS AT THE SAME TIME   # 
	#--------------------------------------------------------#

	def ReplaceManySections(paListOfSections, pcNewSubStr)

		/* EXAMLE
		
		o1 = new stzString("**word1***word2**word3***")
		? o1.Sections([ [1,2], [8, 10], [16, 17], [23, 25] ])
		#--> [ "**", "***", "**", "***" ]
		
		o1.ReplaceManySections([ [1,2], [8, 10], [16, 17], [23, 25] ], "_" )
		
		? o1.Content() #--> "_word1_word2_word3_"
		*/

		if NOT( isList(paListOfSections) and Q(paListOfSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		aListOfSections = StzListOfPairsQ( paListOfSections ).SortedInAscending()

		n = 0
		nNumberOfSections = len(aListOfSections)
		
		for i = len(aListOfSections) to 1 step -1

			aSection = aListOfSections[i]

			n1 = aSection[1]
			n2 = aSection[2]

			This.ReplaceSection(n1, n2, pcNewSubStr)

		next

		def ReplaceManySectionsQ(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)
			return This


		def ReplaceSections(paListOfSections, pcNewSubStr)
			This.ReplaceManySections(paListOfSections, pcNewSubStr)

			def ReplaceSectionsQ(paListOfSections, pcNewSubStr)
				This.ReplaceSections(paListOfSections, pcNewSubStr)
				return This

	def ManySectionsReplaced(paListOfSections, pcNewSubStr)
		cResult = This.Copy().ReplaceManySectionsQ(paListOfSections, pcNewSubStr).Content()
		return This

		def SectionsReplaced(paListOfSections, pcNewSubStr)
			return This.ManySectionsReplaced(paListOfSections, pcNewSubStr)

	  #---------------------------------#
	 #    REPLACING A RANGE OF CHARS   # 
	#---------------------------------#

	// Replaces a portion of the string defined by a start position and
	// a range of n chars
	def ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)

		if nStart = :FirstChar or nStart = :StartOfString { nStart = 1 }
		if nNumberOfChars = :EndOfString { nNumberOfChars = This.NumberOfChars() - nStart + 1 }

		This.ReplaceSection(nStart, nStart + nNumberOfChars - 1, pcNewSubStr)

		def ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr)
			This.ReplaceRange(nStart, nNumberOfChars, pcNewSubStr)
			return This

	def RangeReplaced(nStart, nNumberOfChars, pcNewSubStr)
		cResult = This.ReplaceRangeQ(nStart, nNumberOfChars, pcNewSubStr).Content()
		return cResult

	  #------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS AT THE SAME TIME   # 
	#------------------------------------------------------#

	def ReplaceManyRanges(paListOfRanges, pcNewSubStr)

		# Tranform ranges to sections and then use ReplaceManySections()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySections(aSections, pcNewSubStr)

		def ReplaceManyRangesQ(paListOfRanges, pcNewSubStr)
			This.ReplaceManySections(paListOfRanges, pcNewSubStr)

		def ReplaceRanges(paListOfRanges, pcNewSubStr)
			This.ReplaceManyRanges(paListOfRanges, pcNewSubStr)

			def ReplaceRangesQ(paListOfRanges, pcNewSubStr)
				This.ReplaceRanges(paListOfRanges, pcNewSubStr)
				return This

	def ManyRangesReplaced(paListOfRanges, pcNewSubStr)
		cResult = This.Copy().ReplaceManyRangesQ(paListOfRanges, pcNewSubStr).Content()
		return This

		def RangedReplaced(paListOfRanges, pcNewSubStr)
			return This.ManyRangesReplaced(paListOfRanges, pcNewSubStr)

	  #--------------------------------------------------------------#
	 #    REPLACING SECTIONS OF CHARS VERIFYING A GIVEN CONDITION   # 
	#--------------------------------------------------------------#

	def ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
		/* EXAMPLE

		o1 = new stzString("..AA..aa..BB..bb")
		o1.ReplaceSectionsW(
			[3, 4], [7,8], [11,12], [15,16],
			:With = "_",
			:Wehre = '{ Q(This(@section)).IsLowercase() }'
		)

		#--> "..AA.._..BB.._"
		*/

		if NOT( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise([
				:Where = "stzString > ReplaceManySections()",
				:What  = "Can't Replace many sections from the string.",
				:Why   = "The value you provided is not a list of sections.",
				:Todo  = "Provide a list of sections as pairs of numbers!"
			])
		ok

		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]

		else
			// TODO: add this check everywhere in the library!
			stzRaise("Incorrect condition format!")
		ok

		pcCondition = StzStringQ(pcCondition).
				SimplifyQ().
				ReplaceBoundsQ(["{","}"]).
				Content()

		cCode = "bOk = ( " + pcCondition + " )"

		aSubStrings = This.Sections(paSections)

		aSectionsToReplace = []
		for i = 1 to len( paSections )
			@n1 = paSections[i][1]
			@n2 = paSections[i][2]

			@range = aSubStrings[i]

			eval(cCode)

			if bOk
				aSectionsToReplace + [ @n1, @n2 ]
			ok
		next

		This.ReplaceManySections(aSectionsToReplace, pcNewSubStr)

		#< @FunctionFluentForm

		def ReplaceSectionsWQ(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
			return This

		def ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceSectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceSectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)
	
			def ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsW(paSections, pcNewSubStr, pcCondition)
				return This

		def ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
			This.ReplaceSectionsW(paSections, pcNewSubStr, pcCondition)

			def ReplaceManySectionsWhereQ(paSections, pcNewSubStr, pcCondition)
				This.ReplaceManySectionsWhere(paSections, pcNewSubStr, pcCondition)
				return This

	def ManySectionsReplacedW(paSections, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManySectionsWQ(paSections, pcNewSubStr, pcCondition).Content()
		return cResult

		def ManySectionsReplacedWhere(paSections, pcCondition)
			return This.ManySectionsReplacedW(paSections, pcCondition)

	  #-----------------------------------------------------------------#
	 #    REPLACING MANY RANGES OF CHARS VERIFYING A GIVEN CONDITION   # 
	#-----------------------------------------------------------------#

	def ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

		# Tranform ranges to sections and then use ReplaceManySectionsW()

		aSections = []
		for aRange in paListOfRanges
			n1 = aRange[1]
			n2 = aRange[1] + aRange[2] - 1

			aSections + [ n1, n2 ]
		next
		
		This.ReplaceManySectionsW(aSections, pcNewSubStr, pcCondition)

		def ReplaceManyRangesWQ(paListOfRanges, pcNewSubStr, pcCondition)
			This.ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

		def ReplaceRangesW(paListOfRanges, pcNewSubStr, pcCondition)
			This.ReplaceManyRangesW(paListOfRanges, pcNewSubStr, pcCondition)

			def ReplaceRangesWQ(paListOfRanges, pcNewSubStr, pcCondition)
				This.ReplaceRangesW(paListOfRanges, pcNewSubStr, pcCondition)
				return This

	def ManyRangesReplacedW(paListOfRanges, pcNewSubStr, pcCondition)
		cResult = This.Copy().ReplaceManyRangesWQ(paListOfRanges, pcNewSubStr, pcCondition).Content()
		return cResult

		def RangedReplacedW(paListOfRanges, pcNewSubStr, pcCondition)
			return This.ManyRangesReplacedW(paListOfRanges, pcNewSubStr, pcCondition)

	  #==========================================#
	 #    SWAPPING TWO SECTIONS OF THE STRING   # 
	#==========================================#

	def SwapSections( panSection1, panSection2 )

		if CheckParam() = TRUE
			if isList(panSection2) and Q(panSection2).IsWithOrAndNamedParams()
				panSection2 = panSection2[2]
			ok
	
			if NOT BothArePairsOfNumbers(panSection1, panSection2)
				StzRaise("Incorrect param type! panSection1 and panSection2 must be both pairs of number.")
			ok
		ok

		cSection1 = This.Section(panSection1[1], panSection1[2])
		cSection2 = This.Section(panSection2[1], panSection2[2])

		This.ReplaceSection(panSection1[1], panSection1[2], cSection2)
		This.ReplaceSection(panSection2[1], panSection2[2], cSection1)


		def SwapSectionsQ(panSection1, panSection2)
			This.SwapSections(panSection1, panSection2)
			return This

	def SectionsSwapped(panSection1, panSection2)
		cResult = This.Copy().SwapSectionsQ(panSection1, panSection2)
		return cResult

	  #-----------------------------------#
	 #  SWAPPING MANY PAIRS OF SECTIONS  #
	#-----------------------------------#

	def SwapManyPairsOfSections(paPairsOfSections)
		if CheckParam() = TRUE
			if NOT ( isList(paPairsOfSections) and Q(paPairsOfSections).IsListOfPairsOfSections() )
				StzRaise("Incorrect param type! paPairsOfSections must be a list of pairs of sections, each section being a pair of numbers.")
			ok
		ok

		nLen = len(paPairsOfSections)

		for i = 1 to nLen
			This.SwapSections(paPairsOfSections[i][1], paPairsOfSections[i][2])
		next

		def SwapManyPairsOfSectionsQ(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)
			return This

		def SwapPairsOfSections(paPairsOfSections)
			This.SwapManyPairsOfSections(paPairsOfSections)

			def SwapPairsOfSectionsQ(paPairsOfSections)
				This.SwapPairsOfSections(paPairsOfSections)
				return This

	def ManyPairsOfSectionsSwapped(paPairsOfSections)
		cResult = This.Copy().SwapManyPairsOfSectionsQ(paPairsOfSections).Content()
		return cResult

	  #========================================#
	 #    REMOVING NUMBERS FROM THE STRING    # 
	#========================================#

	def RemoveNumbers()
		cResult = ""
	
		aStzChars = This.ToListOfStzChars()

		# TODO: Replace for/in with for --> better performance
		for oChar in aStzChars
			if NOT oChar.IsANumber()
				cResult += oChar.Content()
			ok
		next
	
		This.Update( cResult )

	
		def RemoveNumbersQ()
			This.RemoveNumbers()
			return This

	def NumbersRemoved()
		cResult = This.Copy().RemoveNumbersQ().Content()
		return cResult

	  #====================================================#
	 #     REMOVING THE NTH OCCURRENCE OF A SUBSTRING     #
	#====================================================#

	def RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if isList(n)
			This.RemoveOccurrencesCS(n, pcSubStr, pCaseSensitive)
			return
		ok

		This.ReplaceNthOccurrenceCS(n, pcSubStr, "", pCaseSensitive)

		#< @FunctionFluentForm
	
		def RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @FunctionAlternativeForm

		def RemoveNthCS(n, pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

			def RemoveNthCSQ(n, pcSubStr, pCaseSensitive)
				This.RemoveNthCS(n, pcSubStr, pCaseSensitive)
				return This

		#>

	def NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def NthRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		def SubStringNthOccurrenceRemovedCS(n, pcSubStr, pCaseSensitive)
			return This.NthOccurrenceOfSubStringRemovedCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def RemoveNthOccurrence(n, pcSubStr)
		This.RemoveNthOccurrenceCS(n, pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveNthOccurrenceQ(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def RemoveNth(n, pcSubStr)
			This.RemoveNthOccurrence(n, pcSubStr)

			def RemoveNthQ(n, pcSubStr)
				This.RemoveNth(n, pcSubStr)
				return This

		#>

	def NthOccurrenceOfSubStringRemoved(n, pcSubStr)
		cResult = This.Copy().RemoveNthOccurrenceQ(n, pcSubStr).Content()
		return cResult

		#< @FunctionAlternativeForms

		def NthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def NthRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		def SubStringNthOccurrenceRemoved(n, pcSubStr)
			return This.NthOccurrenceOfSubStringRemoved(n, pcSubStr)

		#>

	  #------------------------------------------------#
	 #    REMOVING FIRST OCCURRENCE OF A SUBSTRING    #
	#------------------------------------------------#

	def RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(1, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveFirstCS(pcSubStr, pCaseSensitive)
			This.RemoveFirstOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveFirstCSQ(pcSubStr, pCaseSensitive)
				This.RemoveFirstCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveFirstOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def FirstRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringFirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFirstOccurrence(pcSubStr)
		This.RemoveFirstOccurrenceCS(pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFirstOccurrenceQ(pcSubStr, pcNewSubStr)
			This.RemoveFirstOccurrence(pcSubStr)
			return This
	
		#>

		#< @functionAlternativeForm

		def RemoveFirst(pcSubStr)
			This.RemoveFirstOccurrence(pcSubStr)

			def RemoveFirstQ(pcSubStr)
				This.RemoveFirst(pcSubStr)
				return This

		#>

	def FirstOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveFirstOccurrenceQ(pcSubStr).Content()

		def FirstRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringFirstOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	  #--------------------------------------------------#
	 #     REMOVING LAST OCCURRENCE OF A SUBSTRING      #
	#--------------------------------------------------#

	def RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
		This.ReplaceNthOccurrenceCS(:Last, pcSubStr, "", pCaseSensitive)
	
		#< @FunctionFluentForm
	
		def RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This
		
		#>

		#< @functionAlternativeForm

		def RemoveLastCS(pcSubStr, pCaseSensitive)
			This.RemoveLastOccurrenceCS(pcSubStr, pCaseSensitive)

			def RemoveLastCSQ(pcSubStr, pCaseSensitive)
				This.RemoveLastCS(pcSubStr, pCaseSensitive)
				return This

		#>

	def LastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		return This.Copy().RemoveLastOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()

		def LastRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

		def SubStringLastOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
			return This.FirstOccurrenceRemovedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveLastOccurrence(pcSubStr)
		This.RemoveLastOccurrenceCS(pcSubStr, :Casesensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveLastOccurrenceQ(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)
			return This
	
		#>

		#< @FunctionLastOccurrence

		def RemoveLast(pcSubStr)
			This.RemoveLastOccurrence(pcSubStr)

			def RemoveLastQ(pcSubStr)
				This.RemoveLast(pcSubStr)
				return This

		#>

	def LastOccurrenceRemoved(pcSubStr)
		return This.Copy().RemoveLastOccurrenceQ(pcSubStr).Content()

		def LastRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

		def SubStringLastOccurrenceRemoved(pcSubStr)
			return This.FirstOccurrenceRemoved(pcSubStr)

	   #----------------------------------------------------#
	  #    REMOVING NEXT NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if isList(nStart) and StzListQ(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isList(pcSubStr) and StzListQ(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and StzListQ(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		cPart1 = This.Section(1, nStart - 1)

		oPart2 = This.SectionQ(nStart, :LastChar)
		cPart2 = oPart2.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		def RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthNextOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				This.RemoveNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
				return This

		#>

	def NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthNextOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.NextNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

	#-- WIHTOUT CASESENSITIVITY

	def RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		def RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthNextOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				return This.RemoveNthNextOccurrence(n, pcSubStr, nStart, pcNewSubStr)

		#>

	def NextNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemoveNextNthOccurrenceQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthNextOccurrenceRemoved(n, pcSubStr, nStart)
			return This.NextNthOccurrenceRemoved(n, pcSubStr, nStart, pCaseSensitive)

	   #------------------------------------------------#
	  #    REMOVING NEXT OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                #
	#------------------------------------------------#

	def RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		def RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemoveNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

	def NextOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemoveNextOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemoveNextNthOccurrenceCS(1, pcSubStr, nStart, :CaseSensitive = TRUE)

		def RemoveNextOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemoveNextOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def NextOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemoveNextOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

	   #-------------------------------------------------------#
	  #    REMOVING PREVIOUS NTH OCCURRENCE OF A SUBSTRING    # 
	 #    STARTING AT A GIVEN POSITION                       #
	#-------------------------------------------------------#

	def RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		
		if isList(nStart) and Q(nStart).IsStartingAtNamedParam()
			nStart = nStart[2]
		ok

		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		if isList(pcNewSubStr) and Q(pcNewSubStr).IsWithNamedParam()
			pcNewSubStr = pcNewSubStr[2]
		ok

		oPart1 = This.SectionQ(1, nStart - 1)
		n = oPart1.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive) - n + 1
		cPart1 = oPart1.RemoveNthOccurrenceCSQ(n, pcSubStr, pCaseSensitive).Content()

		cPart2 = This.Section(nStart, :LastChar)

		cResult = cPart1 + cPart2
		This.Update( cResult )

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)

			def RemoveNthPreviousOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive)
				This.RemoveNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
				return This

		#>

	def PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousNthOccurrenceCSQ(n, pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

		def NthPreviousOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)
			return This.PreviousNthOccurrenceRemovedCS(n, pcSubStr, nStart, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(n, pcSubStr, nStart, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			return This

		#>

		#< @FunctionAlternativeForm

		def RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousNthOccurrence(n, pcSubStr, nStart, pcNewSubStr)

			def RemoveNthPreviousOccurrenceQ(n, pcSubStr, nStart, pcNewSubStr)
				This.RemoveNthPreviousOccurrence(n, pcSubStr, nStart, pcNewSubStr)
				return This

		#>

	def PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousNthOccurrenceQ(n, pcSubStr, nStart).Content()
		return cResult

		def NthPreviousOccurrenceRemoved(n, pcSubStr, nStart)
			return This.PreviousNthOccurrenceRemoved(n, pcSubStr, nStart)

	   #----------------------------------------------------#
	  #    REMOVING PREVIOUS OCCURRENCE OF A SUBSTRING     # 
	 #    STARTING AT A GIVEN POSITION                    #
	#----------------------------------------------------#

	def RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, pCaseSensitive)

		def RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive)
			This.RemovePreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
			return This

	def PreviousOccurrenceRemovedCS(pcSubStr, nStart, pCaseSensitive)
		cResult = This.Copy().RemovePreviousOccurrenceCSQ(pcSubStr, nStart, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
		This.RemovePreviousNthOccurrenceCS(1, pcSubStr, nStart, :CaseSensitive = TRUE)

		def RemovePreviousOccurrenceQ(pcSubStr, nStart, pcNewSubStr)
			This.RemovePreviousOccurrence(pcSubStr, nStart, pcNewSubStr)
			return This

	def PreviousOccurrenceRemoved(pcSubStr, nStart)
		cResult = This.Copy().RemovePreviousOccurrenceQ(pcSubStr, nStart).Content()
		return cResult

	  #-----------------------------------------------#
	 #    REMOVING LEFT OCCURRENCE OF A SUBSTRING    # 
	#-----------------------------------------------#

	def RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsRightToLeft()
			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveLeftOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def LeftOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveLeftOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveLeftOccurrence(pcSubStr)
		This.RemoveLeftOccurrenceCS(pcSubStr, :CaseSensitive = FALSE)

		def RemoveLeftOccurrenceQ(pcSubStr)
			This.RemoveLeftOccurrence(pcSubStr)
			return This

	def LeftOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveLeftOccurrenceQ(pcSubStr).Content()
		return cResult

	  #---------------------------------------------#
	 #    REMOVING RIGHT OCCURRENCE OF SUBSTRING   # 
	#---------------------------------------------#

	def RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
		if This.IsRightToLeft()
			This.RemoveNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		else # This.IsLeftToRight()

			n = This.NumberOfOccurrenceCS(pcSubStr, pCaseSensitive)
			This.RemoveNthOccurrenceCS( n, pcSubStr, pCaseSensitive)
		ok

		def RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive)
			This.RemoveRightOccurrenceCS(pcSubStr, pCaseSensitive)
			return This

	def RightOccurrenceRemovedCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveRightOccurrenceCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

	#-- WIHTOUT CASESENSITIVITY

	def RemoveRightOccurrence(pcSubStr)
		This.RemoveRightOccurrenceCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveRightOccurrenceQ(pcSubStr)
			This.RemoveRightOccurrence(pcSubStr)
			return This

	def RightOccurrenceRemoved(pcSubStr)
		cResult = This.Copy().RemoveRightOccurrenceQ(pcSubStr).Content()
		return cResult

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM LEFT    #
	#-------------------------------------#

	def RemoveFromLeftCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NLeftCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsLeftToRight()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr
			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromLeftCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
			return This

		def RemovSubStringFromLeftCS(pcSubStr, pCaseSensitive)
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromLeftCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromLeftCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromLeftCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromLeftCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromLeftCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromLeftCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromLeft(pcSubStr)
		This.RemoveFromLeftCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveFromLeftQ(pcSubStr)
			This.RemoveFromLeft(pcSubStr)
			return This

		def RemovSubStringFromLeft(pcSubStr)
			This.RemoveFromLeft(pcSubStr)

			def RemovSubStringFromLeftQ(pcSubStr)
				This.RemovSubStringFromLeft(pcSubStr)
				return This

	def RemovedFromLeft(pcSubStr)
		cResult = This.Copy().RemoveFromLeftQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromLeft(pcSubStr)
			return This.RemovedFromLeft(pcSubStr)

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM RIGHT   #
	#-------------------------------------#

	def RemoveFromRightCS(pcSubStr, pCaseSensitive)

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		nLenSubStr = StzStringQ(pcSubStr).NumberOfChars()

		if This.NRightCharsAsStringQ(nLenSubStr).IsEqualToCS(pcSubStr, pCaseSensitive)

			if This.IsRightToLeft()
				n1 = 1
				n2 = nLenSubStr

			else
				nLenStr = This.NumberOfChars()
				n1 = nLenStr - nLenSubStr + 1
				n2 = nLenStr

			ok

			This.RemoveSection(n1, n2)
		ok

		def RemoveFromRightCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
			return This

		def RemoveRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemoveRightCSQ(pcSubStr, pCaseSensitive)
				This.RemoveRightCS(pcSubStr, pCaseSensitive)
				return This

		def RemovSubStringFromRightCS(pcSubStr, pCaseSensitive)
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromRightCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromRightCS(pcSubStr, pCaseSensitive)
				return This

	def RemovedFromRightCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromRightCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromRightCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromRightCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromRight(pcSubStr)
		This.RemoveFromRightCS(pcSubStr, :CaseSensitive = TRUE)

		def RemoveFromRightQ(pcSubStr)
			This.RemoveFromRight(pcSubStr)
			return This

		def RemoveRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemoveRightQ(pcSubStr)
				This.RemoveRight(pcSubStr)
				return This

		def RemovSubStringFromRight(pcSubStr)
			This.RemoveFromRight(pcSubStr)

			def RemovSubStringFromRightQ(pcSubStr)
				This.RemovSubStringFromRight(pcSubStr)
				return This

	def RemovedFromRight(pcSubStr)
		cResult = This.Copy().RemoveFromRightQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromRight(pcSubStr)
			return This.RemovedFromRight(pcSubStr)	

	  #-------------------------------------#
	 #   REMOVING A SUBSTRING FROM START   #
	#-------------------------------------#

	def RemoveFromStartCS(pcSubStr, pCaseSensitive)

		if This.IsLeftToRight()
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromStartCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromStartCS(pcSubStr, pCaseSensitive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromStartCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromStartCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveStartCS(pcSubStr, pCaseSensittive)
			This.RemoveFromStartCS(pcSubStr, pCaseSensitive)

			def RemoveStartCSQ(pcSubStr, pCaseSensittive)
				This.RemoveStartCS(pcSubStr, pCaseSensittive)
				return This

		#>

	def RemovedFromStartCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromStartCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromStartCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

		def StartRemovedCS(pcSubStr, pCaseSensittive)
			return This.RemovedFromStartCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromStart(pcSubStr)
		This.RemoveFromStartCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFromStartQ(pcSubStr)
			This.RemoveFromStart(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemovSubStringFromStartQ(pcSubStr)
				This.RemovSubStringFromStart(pcSubStr)
				return This

		def RemoveStart(pcSubStr)
			This.RemoveFromStart(pcSubStr)

			def RemoveStartQ(pcSubStr)
				This.RemoveStart(pcSubStr)
				return This

		#>

	def RemovedFromStart(pcSubStr)
		cResult = This.Copy().RemoveFromStartQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromStart(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

		def StartRemoved(pcSubStr)
			return This.RemovedFromStart(pcSubStr)

	  #-----------------------------------#
	 #   REMOVING A SUBSTRING FROM END   #
	#-----------------------------------#

	def RemoveFromEndCS(pcSubStr, pCaseSensitive)
		if This.IsLeftToRight()
			This.RemoveFromRightCS(pcSubStr, pCaseSensitive)
		else
			This.RemoveFromLeftCS(pcSubStr, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def RemoveFromEndCSQ(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemovSubStringFromEndCSQ(pcSubStr, pCaseSensitive)
				This.RemovSubStringFromEndCS(pcSubStr, pCaseSensitive)
				return This

		def RemoveEndCS(pcSubStr, pCaseSensitive)
			This.RemoveFromEndCS(pcSubStr, pCaseSensitive)

			def RemoveEndCSQ(pcSubStr, pCaseSensitive)
				This.RemoveEndCS(pcSubStr, pCaseSensitive)
				return This
		#>

	def RemovedFromEndCS(pcSubStr, pCaseSensitive)
		cResult = This.Copy().RemoveFromEndCSQ(pcSubStr, pCaseSensitive).Content()
		return cResult

		def SubStringRemovedFromEndCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

		def EndRemovedCS(pcSubStr, pCaseSensitive)
			return This.RemovedFromEndCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def RemoveFromEnd(pcSubStr)
		This.RemoveFromEndCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def RemoveFromEndQ(pcSubStr)
			This.RemoveFromEnd(pcSubStr)
			return This

		#>

		#< @FunctionAlternativeForms

		def RemovSubStringFromEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemovSubStringFromEndQ(pcSubStr)
				This.RemovSubStringFromEnd(pcSubStr)
				return This

		def RemoveEnd(pcSubStr)
			This.RemoveFromEnd(pcSubStr)

			def RemoveEndQ(pcSubStr)
				This.RemoveEnd(pcSubStr)
				return This

		#>

	def RemovedFromEnd(pcSubStr)
		cResult = This.Copy().RemoveFromEndQ(pcSubStr).Content()
		return cResult

		def SubStringRemovedFromEnd(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

		def EndRemoved(pcSubStr)
			return This.RemovedFromEnd(pcSubStr)

	  #--------------------------------------------------------#
	 #    REMOVING CHARS FROM LEFT UNDER A GIVEN CONDITION    # 
	#--------------------------------------------------------#

	def RemoveCharsFromLeftW(pcCondition)
		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param type! Condition should be in a string.")
		ok

		pcCondition = StzCCodeQ(pcCondition).UnifiedFor(:stzString)

		cCode = "bOk = ( " + pcCondition + " )"
		oCode = new stzString(cCode)

		cSubStrToRemove = ""

		nLen = This.NumberOfChars()

		for @i = 1 to nLen
			@char = This.Char(@i)
			bEval = TRUE

			if @i = nLen and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i+1]", :CS = FALSE )

				bEval = FALSE
			ok

			if @i = 1 and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i-1]", :CS = FALSE )

				bEval = FALSE
			ok
			
			if bEval
				eval(cCode)
				if bOk
					cSubStrToRemove += @charName
				ok
			ok
		next

		This.RemoveSubStringFromLeft(cSubStrToRemove)

		def RemoveCharsFromLeftWWQ(pcCondition)
			This.RemoveCharsFromLeftW(pcCondition)
			return This

		def RemoveFromLeftW(pcCondition)
			This.RemoveCharsFromLeftW(pcCondition)

			def RemoveFromLeftWQ(pcCondition)
				This.RemoveFromLeftW(pcCondition)
				return This

		def RemoveLeftW(pcCondition)
			This.RemoveFromLeftW(pcCondition)

			def RemoveLeftWQ(pcCondition)
				This.RemoveLeftW(pcCondition)
				return This

	def CharsRemovedFromLeft(pcCondition)
		cResult = This.Copy().RemoveCharsFromLeftWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM RIGHT UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromRightW(pcCondition)
		if isList(pcCondition) and StzListQ(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			stzRaise("Incorrect param type! Condition should be in a string.")
		ok

		pcCondition = StzCCodeQ(pcCondition).UnifiedFor(:stzString)

		cCode = "bOk = ( " + pcCondition + " )"
		oCode = new stzString(cCode)

		cSubStrToRemove = ""

		for @i = 1 to This.NumberOfChars()
			@char = This.Char(@i)
			bEval = TRUE

			if @i = This.NumberOfChars() and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i+1]", :CS = FALSE )

				bEval = FALSE
			ok

			if @i = 1 and
			   oCode.Copy().RemoveSpacesQ().ContainsCS( "This[@i-1]", :CS = FALSE )

				bEval = FALSE
			ok
			
			if bEval
				eval(cCode)
				if bOk
					cSubStrToRemove += @charName
				ok
			ok
		next

		This.RemoveSubStringFromRight(cSubStrToRemove)

		def RemoveCharsFromRightWWQ(pcCondition)
			This.RemoveCharsFromRightW(pcCondition)
			return This

		def RemoveFromRightW(pcCondition)
			This.RemoveCharsFromRightW(pcCondition)

			def RemoveFromRightWQ(pcCondition)
				This.RemoveFromRightW(pcCondition)
				return This

		def RemoveRightW(pcCondition)
			This.RemoveFromRightW(pcCondition)

			def RemoveRightWQ(pcCondition)
				This.RemoveRightW(pcCondition)
				return This

	def CharsRemovedFromRight(pcCondition)
		cResult = This.Copy().RemoveCharsFromRightWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM START UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromStartW(pcCondition)
		if This.IsLeftToRight()
			This.RemoveCharsFromLeftW(pcCondition)

		else
			This.RemoveCharsFromRightW(pcCondition)
		ok


		def RemoveCharsFromStartWWQ(pcCondition)
			This.RemoveCharsFromStartW(pcCondition)
			return This

		def RemoveFromStartW(pcCondition)
			This.RemoveCharsFromStartW(pcCondition)

			def RemoveFromStartWQ(pcCondition)
				This.RemoveFromStartW(pcCondition)
				return This

		def RemoveStartW(pcCondition)
			This.RemoveFromStartW(pcCondition)

			def RemoveStartWQ(pcCondition)
				This.RemoveStartW(pcCondition)
				return This

	def CharsRemovedFromStart(pcCondition)
		cResult = This.Copy().RemoveCharsFromStartWQ(pcCondition).Content()
		return cResult

	  #---------------------------------------------------------#
	 #    REMOVING CHARS FROM END UNDER A GIVEN CONDITION    # 
	#---------------------------------------------------------#

	def RemoveCharsFromEndW(pcCondition)
		if This.IsLeftToRight()
			This.RemoveCharsFromRighttW(pcCondition)

		else
			This.RemoveCharsFromLeftW(pcCondition)
		ok

		def RemoveCharsFromEndWWQ(pcCondition)
			This.RemoveCharsFromEndW(pcCondition)
			return This

		def RemoveFromEndW(pcCondition)
			This.RemoveCharsFromEndW(pcCondition)

			def RemoveFromEndWQ(pcCondition)
				This.RemoveFromEndW(pcCondition)
				return This

		def RemoveEndW(pcCondition)
			This.RemoveFromEndW(pcCondition)

			def RemoveEndWQ(pcCondition)
				This.RemoveEndW(pcCondition)
				return This

	def CharsRemovedFromEnd(pcCondition)
		cResult = This.Copy().RemoveCharsFromEndWQ(pcCondition).Content()
		return cResult

	  #----------------------------------#
	 #    TRIMMING & REMOVING SPACES    # 
	#----------------------------------#

	def Trim()
		This.Update( This.QStringObject().trimmed() )

		def TrimQ()
			This.Trim()
			return This

	def Trimmed()
		cResult = This.Copy().TrimQ().Content()
		return cResult

		def WithoutLeadingAndTrailingSpaces()
			return This.Trimmed()

	def TrimStart()
		if This.HasRepeatedLeadingChars()	
			This.RemoveThisRepeatedLeadingChar(" ")
		ok

		if This.FirstChar() = " "
			This.RemoveFirst(" ")
		ok

		def TrimStartQ()
			This.TrimStart()
			return This

		def RemoveLeadingSpaces()
			This.TrimStart()

			def RemoveLeadingSpacesQ()
				This.RemoveLeadingSpaces()
				return This

	def TrimmedFromStart()
		cResult = This.Copy().TrimStartQ().Content()
		return cResult

		def LeadingSpacesRemoved()
			return This.TrimmedFromStart()

		def WithoutLeadingSpaces()
			return This.TrimmedFromStart()

	def TrimEnd()

		This.RemoveThisRepeatedTrailingChar(" ")

		if This.LastChar() = " "
			This.RemoveLast(" ")
		ok

		def TrimEndQ()
			This.TrimEnd()
			return This

		def RemoveTrailingSpaces()
			This.TrimEnd()

			def RemoveTrailingSpacesQ()
				This.RemoveTrailingSpaces()
				return This
	
	def TrimmedFromEnd()
		cResult = This.Copy().TrimEndQ().Content()
		return cResult

		def TrailingSpacesRemoved()
			return This.TrimmedFromEnd()

		def WithoutTrailingSpaces()
			return This.TrimmedFromEnd()

	def TrimLeft()
		if This.IsLeftToRight()
			This.TrimStart()

		else # IsRightToLeft
			This.TrimEnd()
		ok

		def TrimLeftQ()
			This.TrimLeft()
			return This

		def RemoveLeftSpaces()
			This.TrimeLeft()

			def RemoveLeftSpacesQ()
				This.RemoveLeftSpaces()
				return This

	def TrimmedFromLeft()
		cResult = This.Copy().TrimLeftQ().Content()
		return cResult

		def LeftSpacesRemoved()
			return This.TrimmedFromLeft()

		def WithoutLeftSpaces()
			return This.TrimmedFromLeft()

	def TrimRight()
		if This.IsRightToLeft()
			This.TrimStart()

		else # IsLeftToRight
			This.TrimEnd()
		ok

		def TrimRightQ()
			This.TrimRight()
			return This

		def RemoveRightSpaces()
			This.TrimRight()

			def RemoveRightSpacesQ()
				This.RemoveRightSpaces()
				return This

	def TrimmedFromRight()
		cResult = This.Copy().TrimRightQ().Content()
		return cResult

		def RightSpacesRemoved()
			return This.TrimmedFromRight()

		def WithoutRightSpaces()
			return This.TrimmedFromRight()

	def RemoveSpaces()
		This.RemoveAll(" ")

		def RemoveSpacesQ()
			This.RemoveSpaces()
			return This

		def RemoveAllSpaces()
			This.RemoveSpaces()

			def RemoveAllspacesQ()
				This.RemoveSpaces()
				return This

	def SpacesRemoved()
		cResult = This.Copy().RemoveSpacesQ().Content()
		return cResult

		def WithoutSpaces()
			return This.SpacesRemoved()

			#< @FunctionMisspelledForm

			def WithoutSapces()
				return This.WithoutSpaces()

			#>

	  #==========================================#
	 #  EXTRACTING A SUBSTRING FROM THE STRING  #
	#==========================================#

	def ExtractCS(pcSubStr, pCaseSensitive)
		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			StzRaise("Can't extract the substring It does not exist in the string.")
		ok

		This.RemoveCS(pcSubStr, pCaseSensitive)
		return pcSubStr

		def PopCS(pcSubStr, pCaseSensitive)
			return This.ExtractCS(pcSubStr, pCaseSensitive)

	def SubStringExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractCS(pcSubStr, pCaseSensitive)

		def SubStringPoppedCS(pcSubStr, pCaseSensitive)
			return This.SubStringExtractedCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def Extract(pcSubStr)
		return This.ExtractCS(pcSubStr, :CaseSensitive = TRUE)

		def Pop(pcSubStr)
			return This.Extract(pcSubStr)

	def SubStringExtracted(pcSubStr)
		return This.Extract(pcSubStr)

		def SubStringPopped(pcSubStr)
			return This.SubStringExtracted(pcSubStr)

	  #----------------------------------------------#
	 #  EXTRACTING MANY SUBSTRINGS FROM THE STRING  #
	#----------------------------------------------#

	def ExtractManyCS(paSubStrings, pCaseSensitive)
		if NOT This.ContainsManyCS(paSubStrings, pCaseSensitive)
			StzRaise("Can't extract the substrings! SubStrings in paSubStrings do not exist in the string.")
		ok

		This.RemoveManyCS(paSubStrings, pCaseSensitive)
		return paSubStrings

		def PopManyCS(paSubStrings, pCaseSensitive)
			return This.ExtractManyCS(paSubStrings, pCaseSensitive)

	def ManySubStringsExtractedCS(paSubStrings, pCaseSensitive)
		return This.ExtractManyCS(paSubStrings, pCaseSensitive)

		def ManySubStringsPoppedCS(paSubStrings, pCaseSensitive)
			return This.ExtractManyCS(paSubStrings, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractMany(paSubStrings)
		return This.ExtractManyCS(paSubStrings, :pCaseSensitive = TRUE)

		def PopMany(paSubStrings)
			return This.ExtractMany(paSubStrings)

	def ManySubStringsExtracted(paSubStrings)
		return This.ExtractMany(paSubStrings)

		def ManySubStringsPopped(paSubStrings)
			return This.ExtractMany(paSubStrings)

	  #-------------------------------------------------#
	 #  EXTRACTING ALL THE SUBSTRINGS FROM THE STRING  #
	#-------------------------------------------------#

	def ExtractAll()
		aResult = This.Content()
		This.Clear()
		return aResult

		def PopAll()
			return This.ExtractAll()

	def AllStringExtracted()
		return This.ExtractAll()

		def AllStringPopped()
			return This.ExtractAll()

	  #---------------------------#
	 #  EXTRACTING THE NTH CHAR  #
	#---------------------------#

	def ExtractAt(n)
		if isString(n) and ( n = :Last or n = :LastSubString )
			n = This.NumberOfSubStrings()
		ok

		if NOT isNumber(n) and Q(n).IsBetween(1, This.NumberOfSubStrings())
			StzRaise("Can't extract! n outside of range.")
		ok

		TempcSubStr = This.SubStringAt(n)

		This.RemoveAt(n)

		return TempcSubStr

		#< @FunctionAlternativeForms

		def ExtractNthChar(n)
			return This.ExtractAt(n)

		def ExtractCharAtPosition(n)
			return This.ExtractAt(n)

		def ExtractCharAt(n)
			return This.ExtractAt(n)

		#--

		def PopAt(n)
			return This.ExtractAt(n)

		def PopNthChar(n)
			return This.ExtractAt(n)

		def PopCharAtPosition(n)
			return This.ExtractAt(n)

		def PopCharAt(n)
			return This.ExtractAt(n)

		#>

	def NthCharExtracted(n)
		return This.ExtractAt(n)

		def NthCharPopped(n)
			return This.ExtractAt(n)

		def ExtractedAt(n)
			return This.ExtractAt(n)

		def PoppedAt(n)
			return This.ExtractAt(n)

	  #-----------------------------#
	 #  EXTRACTING THE FIRST CHAR  #
	#-----------------------------#

	def ExtractFirstChar()
		return This.ExtractAt(1)
 
		def PopFirstChar()
			return This.ExtractFirstChar()

	def FirstCharExtracted()
		return This.ExtractCharSubString()

		def FirstCharPopped()
			return This.ExtractFirstChar()

	  #----------------------------#
	 #  EXTRACTING THE LAST CHAR  #
	#----------------------------#

	def ExtractLastChar()
		return This.ExtractAt(This.NumberOfChars())

		def PopLastChar()
			return This.ExtractLastChar()

	def LastCharExtracted()
		return This.ExtractLastChar()

		def LastCharPopped()
			return This.ExtractLastChar()

	  #------------------------------------------------#
	 #  EXTRACTING THE NTH OCCURRENCE OF A SUBSTRING  #
	#------------------------------------------------#

	def ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		if This.FindNthOccurrenceCS(n, pcSubStr, pCaseSensitive) > 0
			This.RemoveNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			StzRaise("Can't extract! The list does not contain n occurrences of pcSubStr.")
		ok

		#< @FunctionAlternativeFroms

		def ExtractNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def PopNthOccurrenceCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		#>

	def NthOccurrenceExtractedCS(n, pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

		def NthOccurrencePoppedCS(n, pcSubStr, pCaseSensitive)
			return This.ExtractNthOccurrenceCS(n, pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractNthOccurrence(n, pcSubStr)
		return This.ExtractNthOccurrenceCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeFroms

		def ExtractNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNth(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		def PopNthOccurrence(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

		#>

	def NthOccurrenceExtracted(n, pcSubStr)
		return This.ExtractNthOccurrence(n, pcSubStr)

		def NthOccurrencePopped(n, pcSubStr)
			return This.ExtractNthOccurrence(n, pcSubStr)

	  #--------------------------------------------------#
	 #  EXTRACTING THE FIRST OCCURRENCE OF A SUBSTRING  #
	#--------------------------------------------------#

	def ExtractFirstCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(1, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopFirstCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def ExtractFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def PopFirstOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		#>

	def FirstOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

		def FirstOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractFirstCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractFirst(pcSubStr)
		return This.ExtractFirstCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def PopFirst(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def ExtractFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		def PopFirstOccurrence(pcSubStr)
			return This.ExtractFirst(pcSubStr)

		#>

	def FirstOccurrenceExtracted(pcSubStr)
		return This.ExtractFirst(pcSubStr)

		def FirstOccurrencePopped(pcSubStr)
			return This.ExtractFirst(pcSubStr)

	  #-------------------------------------------------#
	 #  EXTRACTING THE LAST OCCURRENCE OF A SUBSTRING  #
	#-------------------------------------------------#

	def ExtractLastCS(pcSubStr, pCaseSensitive)
		return This.ExtractNthOccurrenceCS(This.NumberOfChars(), pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PopLastCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def ExtractLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def PopLastOccurrenceCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		#>

	def LastOccurrenceExtractedCS(pcSubStr, pCaseSensitive)
		return This.ExtractLastCS(pcSubStr, pCaseSensitive)

		def LastOccurrencePoppedCS(pcSubStr, pCaseSensitive)
			return This.ExtractLastCS(pcSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ExtractLast(pcSubStr)
		return This.ExtractLastCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def PopLast(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def ExtractLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		def PopLastOccurrence(pcSubStr)
			return This.ExtractLast(pcSubStr)

		#>

	def LastOccurrenceExtracted(pcSubStr)
		return This.ExtractLast(pcSubStr)

		def LastOccurrencePopped(pcSubStr)
			return This.ExtractLast(pcSubStr)

	  #------------------------------------------------#
	 #  EXTRACTING CHARS VERIFYING A GIVEN CONDITION  #
	#------------------------------------------------#

	def ExtractCharsW(pcCondition)
		acResult = This.CharsW(pcCondition)
		if len(acResult) = 0
			StzRaise("Can't extract! The condition returns no values at all.")
		ok

		This.RemoveCharsW(pcCondition)
		return acResult

		def PopCharsW(pcCondition)
			return This.ExtractCharsW(pcCondition)

	def CharsExtractedW(pcCondition)
		return This.ExtractCharsW(pcCondition)

		def CharsPoppedW(pcCondition)
			return This.CharsExtractedW(pcCondition)

	  #-----------------------------------------------------#
	 #  EXTRACTING SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#-----------------------------------------------------#

	def ExtractSubStringsW(pcCondition)
		acResult = This.SubStringsW(pcCondition)
		if len(acResult) = 0
			StzRaise("Can't extract! The condition returns no values at all.")
		ok

		This.RemoveSubStringsW(pcCondition)
		return aResult

		def PopSubStringsW(pcCondition)
			return This.ExtractSubStringsW(pcCondition)

	def SubStringsExtractedW(pcCondition)
		return This.ExtractSubStringsW(pcCondition)

		def SubStringsPoppedW(pcCondition)
			return This.SubStringsExtractedW(pcCondition)

	  #--------------------------------------------------------------#
	 #  EXTRACTING CHARS OR SUBSTRINGS VERIFYING A GIVEN CONDITION  #
	#--------------------------------------------------------------#

	def ExtractW(pcCondition)
		if CheckParams()
			if NOT isString(pcCondition)
				SteRaise("Incorrect param type! pcCondition must be a string.")
			ok

			if NOT Q(pcCondition).ContainsEitherCS( "@char", :Or = "@substring", :CS = FALSE)
				StzRaise("Incorrect condition! pcCondition must contain either @char or @substring keywords.")
			ok
		ok

		acResult = []
		if Q(pcCondition).ContainsCS("@char", :CS = FALSE)
			acResult = This.CharsW(pcCondition)
		else
			acResult = This.SubStringsW(pcCondition)
		ok

		if len(acResult) = 0
			StzRaise("Can't extract! The condition returns no values at all.")
		ok

		This.RemoveW(pcCondition)
		return acResult

		def PopW(pcCondition)
			return This.ExtractW(pcCondition)

	  #----------------------------------------#
	 #  EXTRACTING A SECTION FROM THE STRING  #
	#----------------------------------------#

	def ExtractSection(n1, n2)

		if CheckParams()
			if NOT Q([n1, n2]).BothAreNumbers() and
		   	Q(n1).IsBetween(1, This.NumberOfSubStrings()) and
		   	Q(n2).IsBetween(1, This.NumberOfSubStrings())

				StzRaise("Can't extract! The section is outside the string.")
			ok
		ok

		aResult = This.Section(n1, n2)
		This.RemoveSection(n1, n2)
		return aResult

		#< @FunctionAlternativeForm

		def PopSection(n1, n2)
			return This.ExtractSection(n1, n2)

		#>

	def SectionExtracted(n1, n2)
		return This.ExtractSection(n1, n2)

		#< @FunctionAlternativeForm

		def SectionPopped(n1, n2)
			return This.SectionExtracted(n1, n2)

		#>

	  #--------------------------------------#
	 #  EXTRACTING A RANGE FROM THE STRING  #
	#--------------------------------------#

	def ExtractRange(nStart, nRange)
		return This.ExtractSection(nStart, nStart + nRange - 1)

		def PopRange(nStart, nRange)
			return This.ExtractRange(nStart, nRange)

	def RangeExtracted(nStart, nRange)
		return This.ExtractRange(nStart, nRange)

		def RangePopped(nStart, nRange)
			return This.RangeExtracted(nStart, nRange)

	  #----------------------------------------------------------#
	 #  EXTRACTING NEXT SUBSTRING STARTING AT A GIVEN POSITION  #
	#----------------------------------------------------------#

	def ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		if This.FindNext(pcSubStr, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemoveNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return pcSubStr

		#< @FunctionAlternativeForms

		def ExtractNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractNextSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractNextOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopNextOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def NextOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def NextOccurrenceExtractedSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def NextOccurrencePoppedSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractNextCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractNext(substring, pnStartingAt)
		return This.ExtractNext(substring, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ExtractNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		def PopNext(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		def PopNextOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		#--

		def ExtractNextS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		def ExtractNextOccurrenceS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		def PopNextS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		def PopNextOccurrenceS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		#>

	def NextOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractNext(pcSubStr, pnStartingAt)

		#< @FunctionAlternativeForms

		def NextOccurrenceExtractedS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)
	
		def NextOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)
	
		def NextOccurrencePoppedS(pcSubStr, pnStartingAt)
			return This.ExtractNext(pcSubStr, pnStartingAt)

		#>

	  #--------------------------------------------------------------#
	 #  EXTRACTING PREVIOUS SUBSTRING STARTING AT A GIVEN POSITION  #
	#--------------------------------------------------------------#

	def ExtractPreviousCS(substring, pnStartingAt, pCaseSensitive)
		if This.FindPreviousCS(substring, pnStartingAt, pCaseSensitive) = 0
			StzRaise("Can't extract! pcSubStr does not exist at the specified position.")
		ok

		This.RemovePreviousCS(substring, pnStartingAt, pCaseSensitive)
		return substring

		#< @FunctionAlternativeForms

		def ExtractPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#--

		def ExtractPreviousSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def ExtractPreviousOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		def PopPreviousOccurrenceSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	def PreviousOccurrenceExtractedCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#< @FunctionAlternativeForms

		def PreviousOccurrenceExtractedSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
		def PreviousOccurrencePoppedSCS(pcSubStr, pnStartingAt, pCaseSensitive)
			return This.ExtractPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def ExtractPrevious(substring, pnStartingAt)
		return This.ExtractPreviousCS(substring, pnStartingAt, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def ExtractPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		def PopPrevious(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		def PopPreviousOccurrence(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		#--

		def ExtractPreviousS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		def ExtractPreviousOccurrenceS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		def PopPreviousS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		def PopPreviousOccurrenceS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		#>

	def PreviousOccurrenceExtracted(pcSubStr, pnStartingAt)
		return This.ExtractPrevious(pcSubStr, pnStartingAt)

		#< @FunctionAlternativeForms

		def PreviousOccurrenceExtractedS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePopped(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)
	
		def PreviousOccurrencePoppedS(pcSubStr, pnStartingAt)
			return This.ExtractPrevious(pcSubStr, pnStartingAt)

		#>
	
	  #==========================================================#
	 #   SIMPLIFYING THE STRING BY REMOVING DUPLICATED SPACES   #
	#==========================================================#

	def Simplify()

		# t0 = clock() // Veryf fast, takes almost 0.01s

		This.Update( @oQString.simplified() )

		# ? ( clock() - t0 ) / clockspersecond()

		def SimplifyQ()
			This.Simplify()
			return This

	def Simplified()
		cResult = This.Copy().SimplifyQ().Content()
		return cResult

	  #-------------------------------------------------#
	 #   SIMPLIFYING THE STRING EXCEPT SOME SECTIONS   #
	#-------------------------------------------------#

	def SimplifyExcept(paSections)
		/* EXAMPLE

		o1 = new stzString(' this code:   txt1  = "    withspaces    "   and txt2="nospaces"  ')
		o1.SimplifyExcept( [ [], [] ] )

		#--> 'var txt = "    nice    "'

		*/

		if isList(paSections) and Q(paSections).IsSectionsNamedParam()
			paSections = paSections[2]
		ok

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		aAntiSections = This.AntiSectionsAsPairsOfNumbers(paSections)
		nLen = len(aAntiSections)

		for i = nLen to 1 step -1

			n1 = aAntiSections[i][1]
			n2 = aAntiSections[i][2]

			cSection = This.Section(n1, n2)

			cSectionSimplified = Q(cSection).Simplified()

			if (n2 - n1 + 1) > 2
				if Q(cSection).LastChar() = " " and
				   Q(cSectionSimplified).Last2CharsAsString() != "  "
	
					cSectionSimplified += " "
	
				but Q(cSection).FirstChar() = " " and
				    Q(cSectionSimplified).First2CharsAsString() != "  "
	
					cSectionSimplified = " " + cSectionSimplified
				ok
			ok

			This.ReplaceSection(n1, n2, cSectionSimplified)
		next

		This.Trim()

		def SimplifyExceptQ(paSections)
			This.SimplifyExcept(paSections)
			return This

	def SimplifiedExcept(paSections)
		cResult = This.Copy().SimplifyExceptQ().Content()
		return cResult

	  #==========================#
	 #  SPACIFYING THE STRING   #
	#==========================#

	def SpacifyXT(pcSeparator, pnStep, pcDirection)
		/* EXAMPLE

		Basic mode:

		o1 = new stzString("99999999999")
		? o1.SpacifiedXT(:Separator = "_", :Step = 3, :Direction = :Backward)
		#--> 99_999_999_999

		Advanced mode:
		
		o1 = new stzString("99999999999")
		o1.SpacifyXT(
			:Using    = [ ".", :AndThen = " " ],
			:Stepping = [ 2, :AndThen = 3],
			:Going    = :Backward
		)
		
		? o1.Content()
		#--> 99 999 999.99

		*/

		cMode = :Basic
		cSeparator2 = ""
		nStep2 = 0

		# Checking params correctness

		if isList(pcSeparator) and Q(pcSeparator).IsOneOfTheseNamedParams([ :Using, :Separator ])
			pcSeparator = pcSeparator[2]
		ok

		if isList(pnStep) and Q(pnStep).IsOneOfTheseNamedParams([ :Step, :Stepping, :EachNChars ])
			pnStep = pnStep[2]
		ok

		if isList(pcDirection) and Q(pcDirection).IsOneOfTheseNamedParams([ :Direction, :Going ])
			pcDirection = pcDirection[2]
		ok

		if NOT ( isString(pcDirection) and 
			 Q(pcDirection).IsOneOfThese([ :Default, :Forward, :Backward ]) )

			StzRaise("Incorrect param! pcDirection must be a string. " +
				 "Allowed values are :Default, :Forward, and :Backward.")

		ok

		# checking :Using = [ ".", :AndThen = " " ]
		if isList(pcSeparator) and (isString(pcSeparator[2]))

			cMode = :Extended
			pcSeparator = pcSeparator[1]
			cSeparator2 = pcSeparator[2]

		but isList(pcSeparator) and isList(pcSeparator[2]) and
		    Q(pcSeparator[2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isString(pcSeparator[2][2])

			cMode = :Extended
			cSeparator2 = pcSeparator[2][2]
			pcSeparator = pcSeparator[1]
			
		ok

		# checking :Stepping = [ 2, :AndThen = 3]
		if isList(pnStep) and (isNumber(pnStep[2]))

			cMode = :Basic
			pnStep = pnStep[1]
			nStep2 = pnStep[2]

		but isList(pnStep) and isList(pnStep[2]) and
		    Q(pnStep[2][2]).IsOneOfTheseNamedParams([:And, :AndThen]) and
		    isNumber(pnStep[2][2][2])

			cMode = :Extended
			nStep2 = pnStep[2][2][2]
			pnstep = pnStep[2][1]
			
		ok

		if NOT (isString(pcSeparator) and pcSeparator != "")
			StzRaise("Incorrect param type! pcSeparator must be a non null string.")
		ok

		if NOT (isNumber(pnStep) and pnStep != 0)
			StzRaise("Incorrect param type! pnStep must be a non null number.")
		ok

		# Doing the job

		nLen = This.NumberOfChars()

		if cMode = :Basic

			anPos = []
			if pcDirection = :Forward
					
				for i = (pnStep + 1) to nLen step pnStep
					anPos + i
				next

				This.InsertBeforeThesePositions(anPos, pcSeparator)

			but pcDirection = :Backward
		
				for i = (nLen - pnStep) to 1 step -pnStep

					anPos + i
				next

				This.InsertAfterThesePositions(anPos, pcSeparator)
			ok

			

		but cMode = :Extended
			
			nStart = 0
			if pcDirection = :Forward
				This.InsertBefore( pnStep + 1, pcSeparator )
				nStart = pnStep + nStep2 + 1
			else
				This.InsertBefore( nLen - pnStep + 1, pcSeparator )
				nStart = nLen - pnStep - nStep2
			ok

			pnStep = nStep2
			pcSeparator = cSeparator2
			anPos = []

			if pcDirection = :Forward
				for i = nStart to nLen step pnStep
					anPos + i
				next
		
			but pcDirection = :Backward
		
				for i = nStart to 1 step -pnStep
					anPos + i
				next
			ok

			This.InsertAfterThesePositions(anPos, pcSeparator)

		ok

		def SpacifyXTQ(pcSeparator, pnStep, pcDirection)
			This.SpacifyXT(pcSeparator, pnStep, pcDirection)
			return This

	def SpacifiedXT(pcSeparator, pnStep, pcDirection)
		return This.Copy().SpacifyXTQ(pcSeparator, pnStep, pcDirection).Content()

	  #----------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING   #
	#----------------------------------------#

	def SpacifyEachNChars(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsQ(n)
			This.SpacifyEachNChars(n)
			return This

	def EachNCharsSpacified(n)
		return This.Copy().SpacifyEachNCharsQ(n).Content()

	#--

	def SpacifyEachNCharsForward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Forward)

		def SpacifyEachNCharsForwardQ(n)
			This.SpacifyEachNCharsForward(n)
			return This

	def EachNCharsSpacifiedForward(n)
		return This.Copy().SpacifyEachNCharsForwardQ(n).Content()

	#--

	def SpacifyEachNCharsBackward(n)
		This.SpacifyXT(:Using = " ", :EachNChars = n, :Backward)

		def SpacifyEachNCharsBackwardQ(n)
			This.SpacifyEachNCharsBackward(n)
			return This

	def EachNCharsSpacifiedBackward(n)
		return This.Copy().SpacifyEachNCharsBackwardQ(n).Content()

	#--

	def SpacifyChars()
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").Spacified()
		#--> R I N G O R I A L A N D

		*/
		This.SpacifyXT(:Using = " ", :EachNChars = 1, :Forward)

		def SpacifyCharsQ()
			This.SpacifyChars()
			return This

		def Spacify()
			This.SpacifyChars()

			def SpacifyQ()
				This.Spacify()
				return This

	def CharsSpacified()
		cResult = This.Copy().SpacifyCharsQ().Content()
		return cResult

		def Spacified()
			return This.CharsSpacified()

	  #----------------------------------------------------------------#
	 #   SPACIFYING THE CHARS OF THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------#

	def SpacifyCharsUsing(pcSep)
		/* EXAMPLE

		? StzStringQ("RINGORIALAND").SpacifiedUsing("_")
		#--> R_I_N_G_O_R_I_A_L_A_N_D

		*/

		This.SpacifyXT(:Using = pcSep, :EachNChars = 1, :Forward)

		def SpacifyCharsUsingQ(pcSep)
			This.SpacifyCharsUsing(pcSep)
			return This

		def SpacifyUsing(pcSep)
			This.SpacifyCharsUsing(pcSep)

			def SpacifyUsingQ(pcSep)
				This.SpacifiyUsing(pcSep)
				return This

	def CharsSpacifiedUsing(pcSep)
		cResult = This.Copy().SpacifyCharsUsingQ(pcSep).Content()
		return cResult

		def SpacifiedUsing(pcSep)
			return CharsSpacifiedUsing(pcSep)

	  #--------------------------------------------------------------------------#
	 #  SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING USING A GIVEN SEPARATOR  #
	#--------------------------------------------------------------------------#

	def SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
		This.AddBoundsToSubStringCS(pcSubStr, pcSep, pcSep, pCaseSensitive)
		
		#< @FunctionFluentForm

		def SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringUsingCS(pcSubStr, pcSep, pCaseSensitive)
			return This

		#>

	def SubStringSpacifiedUsingCS(pcSubStr, pcSep, pCaseSensitive)
		cResult = This.Copy().SpacifySubStringUsingCSQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubstringUsing(pcSubStr, pcSep)
		This.SpacifySubStringUsingCS(pcSubStr, pcSep, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringUsingQ(pcSubStr, pcSep)
			This.SpacifySubstringUsing(pcSubStr, pcSep)
			return This

		#>

	def SubStringSpacifiedUsing(pcSubStr, pcSep)
		cResult = This.Copy().SpacifySubStringUsingQ(pcSubStr, pcSep, pCaseSensitive).Content()
		return cResult

	  #----------------------------------------------------#
	 #   SPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#----------------------------------------------------#

	def SpacifySubstringCS(pcSubStr, pCaseSensitive)
		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcSubStr must be a string.")
		ok

		anSections = This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive).Reversed()
	
		for aSection in anSections
			n1 = aSection[1]
			n2 = aSection[2]

			if n2 < This.NumberOfChars() and
			   This.CharAt(n2 + 1) != " "

				This.InsertAfter(n2, " ")
			ok

			if n1 > 1 and This.CharAt(n1 - 1) != " "
				This.InsertBefore(n1, " ")
			ok
		next

		def SpacifySubStringCSQ(pcSubStr, pCaseSensitive)
			This.SpacifySubStringCS(pcSubStr, pCaseSensitive)
			return This

		def SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
			This.SpacifySubstringCS(pcSubStr, pCaseSensitive)

			def SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive)
				This.SpacifyThisSubStringCS(pcSubStr, pCaseSensitive)
				return This

	def SubStringSpacifiedCS(pcSubStr, pCaseSensitive)
		return This.Copy().SpacifyThisSubStringCSQ(pcSubStr, pCaseSensitive).Content()

		def ThisSubStringSpacifiedCS(pcSubStr, pCaseSensitive)
			return This.SubStringSpacifiedCS(pcSubStr, pCaseSensitive)

	#-- CASE-SENSITIVE

	def SpacifySubstring(pcSubStr)
		This.SpacifySubstringCS(pcSubStr, :CaseSensitive = TRUE)

		def SpacifySubstringQ(pcSubStr)
			This.SpacifySubstring(pcSubStr)
			return This

		def SpacifyThisSubString(pcSubStr)
			This.SpacifySubstring(pcSubStr)

			def SpacifyThisSubStringQ(pcSubStr)
				This.SpacifyThisSubString(pcSubStr)
				return This

	def SubStringSpacified(pcSubStr)
		return This.Copy().SpacifyThisSubStringQ(pcSubStr).Content()

		def ThisSubStringSpacified(pcSubStr)
			return This.SubStringSpacified(pcSubStr)

	  #----------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING   #
	#----------------------------------------------#

	def SpacifySubStringsCS(pacSubStr, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("IbelieveinRingfutureandengageforit!")

		o1.SpacifyTheseSubStrings([
			"believe", "in", "Ring", "future", "and", "engage", "for"
		])

		#--> I believe in Ring future and engage for it!

		*/

		This.SpacifySubStringsUsingCS(pacSubStr, " ", pCaseSensitive)

		#< @FuncionFluentForm

		def SpacifySubStringsCSQ(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This

		def SpacifyTheseCS(pacSubStr, pCaseSensitive)
			This.SpacifySubStringsCS(pacSubStr, pCaseSensitive)

			def SpacifyTheseCSQ(pacSubStr, pCaseSensitive)
				This.SpacifyTheseSubStringsCS(pacSubStr, pCaseSensitive)
				return This


		#>

	def SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
		return This.Copy().SpacifySubStringsCSQ(pacSubStr, pCaseSensitive).Content()

		def TheseSubStringsSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

		def TheseSpacifiedCS(pacSubStr, pCaseSensitive)
			return This.SubStringsSpacifiedCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStrings(pacSubStr)
		This.SpacifySubStringsCS(pacSubStr, :CaseSensitive = TRUE)

		def SpacifySubStringsQ(pacSubStr)
			This.SpacifySubStrings(pacSubStr)
			return This

		def SpacifyTheseSubStrings(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseSubStringsQ(pacSubStr)
				This.SpacifyTheseSubStrings(pacSubStr)
				return This

		def SpacifyThese(pacSubStr)
			This.SpacifySubStrings(pacSubStr)

			def SpacifyTheseQ(pacSubStr)
				This.SpacifyThese(pacSubStr)
				return This

	def SubStringsSpacified(pacSubStr)
		return This.Copy().SpacifySubStringsQ(pacSubStr).Content()

		def TheseSubStringsSpacified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

		def TheseSpaccified(pacSubStr)
			return This.SubStringsSpacified(pacSubStr)

	  #----------------------------------------------------------------------#
	 #   SPACIFYING MANY SUBSTRINGS IN THE STRING USING A GIVEN SEPARATOR   #
	#----------------------------------------------------------------------#

	def SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

		if NOT ( isList(pacSubStr) and Q(pacSubStr).isListOfStrings() )
			stzRaise("Incorrect param! pacSubStr must be a list of strings.")
		ok


		if NOT ( isList(pacSubStr) and Q(pacSubStr).isListOfStrings() )
			stzRaise("Incorrect param! pacSubStr must be a list of strings.")
		ok

		# Removing duplicates from the provided substrings

		pacSubStr = Q(pacSubStr).DuplicatesRemoved()
		nLen = len(pacSubStr)

		# Among the substrings provided, idenifying those that
		# actually exist in the string (others are ignored)

		acSubstrings = []
		for i = 1 to nLen
			if This.ContainsCS(pacSubStr[i], pCaseSensitive)
				acSubstrings + pacSubStr[i]
			ok
		next
		#--> [ "believe", "in", "Ring", "future", "and", "engage", "for" ]
		nLenSubStr = len(acSubStrings)

		if nLenSubStr = 0
			return
		ok

		# Sorting the substrings in descending order

		acSubStrings = QR(acSubStrings, :stzListOfStrings).SortedInDescendingBy('Q(@string).NumberOfChars()')
		nLenSubStr = len(acSubStrings)

		aSections = []
		aSectionsNow = [ [ 1, This.NumberOfChars() ] ]

		for i = 1 to nLenSubStr

			aTempSections = This.FindInSectionsAsSectionsCS(
					acSubStrings[i], aSectionsNow, pCaseSensitive)

			nLenTemp = len(aTempSections)

			for j = 1 to nLenTemp
				aSections + aTempSections[j]
			next

			aSectionsNow = This.FindAntiSections( aSections )

		next

		This.SpacifySections(aSections)


		#< @FunctionFluentForm

		def SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseSubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		def SpacifyTheseUsingCS(pacSubStr, pcSep, pCaseSensitive)
			This.SpacifySubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)

			def SpacifyTheseUsingCSQ(pacSubStr, pcSep, pCaseSensitive)
				This.SpacifyTheseSubStringsUsingCS(pacSubStr, pcSep, pCaseSensitive)
				return This

		#>

	def SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
		return This.Copy().SpacifySubStringsUsingCSQ(pacSubStr, pcSep, pCaseSensitive).Content()

		#< @FunctionAlternativeForms

		def TheseSubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		def TheseSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)
			return This.SubStringsSpacifiedUsingCS(pacSubStr, pcSep, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def SpacifySubStringsUsing(pacSubStr, pcSep)
		This.SpacifySubStringsUsingCS(pacSubStr, pcSep, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def SpacifySubStringsUsingQ(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)
			return This

		def TheseSpacifiedUsingUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

		#>

		#< @FunctionAlternativeForms

		def SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
			This.SpacifySubStringsUsing(pacSubStr, pcSep)

			def SpacifyTheseSubStringsUsingQ(pacSubStr, pcSep)
				This.SpacifyTheseSubStringsUsing(pacSubStr, pcSep)
				return This

		#>

	def SubStringsSpacifiedUsing(pacSubStr, pcSep)
		return This.Copy().SpacifySubStringsUsingQ(pacSubStr, pcSep).Content()

		def TheseSubStringsSpacifiedUsing(pacSubStr, pcSep)
			return This.SubStringsSpacifiedUsing(pacSubStr, pcSep)

	  #------------------------------------------#
	 #   SPACIFITYING A SECTION OF THE STRING   #
	#------------------------------------------#

	def SpacifySection(n1, n2)

		cLeftSpace = ""
		if This.CharAt(n1) != " "
			cLeftSpace = " "
		ok

		cRightSpace = ""
		if This.CharAt(n2)
			cRightSpace = " "
		ok

		This.ReplaceSection(n1, n2, :By = (cLeftSpace + This.Section(n1, n2) + cRightSpace) )

		def SpacifySectionQ(n1, n2)
			This.SpacifySection(n1, n2)
			return This

	def SectionSpacified(n1, n2)
		cResult = This.Copy().SpacifySectionQ(n1, n2).Content()
		return cResult

	  #----------------------------------------------#
	 #   SPACIFITYING MANY SECTIONS OF THE STRING   #
	#----------------------------------------------#

	def SpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		nLen = len(paSections)
		anPos = []
		for i = 1 to nLen
			anPos + paSections[i][1]
			anPos + (paSections[i][2] + 1)
		next

		This.InsertBeforePositions(anPos, " ")

		def SpacifySectionsQ(paSections)
			This.SpacifySections(paSections)
			return This

	def SectionsSpacified(paSections)
		cResult = This.Copy().SpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #   UNSPACIFYING THE STRING --> REMOVING SPACES  #
	#================================================#

	def UnSpacify()
		if This.Content() = ""
			return

		but This.NumberOfChars() = 1 and This.Content() = " "
			This.Clear()

		but This.NumberOfChars() = 2
			if This.Content() = " " + " "
				This.Update(" ")

			but This.Contains(" ")
				This.Remove(" ")
			ok

		else

			This.Trim()
		ok


		def UnSpacifyQ()
			This.UnSpacify()
			return This

	def Unspacified()
		return This.Copy().UnSpacifyQ().Content()

	  #------------------------------------------------------#
	 #   UNSPACIFYING A GIVEN SUBSTRING INSIDE THE STRING   #
	#------------------------------------------------------#

	def UnSpacifySubStringCS(pcSubStr, pCaseSensitive)

		if NOT ( isString(pcSubStr) and Q(pcSubStr).ContainsSpaces() )
			StzRaise("Incorrect param! pcSubStr must be a string containing spaces.")
		ok

		if NOT This.ContainsCS(pcSubStr, pCaseSensitive)
			return
		ok

		aSections = This.FindAsSectionsCS(pcSubStr, pCaseSensitive)
		This.ReplaceSections( aSections, Q(pcSubStr).Unspacified() )

	def UnSpacifySubString(pcSubStr)
		This.UnSpacifySubStringCS(pcSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------#
	 #   UNSPACIFITYING A SECTION OF THE STRING   #
	#--------------------------------------------#

	def UnSpacifySection(n1, n2)
		This.ReplaceSection(n1, n2, :By = Q(This.SectionQ(n1, n2).Unspacified()) )

		def UnSpacifySectionQ(n1, n2)
			This.UnSpacifySection(n1, n2)
			return This

	def SectionUnSpacified(n1, n2)
		cResult = This.Copy().UnSpacifySectionQ(n1, n2).Content()
		return cResult

	  #------------------------------------------------#
	 #   UNSPACIFITYING MANY SECTIONS OF THE STRING   #
	#------------------------------------------------#

	def UnSpacifySections(paSections)
		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )
			StzRaise("Incorrect param type! paSections must be a list of pairs of numbers.")
		ok

		paSections = StzListOfPairsQ(paSections).SortedInAscending()
		nLen = len(paSections)

		for i = nLen to 1 step -1
			n1 = paSections[i][1]
			n2 = paSections[i][2]

			cSectionWithoutSpaces = This.SectionQ(n1, n2).Unspacified()
			This.ReplaceSection( n1, n2, :By = cSectionWithoutSpaces )

		next

		def UnSpacifySectionsQ(paSections)
			This.UnSpacifySections(paSections)
			return This

	def SectionsUnSpacified(paSections)
		cResult = This.Copy().UnSpacifySectionsQ(paSections).Content()
		return cResult

	  #================================================#
	 #    GETTING POSITION AFTER A GIVEN SUBSTRING    #
	#================================================#

	def PositionAfterCS(cSubStr, pCaseSensitive)
		return This.PositionAfterNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionAfterNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		n = This.FindNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		oStr = new stzString(cSubStr)
		return n + oStr.NumberOfChars()

	def PositionAfter(cSubStr)
		return This.PositionAfterCS(cSubStr, :CaseSensitive = TRUE)

	def PositionAfterNthOccurrence(n, cSubStr)
		return This.PositionAfterNthOccurrenceCS(n, cSubStr, :CaseSensitive = TRUE)

	  #--------------------------------------------------#
	 #    GETTING POSITION BEFORE A GIVEN SUBSTRING     #
	#--------------------------------------------------#

	def PositionBeforeCS(cSubStr, pCaseSensitive)
		return This.PositionBeforeNthOccurrenceCS(1, cSubStr, pCaseSensitive)

	def PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)
		return This.FindNthOccurrenceCS(cSubStr, pCaseSensitive)
	
	def PositionBefore(cSubStr)
		return This.PositionBeforeCS(cSubStr, :CaseSensitve = FALSE)

	def PositionBeforeNthOccurrence(n, cSubStr)
		return This.PositionBeforeNthOccurrenceCS(n, cSubStr, pCaseSensitive)

	  #------------------------------#
	 #   FINDING THE CENTRAL CHAR   #
	#------------------------------#
	
	// Returns the position (if any) of the central Char in the string
	def FindCentralChar()
		nResult = 0

		oNumberOfChars = new stzNumber(This.NumberOfChars())
		if oNumberOfChars.IsOdd()
			nResult = ( This.NumberOfChars() + 1 ) / 2
		ok

		return nResult

		#< @FunctionAlternativeForms

		def FindMiddleChar()
			return This.FindCentralChar()

		def PositionOfCentralChar()
			return This.FindCentralChar()

		def CentralCharposition()
			return This.FindCentralChar()

		def PositionOfMiddleChar()
			return This.FindCentralChar()

		def MiddleCharposition()
			return This.FindCentralChar()


		#>

	  #------------------------------#
	 #   GETTING THE CENTRAL CHAR   #
	#------------------------------#

	def CentralChar()
		if This.CentralCharPosition() != NULL
			return This.NthChar( This.CentralCharPosition() )
		ok

		def CentralCharQ()
			return This.CentralCharQR(:stzChar)
	
		def CentralCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzChar
				return new stzChar( This.CentralChar() )
			on :stzString
				return new stzString( This.CentralChar() )
			on :stzListOfBytes
				return new stzListOfBytes( This.CentralChar() )
			off

		def MiddleChar()
			return This.CentralChar()

	  #-----------------------------------------------#
	 #   DOES THE STRING CONTAIN ANY CENTRAL CHAR?   #
	#-----------------------------------------------#

	def ContainsCentralChar()
		return This.NumberOfCharsQ().IsNotEven()

		def ContainsMiddleChar()
			return This.ContainsCentralChar()

		def HasCentralChar()
			return This.ContainsCentralChar()

		def HasMiddleChar()
			return This.ContainsCentralChar()

	  #---------------------------------------------------#
	 #   DOES THE STRING CONTAIN A GIVEN CENTRAL CHAR?   #
	#---------------------------------------------------#

	def ContainsCharInTheCenter(c)
		return This.CentralChar() = c

		def ContainsCharInTheMiddle(c)
			return This.ContainsCharInTheCenter()

		def HasCharInTheCenter(c)
			return This.ContainsCharInTheCenter(c)

		def HasCharInTheMiddle(c)
			return This.ContainsCharInTheMiddle(c)

	  #----------------------------------------------------#
	 #    DOES THE STRING CONTAIN ANY MIDDLE SUBSTRING?   #
	#----------------------------------------------------#

	def ContainsMiddleSubstring()
		if This.NumberOfCharsQ().IsOdd()
			return TRUE

		else
			return FALSE
		ok

		def HasMiddleSubstring()
			return This.ContainsMiddleSubstring()

		def ContainsCentralSubString()
			return This.ContainsMiddleSubstring()

		def HasCentralSubString()
			return This.ContainsMiddleSubstring()

	  #---------------------------------------------------------#
	 #    DOES THE STRING CONTAIN A GIVEN MIDDLE SUBSTRING?    #
	#---------------------------------------------------------#

	def ContainsSubstringInTheMiddle(pcSubStr)
		if IsStzString(pcSubStr)
			pcSubStr = pcSubStr.Content()
		ok

		if This.MiddleSubstring() = pcSubStr
			return TRUE
		else
			return FALSE
		ok

		def HasSubstringInTheCenter(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

		def ContainsSubstringInTheCenter(c)
			return This.ContainsSubstringInTheMiddle(c)

		def HasSubstringInTheMiddle(pcSubStr)
			return This.ContainsSubstringInTheMiddle(c)

	  #---------------------------------------------------#
	 #    GETTING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def MiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		cResult = ""

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			n1 = nNumberOfCharsOfOnePart + 1
			n2 = nNumberOfChars - nNumberOfCharsOfOnePart

			cResult = This.Section( n1, n2 )
		ok

		return cResult

		#< @FunctionALternativeForms

		def CentralSubstringWithNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def MiddleSubstringN(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringUpToNChars(n)
			return This.MiddleSubstringWithNChars(n)

		def CentralSubstringN(n)
			return This.MiddleSubstringWithNChars(n)


		#>

	  #---------------------------------------------------#
	 #    FINDING THE MIDDLE SUBSTRING UP TO N CHARS     #
	#---------------------------------------------------#

	def FindMiddleSubstringWithNChars(n)
		if NOT isNumber(n)
			stzRaise("Incorrect param type! n must be a number.")
		ok

		nNumberOfChars = This.NumberOfChars()

		if NOT n <= nNumberOfChars
			stzRaise("Out of range!")
		ok

		nResult = 0

		nNumberOfCharsWithoutmiddle = nNumberOfChars - n
		if StzNumberQ( nNumberOfCharsWithoutmiddle ).IsEven()

			nNumberOfCharsOfOnePart = nNumberOfCharsWithoutmiddle / 2
			nResult = nNumberOfCharsOfOnePart + 1
		ok

		return nResult

		#< @FunctionALternativeForms

		def FindCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def FindCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#--

		def PositionOfMiddleSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringWithNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfMiddleSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringUpToNChars(n)
			return This.FindMiddleSubstringWithNChars(n)

		def PositionOfCentralSubstringN(n)
			return This.FindMiddleSubstringWithNChars(n)

		#>

	  #--------------------------------#
	 #   GETTING STRING ORIENTATION   #
	#--------------------------------#

	/*
	Note that we distinguish between string 'orientation', 
	char 'orientation', and char 'unicode direction'.

	The first says if a string is left-to-right or right-to-left oriented, and
	uses the Orientation() method, here, in stzString.

	The second says the same thing for the individual chars, and uses
	the Orientation() method on stzChar.

	While the third informs us about the technical direction of the char,
	in terms of UNICODE standard, and is returned using UnicodeDirection()
	method on stzChar.
	*/

	// Returns the orientation of the string (:RightToLeft OR :LeftToRight)
	def Orientation()
		if This.IsRightToLeft()
			return :RightToLeft
		else
			return :LeftToRight
		ok

	// Verifies if the string is right-to-left (like arabic) : SEE Orientation()
	def IsRightToleft()
		bResult = @oQString.isRightToleft()

		return bResult

	// Verifies if the string is left-to-right (like english)
	def IsLeftToRight()
		IF NOT This.IsRightToLeft()
			return TRUE
		else
			return FALSE

		ok

	// Checks if the text is hybrid (containing :RightToLeft AND :LeftToRight" texts)
	def ContainsHybridOrientation()
		aStzChars = This.ToListOfStzChars()

		bIsHybrid = FALSE
		cFlag = aStzChars[1].Orientation()

		for i=2 to len(aStzChars)
			if aStzChars[i].Orientation() != cFlag
				bIsHybrid = TRUE
				exit
			ok
		next

		return bIsHybrid

	// Transforms the string to a list of chars with indication of their orientation
	def CharsWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)
			aResult + [ This.Char(i) , oTempChar.Orientation() ]
		next

		return aResult

	def CharsWithOrientationQ()
		return new stzList( This.CharsWithOrientation() )

	// Transforms the string to a list of letters with indication of their orientation
	def LettersWithOrientation()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			oTempChar = This.CharQ(i)

			if oTempChar.isLetter()
				aResult + [ This.Char(i) , oTempChar.Orientation() ]
			ok
		next

		return aResult

	def LettersWithOrientationQ()
		return new stzList( This.LettersWithOrientation() )

	  #----------------------#
	 #     ONLY NUMBERS     #
	#----------------------#
		
	/* Returns (as a string) only the numbers contained in the string

	   Note: if the string contains "", for example, then it is returned
	   as the number 36 contained in a string ("36")!

	   To return just numbers formed from decimal digits from 0 to 9,
	   use OnlyDecimalDigits()
	*/

	def OnlyNumbers()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsANumber()
				cResult += c
			ok
		next
		return cResult

		def OnlyNumbersQ()
			return new stzString( This.OnlyNumbers() )

	def OnlyDecimalDigits()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.IsDecimalDigit()
				cResult += c
			ok
		next
		return cResult

	def OnlyDecimalDigitsQ()
		return new stzList( This.OnlyDecimalDigits() )

	  #------------------------------------------#
	 #     ONLY LETTERS AND SPACES ANS CHARS    #
	#------------------------------------------#

	// Returns (as a string) only the letters contained in the string
	def OnlyLetters()
		cResult = NULL
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			oChar = new stzChar(c)
			if oChar.isLetter()
				cResult += c
			ok
		next
		return cResult

	def OnlyLettersQ()
		return new stzList(This.OnlyLetters())

	#----

	def OnlyLettersAndSpaces()
		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)

			if StzCharQ(c).IsLetterOrSpace()

				cResult += c
			ok
		next

		return cResult

	def OnlyLettersAndSpacesQ()
		return new stzString( This.OnlyLettersAndSpaces() )

	#----

	def OnlyLettersAndSpacesAndChar(pcChar)

		# t0 = clock() # Takes almost 0.62s

		cResult = ""
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			c = This.NthChar(i)
			oChar = new stzChar(c)

			if oChar.IsLetterOrSpaceOrChar(pcChar)
				cResult += c
			ok
		next

		# ? ( clock() - t0 ) / clockspersecond()

		return cResult

		def OnlyLettersAndSpacesAndThisChar(pcChar)
			return This.OnlyLettersAndSpacesAndChar(pcChar)

	def OnlyLettersAndSpacesAndCharQ(pcChar)
		return new stzString( This.OnlyLettersAndSpacesAndChar(pcChar) )

		def OnlyLettersAndSpacesAndThisCharQ(pcChar)
			return OnlyLettersAndSpacesAndCharQ(pcChar)

	#----

	def OnlyLettersAndSpacesAndChars(pacChars)
		return This.ItemsWhere('isLetter(@item) or isSpace(@item) or Q(@item).IsOneOfThese(pacChars)')

		def OnlyLettersAndSpacesAndCharsQ(paChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

		def OnlyLettersAndSpacesAndTheseChars(pacChars)
			return This.OnlyLettersAndSpacesAndChars(pacChars)

	def IsLetterOrSpaceOrChar(pcChar)
		return This.IsLetterOrSpaceOrOneOfTheseChars([ pcChar ])

		def IsLetterOrSpaceOrThisChar(pcChar)
			return IsLetterOrSpaceOrChar(pcChar)

	def IsLetterOrSpaceOrChars(pacChar)
		bResult = FALSE

		if This.IsLetter() or This.IsSpace() or
		   This.IsOneOfThese(pacChars)

			return TRUE
		else
			return FALSE
		ok

		def IsLetterOrSpaceOrOneOfTheseChars(pacChar)
			return This.IsLetterOrSpaceOreChars(pacChar)

	  #==========================#
	 #    ALIGNING THE STRING   #
	#==========================#

	def Align(pcDirection)
		This.AlignXT( :Max, " ", pcDirection )

		#< @FunctionFluentForms

		def AlignQ(pcDirection)
			This.Align(pcDirection)
			return This

		def AlignQC(pcDirection)
			return This.Copy().Align(pcDirection)

		#>

		#< @FunctionAlternativeForms

		def AlignTo(pcDirection)
			This.Align(pcDirection)

			def AlignToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AlignToQC(cDirection)
				return This.AlignQC(cDirection)

		def Adjust(pcDirection)
			This.Align(pcDirection)

			def AdjustQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustQC(cDirection)
				return This.AlignQC(cDirection)

		def AdjustTo(pcDirection)
			This.Align(pcDirection)

			def AdjustToQ(cDirection)
				return This.AlignQ(cDirection)
	
			def AdjustToQC(cDirection)
				return This.AlignQC(cDirection)
		#>
		
	def Aligned(cDirection)
		return This.Copy().AlignQ(cDirection).Content()

		#< @FunctionAlternativeForms

		def AlignedTo(cDirection)
			return This.Aligned(cDirection)

		def Adjusted(cDirection)
			return This.Aligned(cDirection)

		def AdjustedTo(cDirection)
			return This.Aligned(cDirection)

		#>
	  #-----------------------------------#
	 #  ALIGNING THE STRING -- EXTENDED  #
	#-----------------------------------#

	// Aligns the text in a container of width nWidth
	// Note: if the width is smaller then the string, nothing is done!

	def AlignXT(nWidth, cChar, cDirection)
		# cChar is the char to fill the 'blanks" with.

		if isList(nWidth) and Q(nWidth).IsWidthNamedParam()
			nWidth = nWidth[2]
		ok

		if isList(cChar) and ( Q(cChar).IsUsingNamedParam() or
			Q(cChar).IsCharNamedParam() )

			cChar = cChar[2]
		ok

		if isString(cChar) and cChar = ""
			cChar = " "
		ok

		if isList(cDirection) and ( Q(cDirection).IsOneOfTheseNamedParams([ :Direction, :Going ]) or
			Q(cDirection).IsToNamedParam() )

			cDirection = cDirection[2]
		ok

		switch cDirection

		on :Left
			return This.AlignLeftXT(nWidth, cChar)

		on :Right
			return This.AlignRightXT(nWidth, cChar)

		on :Center
			return This.AlignCenterXT(nWidth, cChar)

		on :Justified
			return This.JustifyXT(nWidth, cChar)

		other
			stzRaise(stzStringError(:UnsupportedStringJustificationDirection))
		end

		#< @FunctionFluentForm

		def AlignXTQ(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)
			return This
	
		#>

		#< @FunctionAlternativeForm

		def AdjustXT(nWidth, cChar, cDirection)
			This.AlignXT(nWidth, cChar, cDirection)

			def AdjustXTQ(nWidth, cChar, cDirection)
				return This.AlignXTQ(nWidth, cChar, cDirection)

		#>

	def AlignedXT(nWidth, cChar, cDirection)
		cResult = This.Copy().AlignXTQ(nWidth, cChar, cDirection).Content()
		return cResult

		def AdjustedXT(nWidth, cChar, cDirection)
			return This.AlignedXT(nWidth, cChar, cDirection)

	  #-----------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT  #
	#-----------------------------------#

	def LeftAlign(nWidth)
		This.LeftAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def LeftAlignQ(nWidth)
			This.LeftAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AlignToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AlignToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def LeftAdjust(nWidth)
			This.LeftAlign(nWidth)

			def LeftAdjustQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		def AdjustToLeft(nWidth)
			This.LeftAlign(nWidth)

			def AdjustToLeftQ(nWidth)
				return This.LeftAlignQ(nWidth)

		#>

	def LeftAligned(nWidth)
		cResult = This.Copy().LeftAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		def LeftAdjusted(nWidth)
			return This.LeftAligned(nWidth)

		def AdjustedToLeft(nWidth)
			return This.LeftAligned(nWidth)

		#>

	  #-----------------------------------------------#
	 #  ALIGNING THE STRING TO THE LEFT -- EXTENDED  #
	#-----------------------------------------------#

	def LeftAlignXT(nWidth, cChar)

		/* NOTE

		Managing the special case of the arabic char (Shaddah)
		which can alter the justification of text, because Qt
		treats it as a spearate char with its own position in
		the resulting string, while it must set on top of chars!

		Note: The same case of arabic diacritics (7araket)
		is not managed in this version (In the future,
		an extended arabic library will manage those (and other)
		specificities of arabic language.

		WARNING: In this version, if your arabic text contains
		arabic diactritics (7arakets), then the alignment
		won't be correct!

		Also, for this alignement to work as expected, the font
		you use in to display the text on the console must be
		of "fixed size".

 		*/

		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the alignment using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			// Take in account a logical error of Qt in aligning non
			// left-to-right strings (like arabic and hebrew)

			if This.IsRightToLeft()
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def LeftAlignXTQ(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignLeftXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def AlignLeftXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		def LeftAdjustXT(nWidth, cChar)
			This.LeftAlignXT(nWidth, cChar)

			def LeftAdjustXTQ(nWidth, cChar)
				return This.LeftAlignXTQ(nWidth, cChar)

		#>

	def LeftAlignedXT(nWidth, cChar)
		cResult = This.Copy().LeftAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToLeftXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		def LeftAdjustedXT(nWidth, cChar)
			return This.LeftAlignedXT(nWidth, cChar)

		#>

	  #------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT  #
	#------------------------------------#

	def RightAlign(nWidth)
		This.RightAlignXT(nWidth, " ")

		#< @FunctioFluentForm

		def RightAlignQ(nWidth)
			This.RightAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRight(nWidth)
			This.RightAlign(nWidth)

			def AlignRightQ(nWidth)
				return This.RightAlignQ(nWidth)

		def AlignToRight(nWidth)
			This.RightAlign(nWidth)

			def AlignToRightQ(nWidth)
				return This.RightAlignQ(nWidth)
	
		def RightAdjust(nWidth)
			This.RightAlign(nWidth)

			def RightAdjustQ(nWidth)
				return This.RightAlignQ(nWidth)

		#>

	def RightAligned(nWidth)
		cResult = This.Copy().RightAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRight(nWidth)
			return This.RightAligned(nWidth)

		def RightAdjusted(nWidth)
			return This.RightAligned(nWidth)

		def AdjustedtoRight(nWidth)
			return This.RightAligned(nWidth)

		#>

	  #------------------------------------------------#
	 #  ALIGNING THE STRING TO THE RIGHT -- EXTENDED  #
	#------------------------------------------------#

	def RightAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification using Qt

		if nWidth > This.NumberOfChars()
			oChar = new stzChar(cChar)
			oQChar = oChar.QCharObject()

			if This.IsRightToLeft()
				cJustified = @oQString.leftJustified(nWidth, oQChar, FALSE)
			else
				cJustified = @oQString.rightJustified(nWidth, oQChar, FALSE)
			ok
	
			This.Update( cJustified )
		ok

		#< @FunctionFluentForm

		def RightAlignXTQ(nWidth, cChar)
			
			This.RightAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignRightXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def AlignRightXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		def RightAdjustXT(nWidth, cChar)
			This.RightAlignXT(nWidth, cChar)

			def RightAdjustXTQ(nWidth, cChar)
				return This.RightAlignXTQ(nWidth, cChar)

		#>

	def RightAlignedXT(nWidth, cChar)
		cResult = This.Copy().RightAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def RightAdjustedXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		def AdjustedToRightXT(nWidth, cChar)
			return This.RightAlignedXT(nWidth, cChar)

		#>

	  #------------------------#
	 #  CENTERING THE STRING  #
	#------------------------#

	def CenterAlign(nWidth)
		This.CenterAlignXT(nWidth, " ")

		#< @FunctionFluentForm

		def CenterAlignQ(nWidth)
			This.CenterAlign(nWidth)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AlignCenter(nWidth)
			This.CenterAlign(nWidth)

			def AlignCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def CenterAdjust(nWidth)
			This.CenterAlign(nWidth)

			def CenterAdjustQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustToCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustToCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def AdjustCenter(nWidth)
			This.CenterAlign(nWidth)

			def AdjustCenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		def Center(nWidth)
			This.CenterAlign(nWidth)

			def CenterQ(nWidth)
				return This.CenterAlignQ(nWidth)

		#>

	def CenterAligned(nWidth)
		cResult = This.Copy().CenterAlignQ(nWidth).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def AdjustedToCenter(nWidth)
			return This.CenterAligned(nWidth)

		def CenterAdjusted(nWidth)
			return This.CenterAligned(nWidth)

		def Centered(nWidth)
			This.CenterAligned(nWidth)

		#>

	  #------------------------------------#
	 #  CENTERING THE STRING -- EXTENDED  #
	#------------------------------------#

	def CenterAlignXT(nWidth, cChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth > This.NumberOfChars()

			n = nWidth - This.NumberOfChars()
			n1 = 0
			n2 = 0

			oNumber = new stzNumber(n)
			if oNumber.IsEven()
				n1 = n / 2
				n2 = n1
			else
				n1 = (n - 1) / 2
				n2 = n1 + 1
			ok

			cResult = StringRepeat(cChar, n1) +
				  This.String() +
				  StringRepeat(cChar, n2)

			This.Update( cResult )
		ok

		#< @FunctionFluentForm

		def CenterAlignXTQ(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)
			return This

		#>

		#< @FunctionAlternativeForms

		def AlignCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AlignToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AlignToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterAdjustXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterAdjustXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def AdjustToCenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def AdjustToCenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		def CenterXT(nWidth, cChar)
			This.CenterAlignXT(nWidth, cChar)

			def CenterXTQ(nWidth, cChar)
				return This.CenterAlignXTQ(nWidth, cChar)

		#>

	def CenterAlignedXT(nWidth, cChar)
		cResult = This.Copy().CenterAlignXTQ(nWidth, cChar).Content()
		return cResult

		#< @FunctionAlternativeForms

		def AlignedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenterAdjustedXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def AdjustedToCenterXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		def CenteredXT(nWidth, cChar)
			return This.CenterAlignedXT(nWidth, cChar)

		#>

	  #-------------------------#
	 #  JUSTIFYING THE STRING  #
	#-------------------------#

	def Justify(nWidth)
		This.JustifyXT(nWidth, " ")

		def JustifyQ(nWidth)
			This.Justify(nWidth)
			return This

		// NEW: returns a jystified copy of the string object
		// --> Useful in copy-on-right (functional) programming
		def JustifyQC(nWith)
			return This.Copy().Justify(nWidth)

	def Justified(nWidth)
		return This.Copy().JustifyQ(nWidth).Content()

	  #-------------------------------------#
	 #  JUSTIFYING THE STRING -- EXTENDED  #
	#-------------------------------------#

	def JustifyXT(nWidth, pcChar)

		# See comment in LeftAlign() method
 
		nWidth += This.NumberOfOccurrence( ArabicShaddah() )

		# Computing the justification

		if nWidth <= This.NumberOfChars()
			return NULL
		ok

		nPoints = nWidth - This.NumberOfChars()
		aTemp = []

		nLen = This.NumberOfChars()

		for i = 1 to nLen - 1

			cCurrentChar = This.Char(i)

			if NOT ( CharIsArabicShaddah(cChar) or CharIsArabic7arakah(cCurrentChar) )

				aTemp + cCurrentChar
			else
				if len(aTemp) != 0
					aTemp[ len(aTemp) ] = aTemp[ len(aTemp) ] + cCurrentChar
				ok
			ok
		next

		while nPoints > 0
			for i = 1 to len(aTemp)
				aTemp[i] = aTemp[i] + pcChar
				nPoints--
				if nPoints = 0 { exit }
			next
		end

		aTemp + This.LastChar()

		cResult = ""
		for str in aTemp
			cResult += str
		next

		cResult = Q(cResult).ReplaceQ(" ", pcChar).Content()
		This.Update( cResult )

		def JustifyXTQ(nWidth, pcChar)
			This.JustifyXT(nWidth, pcChar)
			return This

	def JustifiedXT(nWidth, pcChar)
		cResult = This.Copy().JustifyXTQ(nWidth, pcChar).Content()

	  #==================================#
	 #    TEXT ENCODING & CONVERTING    #
	#==================================#

	//Returns a UTF-8 representation of the string (using QByteArray)
	def ToUTF8()
		return QByteArrayToListOfUnicodes(@oQString.toUtf8())

	def ToUTF8Q()
		return new stzString( This.ToUTF8() )

	def FromUTF8(pcUTF8String)
		// TODO

	def ToLatin1()
		return @oQString.toLatin1()

	def FromLatin1(pcLatin1String)
		// TODO

	def ToLocal8Bit()
		return @oQString.toLocal8Bit()

	def ToBase64()
		return This.ToStzListOfBytes().ToBase64()

		def ToBase64Q()
			return new stzString( This.ToBase64() )

	// Transforms the content of the string to a url-like encoded string
	def ToPercentEncoding(pcExcludedFromEncoding, pcIncludedInEncoding, pcPercentAsciiChar)
		/* Example:
		o1 = new stzString("{a fishy string?}")
		? o1.ToPercentEncoding( "{}", "s" )

		--> {a%20fi%73hy%20%73tring%3F}
		*/

	// Updates the list of bytes with an url-like decoded copy of the provided string
	def FromPercentEncoding(pcPercentEncodedString, pcPercentAsciiChar) // TODO
		/* Example:
		o1 = new stzString("")
		o1.FromPercentEncoding( "{a%20fi%73hy%20%73tring%3F}", "%" )
		o1.Content()

		--> {a fishy string?}
		*/

	def ToHex()
		return str2hex( This.String() )

		def ToHexQ()
			return new stzString( This.ToHex() )

	def ToHexSpacified()
		cHex = This.ToHex()
		n = ceil( StzStringQ(cHex).NumberOfChars() / This.NumberOfBytes() )

		cResult = StzStringQ(cHex).InsertAfterEveryNCharsQ(n, " ").Content()
		return cResult

	def FromHex(cHex)
		@oQString = new QString2()
		@oQString.append(hex2str(cHex))

		def FromHexQ(cHex)
			This.FromHex(cHex)
			return This

	// Escapes HTML special Chars in the string
	def EscapeHtml()
		cResult = @oQString.toHtmlEscaped()

		return cResult

		def EscapeHtmlQ()
			return new stzString( This.EscapeHtml() )

	def HtmlEscaped()
		return This.EscapeHtmlQ().Content()
	
	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// Transforms the string to a number based on the defined format
	// --> TODO: Use the ApplyFormat() method in the stzNumber class...
	// Rething the naming!
	def ToNumberFormatted(cFormat) // TODO
		/*
		o1 = new stzString("+12500,14")
		? o1.ToNumberFormatted( :As = "+99 999.99") --> 12 500.14
		*/

		stzRaise("Function unavailable in this version!")

		def ToNumberFormattedQ(cFormat)
			return new stzNumber( This.ToNumberFormatted() )

	  #------------------------------------------------#
	 #    UNICODE CODES OF THE CHARS OF THE STRING    #
	#------------------------------------------------#

	// The following method is mainly used by stzChar class to
	// create a characrer object from text
	def UnicodeOfCharN(n)
		oTempQStr = new QString2()
		oTempQStr.append(This[n])
		return oTempQStr.unicode().unicode()
		/*
		The first unicode() on QString returns a QChar,
		while the seconde unicode() on this QChar returns
		the actual decimal unicode of the Char
		*/

	// Returns a list of unicodes of all the Chars in the string
	def Unicodes()
		aResult = []
		for i = 1 to This.NumberOfChars()
			aResult + This.UnicodeOfCharN(i)
		next

		return aResult

		def UnicodesQR(pcReturnType)
			if isList(pcReturnType) and
			   Q(pcReturnType).IsReturnedAsNamedParam()

				pcReturnType = pcReturnType[2]
			ok

			if NOT 	( isString(pcReturnType) and
				  Q(pcReturnType).IsStzClassName()
				)

				stzRaise("Incorrect param type! pcReturnType must " +
					 "be a string containin a Softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Unicodes() )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.Unicodes() )

			other
				stzRaise("Unsupported return type!")
			off

	def Unicode()
		if This.NumberOfChars() = 1
			return This.UnicodeOfCharN(1)

		else
			return This.Unicodes()
		ok

	def CharsAndUnicodes()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.Char(i), This.UnicodeOfCharN(i) ]
		next

		return aResult

		def CharsAndTheirUnicodes()
			return This.CharsAndUnicodes()

		def UnicodesPerChar()
			return This.CharsAndUnicodes()

	def UnicodesAndChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			aResult + [ This.UnicodeOfCharN(i), This.Char(i) ]
		next

		return aResult

		def UnicodesAndTheirChars()
			return This.UnicodesAndChars()

		def UnicodesXT()
			return This.UnicodesAndChars()

	
		def CharsPerUnicode()
			return This.UnicodesAndChars()

	  #-------------------#
	 #    CHARS NAMES    #
	#-------------------#

	def CharsNames()
		acResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			acResult + This.CharQ(i).Name()
		next

		return acResult

		def CharNamesQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			if pcReturnType = :stzList
				return new stzList(This.CharNames())

			pcReturnType = :stzListOfStrings
				return new stzListOfString(This.CharNames())

			else
				stzRaise("Unsupported return type!")
			ok

		def CharNamesQ()
			return This.CharNamesQR(:stzListOfStrings)

		def CharsAndTheirNames()
			return This.CharsNames()

	def CharName()
		return This.CharsNames()[1]

		def CharNameQ()
			return new stzString(This.CharName())

	  #===============================#
	 #    MULTINGUAL & LOCLAE INFO   #
	#===============================#

	/*
	In Softanza, a unicode code of a language, country or locale can be:
		* number : like "6" for arabic
		* name : like "arabic" for arabic
		* abbreviation : like "ar" (short form) and "ara" (long form) for arabic
	*/

	def IsLanguageIdentifier()
		return 	This.IsLanguageNumber() or
			This.IsLanguageAbbreviation() or
			This.IsLanguageName()

	def IsLanguageNumber()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if aLanguageInfo[1] = This.String()
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsLanguageCode()
			return This.IsLanguageNumber()

	def IsShortLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLongLanguageAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageAbbreviation()
		/* Could be written expressively like this:

		return This.IsLanguageShotAbbreviation() OR This.IsLanguageLongAbbreviation()

		but the following is mutch more efficient: */

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()

			if lower(aLanguageInfo[3]) = lower(This.String()) OR
			   lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageShortAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[3]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsLanguageLongAbbreviation()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[4]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def LanguageAbbreviationForm()

		if NOT This.IsLanguageAbbreviation()
			cForm = :NotLanguage
		
		else

			if This.IsLanguageShortAbbreviation()
				cForm = :Short

			but This.IsLanguageLongAbbreviation()
				cForm = :Long
			ok
		ok

		return cForm

	def IsLanguageName() # In english

		if This.IsEmpty() { return FALSE }

		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aLanguageInfo in LocaleLanguagesXT()
			if lower(aLanguageInfo[2]) = lower(This.String())
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsNotLanguageName()
			return NOT This.IsLanguageName()

	def IsNativeLanguageName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzStringError(:UnsupportedFeatureInThisVersion)) # TODO

	def IsCountryIdentifier()
		return 	This.IsCountryNumber() or
			This.IsCountryAbbreviation() or
			This.IsCountryName() or
			This.IsCountryPhoneCode()

	def IsCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr) OR
			   UPPER(aCountryInfo[4]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsCountryName()
		if This.IsEmpty() { return FALSE }

		cName = This.String()
		bResult = FALSE
		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[2]) = lower(cName)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsNotCountryName()
			return NOT This.IsCountryName()

	def IsNativeCountryName() # Locale-specific
		if This.IsEmpty() { return FALSE }

		stzRaise(stzString(:UnsupportedFeatureInThisVersion))

	def IsCountryPhoneCode()
		if This.IsEmpty() { return FALSE }

		cPhoneCode = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if aCountryInfo[5] = cPhoneCode
				bResult = TRUE
				exit
			ok
		next

		return bResult

	def IsCountryNumber()
		if This.IsEmpty() { return FALSE }

		cNumber = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if lower(aCountryInfo[1]) = lower(cNumber)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsCountryCode()
			return This.IsCountryNumber()

	def IsShortCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[3]) = UPPER(cAbbr)

				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryShortAbbreviation()
			return This.IsShortCountryAbbreviation()

	def IsLongCountryAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCountryInfo in LocaleCountriesXT()
			if UPPER(aCountryInfo[4]) = UPPER(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

		def IsCountryLongAbbreviation()
			return This.IsLongCouontryAbbreviation()

	def IsCountryAbbreviationXT()
		/*
		Returns :
		[ TRUE, :Short ] or [ :TRUE, :Long ] or [ FALSE, NULL ]
		*/

		if This.IsEmpty() { return FALSE }

		bAbbr = This.IsCountryAbbreviation()
		ctype = :Nothing

		if This.IsShortCountryAbbreviation()
			cType = :Short
		but This.IsLongCountryAbbreviation()
			cType = :Long
		ok

		return [ bAbbr, cType ]
	
	def IsScriptIdentifier()
		return 	This.IsScriptNumber() or
			This.IsScriptAbbreviation() or
			This.IsScriptName()

	# Script abbreviation can't be short or long, it is always 4 chars long!
	def IsScriptAbbreviation()
		if This.IsEmpty() { return FALSE }

		cAbbr = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[3]) = lower(cAbbr)
				bResult = TRUE
				exit
			ok
		next
	
		return bResult

	def IsScriptName()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[2]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScript()
			return This.IsScriptName()

		def IsNotScriptName()
			return NOT This.IsScriptName()

	def IsScriptNumber()
		if This.IsEmpty() { return FALSE }

		cScript = This.String()
		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aScriptInfo in LocaleScriptsXT()
			if lower(aScriptInfo[1]) = lower(cScript)
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def IsScriptCode()
			return This.IsScriptNumber()

	def IsLocaleAbbreviation()
		cThisString = This.Copy().ReplaceQ("_", "-").Content()
		oLocalesInString = StzStringQ( LocaleAbbreviationsHostedInString() )
		bResult = oLocalesInString.ContainsCS( cThisString, :CaseSensitive = FALSE )

		return bResult
	
	def ContainsLocaleSeparator()
		return This.Contains("_") or This.Contains("-")

	def ExtractLocaleSeparator()

		if This.ContainsLocaleSeparator()
			if This.Contains("_")
				return "_"

			but This.Contains("-")
				return "-"
			ok
		ok

	def ContainsNoLocaleSeparator()
		return NOT This.ContainsLocaleSeparator()

	def ContainsOneLocaleSeparator()
		return  This.ContainsNTimes(1, "_") or
			This.ContainsNTimes(1, "_")

	def IsLocaleSeparator()
		return This.Content() = "_" or This.Content() = "-"

	def IsCurrencyName()
		if This.IsEmpty() { return FALSE }

		bResult = FALSE

		# TODO: Replace for/in with for --> better performance
		for aCurrencyInfo in CurrenciesXT()
			if lower(aCurrencyInfo[1]) = This.Lowercased()
				bResult = TRUE
				exit
			ok
		next

		return bResult	

	def IsCurrencySymbol()	# TODO
		if This.IsEmpty() { return FALSE }
		
	def IsBp64LocaleAbbreviation() # Like "ar-TN" for example
		if This.IsEmpty() { return FALSE }

		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsDayName() # In english

		return This.IsDayNameIn(:English)

	def IsDayNameIn(pcLanguageName)
		if This.IsEmpty() { return FALSE }

		return This.LowercaseQ().IsOnOfThese(NamesOfDaysIn(pcLanguageName))

	def IsNativeDayNameInLocale(pLocale) # Locale-specific
		if This.IsEmpty() { return FALSE }

		return This.IsEqualToCS(StzLocaleQ(pLocale).NativeDayName(), :CaseSensitive = FALSE)

	def IsMonthName() # In english
		stzRaise(:UnsupportedFeatureInThisVersion)

	def IsNativeMonthName() # Locale-specific
		stzRaise(:UnsupportedFeatureInThisVersion)

	  #========================#
	 #    NUMBER IN STRING    #
	#========================#

	def RepresentsDecimalNumber()
		return This.RepresentsNumberInDecimalForm()

		def IsNumberInString()
			return This.RepresentsDecimalNumber()

		def IsANumberInString()
			return This.RepresentsDecimalNumber()

		def IsNumberInAString()
			return This.RepresentsDecimalNumber()

		def IsANumberInAString()
			return This.RepresentsDecimalNumber()

		def RepresentsADecimalNumber()
			return This.RepresentsDecimalNumber()

		def IsDecimalNumberInString()
			return This.RepresentsDecimalNumber()

		def IsDecimalNumberInAString()
			return This.RepresentsDecimalNumber()

		def IsADecimalNumberInString()
			return This.RepresentsDecimalNumber()

		def IsADecimalNumberInAString()
			return This.RepresentsDecimalNumber()

	def RepresentsBinaryNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInBinaryForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsABinaryNumber()
			return This.RepresentsBinaryNumber()

		def IsBinaryNumberInString()
			return This.RepresentsBinaryNumber()

		def IsBinaryNumberInAString()
			return This.RepresentsBinaryNumber()

		def IsABinaryNumberInString()
			return This.RepresentsBinaryNumber()

		def IsABinaryNumberInAString()
			return This.RepresentsBinaryNumber()

	def RepresentsOctalNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInOctalForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAnOctalNumber()
			return This.RepresentsOctalNumber()

		def IsOctalNumberInString()
			return This.RepresentsOctalNumber()

		def IsOctalNumberInAString()
			return This.RepresentsOctalNumber()

		def IsAnOctalNumberInString()
			return This.RepresentsOctalNumber()

		def IsAnOctalNumberInAString()
			return This.RepresentsOctalNumber()

	def RepresentsHexNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInHexForm()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAHexNumber()
			return This.RepresentsHexNumber()

		def IsHexNumberInString()
			return This.RepresentsHexNumber()

		def IsHexNumberInAString()
			return This.RepresentsHexNumber()

		def IsAHexNumberInString()
			return This.RepresentsHexNumber()

		def IsAHexNumberInAString()
			return This.RepresentsHexNumber()

	def RepresentsScientificNotationNumber()
		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInScientificNotation()
			return TRUE

		else
			return FALSE
		ok

		def RepresentsAScientificNumber()
			return This.RepresentsScientificNumber()

		def IsScientificNumberInString()
			return This.RepresentsScientificNumber()

		def IsScientificNumberInAString()
			return This.RepresentsScientificNumber()

		def IsAScientificNumberInString()
			return This.RepresentsScientificNumber()

		def IsAScientificNumberInAString()
			return This.RepresentsScientificNumber()

	def NumberForm()
		if NOT This.RepresentsNumber()
			return :NotNumber

		else
 			if This.RepresentsNumberInDecimalForm()
				return :Decimal

		   	but This.RepresentsNumberInBinaryForm()
				return :Binary

		   	but This.RepresentsNumberInOctalForm()
				return :Octal

		   	but This.RepresentsNumberInHexForm()
				return :Hex

			but This.RepresentsNumberInScientificNotation()
				return :ScientificNotation
			ok
		ok

	def RepresentsNumber()

		oCopy = This.RemoveSpacesQ()

		if oCopy.RepresentsNumberInDecimalForm() or
		   oCopy.RepresentsNumberInBinaryForm() or
		   oCopy.RepresentsNumberInOctalForm() or
		   oCopy.RepresentsNumberInHexForm() or
		   oCopy.RepresentsNumberInScientificNotation()
			
			return TRUE

		else

			return FALSE
		ok

		#< @FunctionAlternativeForms

		def RepresentsANumber()
			return This.RepresentsNumber()

		def RepresentsNumberInString()
			return This.RepresentsNumber()

		def RepresentsNumberInAString()
			return This.RepresentsNumber()

		def RepresentsANumberInString()
			return This.RepresentsNumber()

		def RepresentsANumberInAString()
			return This.RepresentsNumber()

		#>
	
	def RepresentsSignedNumber()
		if This.RepresentsNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedNumber()
			return This.RepresentsSignedNumber()

	def RepresentsUnsignedNumber()
		if This.RepresentsNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedNumber()
			return This.RepresentsUnsignedNumber()		

	def RepresentsCalculableNumber() 

		if This.RepresentsCalculableInteger() or
		   This.RepresentsCalculableRealNumber()

			return TRUE

		else
			return FALSE
		ok
				 
		/* INFO
		Non calculable numbers are: 
		-  other numbers in Uniocde, like circled number icons,
		   roman and indian numbers and others

		- numbers in any form (decimal, binary, octal, hex, scientific)
		  that can not be calculated "precisily" with Ring, as defined by
		  MinCalculableNumber() and MaxCalculableNumber()
		*/

		def RepresentsACalculableNumber() 
			return This.RepresentsCalculableNumber() 

	def RepresentsInteger()
		if This.RepresentsNumber() and This.ContainsNo(".")
			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnInteger()
			return This.RepresentsInteger()

	def RepresentsSignedInteger()
		if This.RepresentsInteger() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedInteger()
			return This.RepresentsSignedInteger()

	def RepresentsUnsignedInteger()
		if This.RepresentsInteger() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedInteger()
			return This.RepresentsUnsignedInteger()

	def RepresentsCalculableInteger()

		if This.representsInteger()

			# Step 1: we define the number of digits of
			# the integer and the maximum number of digits
			# allowed by Ring for integers
			
			if This.RepresentsSignedInteger()

				nNumberOfDigits = This.NumberOfChars() - 1
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedInteger()

			else

				nNumberOfDigits = This.NumberOfChars()
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedInteger()
			ok

			# Step 2: we compare between them to kwow if this
			# integer is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		def RepresentsACalculableInteger()
			return This.RepresentsCalculableInteger()

	def RepresentsRealNumber()
		if This.RepresentsNumber() and This.Contains(".")
			return TRUE
		else
			return FALSE
		ok

		def RepresentsARealNumber()
			return This.RepresentsRealNumber()		

	def RepresentsSignedRealNumber()
		if This.RepresentsRealNumber() and
		   (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsASignedRealNumber()
			return This.RepresentsSignedRealNumber()		

	def RepresentsUnsignedRealNumber()
		if This.RepresentsRealNumber() and
		   NOT (This.FirstChar() = "+" or This.FirstChar() = "-")

			return TRUE
		else
			return FALSE
		ok

		def RepresentsAnUnsignedRealNumber()
			return This.RepresentsUnsignedRealNumber()		

	def RepresentsCalculableRealNumber()
		
		if This.RepresentsRealNumber()

			# Step1: We split the string to get integer and
			# decimal parts and calculate the number of
			# digits in the real number

			cIntegerPart = This.Split(".")[1]
			nNumberOfDigitsIncIntegerPart = len(cIntegerPart)

		 	if ring_left(cIntegerPart, 1) = "+" or
			   ring_left(cIntegerPart, 1) = "-"
				nNumberOfDigitsIncIntegerPart--
			ok

			cFractionalPart = This.Split(".")[2]
			nNumberInDigitsInFractionalPart = len(cFractionalPart)

			nNumberOfDigits = nNumberOfDigitsIncIntegerPart +
					  nNumberInDigitsInFractionalPart

			# Step 2: We compute the maximum number of digits allowed
			# depending on the real number being singed or unsigned

			nMaxNumberOfDigits = 0
			if This.RepresentsSignedRealNumber()
				nMaxNumberOfDigits = MaxNumberOfDigitsInSignedRealNumber()
			else
				nMaxNumberOfDigits = MaxNumberOfDigitsInUnsignedRealNumber()
			ok

			# Step 3: we compare between them to kwow if this real
			# number is calculable precisely by Ring or not

			if nNumberOfDigits <= nMaxNumberOfDigits
				return TRUE
			else
				return FALSE
			ok

		else
			return FALSE
		ok

		def RepresentsACalculableRealNumber()
			return This.RepresentsCalculableRealNumber()

	def RepresentsNumberInDecimalForm()

		# Rule 1: String shouldn't be null

		if This.Content() = ""
			return FALSE
		ok

		# Rule 2: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" or
		    This.Content() = " ")

			return FALSE
		ok

		# Rule 3: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 4: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 5: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 6: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( "0":"9" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInDecimalForm()
			return This.RepresentsNumberInDecimalForm()

	// Checks if the string corresponds to a binary number started by the
	// prefix defined in BinaryNumberPrefix() and composed of 0s and 1s

	def RepresentsNumberInBinaryForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must contains 0s or 1s

		if This.ContainsNo("0") and This.ContainsNo("1")
			return FALSE
		ok

		# Rule 3: String should be prefixed with a binary prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cBinPrefix in BinaryPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cBinPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 4: String shouldn't be just one of these chars

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_")

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( "0":"1" + "b" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInBinaryForm()
			return This.RepresentsNumberInBinaryForm()

	// Checks if the string corresponds to a hex number form
	def RepresentsNumberInHexForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain just a hex prefix

		if This.IsEqualToOneOfTheseCS(HexPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 3: String should be prefixed with a hex prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cHexPrefix in HexPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cHexPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 4: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 5: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 6: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 7: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 8: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that chars correspond to digits, signs or separators

		oPossibleChars = new stzList( HexChars() + "x" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)	

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a hex number

		return TRUE

		def RepresentsANumberInHexForm()
			return This.RepresentsNumberInHexForm()

	def RepresentsNumberInUnicodeHexForm()
		if NOT This.LeftNCharsQ(2).Uppercased() = "U+"
			return FALSE
		ok
	
		if This.IsEqualToOneOfTheseCS("U", "U+")
			return FALSE
		ok

		cNumber = This.LeftNCharsRemoved(2)
	
		if IsHexNumber( HexPrefix() + cNumber )
			return TRUE
		else
			return FALSE
		ok

		def RepresentsANumberInUnicodeHexForm()
			return This.RepresentsNumberInUnicodeHexForm()

	// Checks if the string corresponds to an octal number
	def RepresentsNumberInOctalForm()

		# Rule 1: String shouldn't be null or formed of just spaces

		if This.IsEmpty()
			return FALSE
		ok

		# Rule 2: String must not contain only an octal prefix

		if This.IsEqualToOneOfTheseCS(OctalPrefixes(), :CS = FALSE)
			return FALSE
		ok

		# Rule 4: String should be prefixed with an octal prefix

		bTemp = FALSE

		# TODO: Replace for/in with for --> better performance
		for cOctalPrefix in OctalPrefixes()
			oCopy = This.Copy()
			oCopy.RemoveFromLeftQ("-").RemoveFromLeftQ("+")

			if oCopy.StartsWithCS(cOctalPrefix, :CaseSensitive = FALSE)
				bTemp = TRUE
				exit
			ok
		next
		if bTemp = FALSE { return FALSE }

		# Rule 5: String shouldn't be formed of these chars alone

		if This.NumberOfChars() = 1 and
		   (This.Content() = "+" or This.Content() = "-" or
		    This.Content() = "." or This.Content() = "_" )

			return FALSE
		ok

		# Rule 6: String shouldn't contain more then once these chars

		if This.NumberOfOccurrence("-") > 1 or
		   This.NumberOfOccurrence("+") > 1 or
		   This.NumberOfOccurrence(".") > 1

			return FALSE
		ok

		# Rule 7: If "-" sign exits, then it should prefix the string

		if This.Contains("-") and This.FirstChar() != "-"
			return FALSE
		ok

		# Rule 8: If "+" sign exits, then it should prefix the string

		if This.Contains("+") and This.FirstChar() != "+"
			return FALSE
		ok

		# Rule 9: If "." separator exists, then it shouldn't be at the end

		if This.Contains(".") and This.LastChar() = "."
			return FALSE
		ok

		# Now, let's check that the chars correspond to digits, signs or separators

		oPossibleChars = new stzList( OctalChars() + "o" + "-" + "+" + "." + "_" )

		for i = 1 to This.NumberOfChars()
			c = This.NthChar(i)

			if NOT oPossibleChars.Contains(c)
				return FALSE
			ok

		next

		# At this level, we can be sure the string is a decimal number

		return TRUE

		def RepresentsANumberInOctalForm()
			return This.RepresentsNumberInOctalForm()

	def RepresentsNumberInScientificNotation()
		// TODO
		StzRaise("Unsupported feature yet!")

		def RepresentsANumberInScientificNotation()
			return This.RepresentsNumberInScientificNotation()

	def IsNumberFraction() # of the form "1/2" or "/" or "/" or
					  # even "/" (in mandarin numerals)
		bResult = FALSE

		if This.NumberOfChars() = 3
			aStzChars = This.ToListOfStzChars()
			if aStzChars[1].IsANumber() and
			   (aStzChars[2].Content() = "/" or aStzChars[2].Content() = ":") and
			   aStzChars[3].IsANumber()

				bResult = TRUE
			ok
		ok

		def IsANumberFraction()
			return This.IsNumberFraction()

		def IsNumberFractionInString()
			return This.IsNumberFraction()

		def IsANumberFractionInString()
			return This.IsNumberFraction()

	  #==============#
	 #    CHARS     #
	#==============#

	// Returns the string as a list of Chars
	def Chars()

		acResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
			acResult + This.NthChar(i)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsQ()
			return This.CharsQR(:stzList)

		def CharsQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Chars() )

			on :stzListOfChars
				return new stzListOfChars( This.Chars() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Chars() )
			other
				stzRaise([
					:Where = "stzString (13237) > CharsQR()",
					:What  = "Unsupported type!"
				])
			off

		#>

		#< @FunctionAlternativeForms

		def ToListOfChars()
			return This.Chars()

			#< @FunctionFluentForm

			def ToListOfCharsQR(pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.Chars() )

				on :stzListOfChars
					return new stzListOfChars( This.Chars() )

				on :stzListOfStrings
					return new stzListOfStrings( This.Chars() )

				other
					stzRaise("Unsupported type!")
				off 

			def ToListOfCharsQ()
				return This.ToListOfCharsQR(:stzListOfChars)

			def ToStzListOfChars()
				return This.ToListOfCharsQR(:stzListOfChars)


			#>
	
		#>
			
	def ToListOfStzChars()
		aResult = []
		nLen = This.NumberOfChars()

		for i = 1 to nLen
		# Warning: Note that using 'for in' yields erronous
		# result for strings coded on more then 1 byte
			aResult + This.CharQ(i)
		next
		return aResult

		#< @FunctionFluentForm

		def ToListOfStzCharsQ()
			return new stzList( This.ToListOfStzChars() )

		#>

	  #=====================================================#
	 #  CHECKING IF THE STRING IS THE NAME OF A FUNCTION   #
	#=====================================================#
	/*
	TODO: Distinguish between Ring, Softanza, Qt, and other
	libraries functions, classes, and attributes.
	*/

	def IsAFunction()
		if ring_find( functions(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok
 
		def IsAFunctionName()
			return This.IsAFunction()

		def IsFunction()
			return This.IsAFunction()

		def IsFunctionName()
			return This.IsAFunction()

		#--

		def IsFunc()
			return This.IsAFunction()

		def IsFunctName()
			return This.IsAFunction()

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A CLASS   #
	#--------------------------------------------------#

	def IsAClass()
		if ring_find( classes(), This.Lowercased() ) > 0
			return TRUE
		else
			return FALSE
		ok

		def IsAClassName()
			return This.IsAClass()

		def IsClass()
			return This.IsAClass()

		def IsClassName()
			return This.IsAClass()

	  #------------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF AN ATTRIBUTE  #
	#------------------------------------------------------#

	def IsAnAttributeOfClass(pcClass)
		acTheseAttributes = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Attributes )
		bResult = This.ExistsInCS( acTheseAttributes, :CS = FALSE )
		return bResult

		def IsAnAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAnAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOfClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeInClass(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeOf(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

		def IsAttributeIn(pcClass)
			return This.IsAnAttributeOfClass(pcClass)

	  #--------------------------------------------------#
	 #  CHECKING IF THE STRING IS THE NAME OF A METHOD  #
	#--------------------------------------------------#

	def IsAMethodOfClass(pcClass)
		acTheseMethods = Stz( Q(pcClass).FirstNCharsRemeoved(3), :Methods )
		bResult = This.ExistsInCS( acTheseMethods, :CS = FALSE )
		return bResult

		def IsAMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsAMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOfClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodInClass(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodOf(pcClass)
			return This.IsAMethodOfClass(pcClass)

		def IsMethodIn(pcClass)
			return This.IsAMethodOfClass(pcClass)

	  #========================================#
	 #      CHECKING IF ALL CHARS ARE ...     #
	#========================================#

	def AllCharsAreNumbers()
		nLen = This.NumberOfChars()

		if nLen = 0 or (nLen = 1 and NOT This.FirstCharQ().IsANumber() )
			return FALSE
		ok

		bResult = TRUE
		
		for i = 1 to nLen
			if NOT This.CharQ(i).IsANumber()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		def IsMadeOfNumbers()
			return This.AllCharsAreNumbers()

	def AllCharsAre(pDescriptor)
		/* EXAMPLE

		? Q("248").AllCharsAre([ :Even, :Positive, :Numbers ])
		#--> TRUE

		? Q("248").AllCharsAre([ :Even, W('Q(@char).IsANumber()'), :Numbers ])
		#--> TRUE

		? Q(",:;").AllCharsAre(:Punctuations)

		*/

		if isString(pDescriptor)
			return This.AllCharsAreXT([ pDescriptor ], :EvalDirection = :Nothing)

		but isList(pDescriptor) and Q(pDescriptor).IsListOfStrings()
			return This.AllCharsAreXT(pDescriptor, :EvalDirection = :Nothing)

		ok	

	def AllCharsAreXT(pacDescriptors, paEvalDirection)

		if NOT ( isList(pacDescriptors) and Q(pacDescriptors).IsListOfStrings() )
			stzRaise("Incorrect param type! pacDescriptors must be a list of strings.")
		ok

		if isList(paEvalDirection) and
		   Q(paEvalDirection).IsOneOfTheseNamedParams([
			:Eval, :Evaluate,
			:EvalFrom, :EvaluateFrom,
			:EvalDirection, :EvaluationDirection
		   ])

			paEvalDirection = paEvalDirection[2]
		ok

		if NOT Q(paEvalDirection).IsOneOfTheseCS([
			:Default, :Nothing,
			:LeftToRight, :RightToLeft,
			:Left2Right, :Right2Left,
			:FromLeftToRight, :FromRightToLeft,
			:FromLeft2Right, :FromRight2Left,
			:LTR, :RTL, :L2R, :R2L,
			:FromLTR, :FromRTL, :FromL2R, :FromR2L
			], :CS = FALSE)

			stzRaise("Incorrect param value for paEvalDirection! Allowed values are :RightToLeft and :LeftToRight.")
		ok

		if Q(paEvalDirection).IsEither(:Default, :Or = :Nothing)
			paEvalDirection = :RightToLeft
		ok

		# Doing the job

		acDescriptors = pacDescriptors
		if Q(paEvalDirection).IsOneOfTheseCS([
			:RightToLeft,
			:Right2Left,
			:FromRightToLeft,
			:FromRight2Left,
			:RTL, :R2L,
			:FromRTL, :FromR2L
			], :CS = FALSE)

			acDescriptors = Q(acDescriptors).Reversed()
		ok

		if len(acDescriptors) = 1
			if acDescriptors[1] = :Number or acDescriptors[1] = :Numbers
				cMethod = :IsANumber

			but acDescriptors[1] = :String or acDescriptors[1] = :Strings
				cMethod = :IsAString

			but acDescriptors[1] = :List or acDescriptors[1] = :Lists
				Method = :IsAList

			but acDescriptors[1] = :Object or acDescriptors[1] = :Objects
				cMethod = :IsAnObject

			but Q(acDescriptors[1]).FirstChar() = "{" and
			    Q(acDescriptors[1]).LastChar() = "}"

				bResult = This.Check( :That = acDescriptors[1] )
				return bResult
			
			else

				cMethod = Q(acDescriptors[1]).InfereMethod(:From = :stzChar)

			ok

			bResult = This.Check( :That = 'StzCharQ(@char).' + cMethod + "()" )

		else

			cType = Q(acDescriptors[1]).InfereType()
			if Q(cType).StartsWithCS("stz", :CS = FALSE)
				cType = Q(cType).FirstNCharsRemoved(3)
			ok

			bResult = TRUE
	
			for i = 2 to len(acDescriptors)

 				if Q(acDescriptors[i]).FirstChar() = "{" and
			   	   Q(acDescriptors[i]).LastChar() = "}"

					bOk = This.Check( :That = acDescriptors[i] )
				
				else

					cMethod = Q(acDescriptors[i]).InfereMethod( :From = 'stz' + cType )
					bOk = This.Check( :That = 'Stz' + cType + 'Q(@item).' + cMethod + "()" )
				ok

				if bOk = FALSE
					bResult = FALSE
					exit
				ok
			next
		ok

		return bResult

	  #========================================#
	 #   CHARS VERIFYING A GIVEN CONDITION    #
	#========================================#
	
	def CharsW(pcCondition)
		aResult = This.YieldW('@char', pcCondition)
		return aResult

		def CharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsWhere(pcCondition)
			return This.CharsW(pcCondition)

		def AllCharsW(pcCondition)
			return This.CharsW(pcCondition)

		def OnlyW(pcCondition)
			return This.CharsW(pcCondition)

		# The use of Item instead of Char is required by some
		# features of natural-coding (namely the IsA() function
		# is stzChainOfTruth class
		def ItemsW(pcCondition)
			return This.CharsW(pcCondition)

		def ItemsWhere(pcCondition)
			return This.CharsW(pcCondition)

	  #-------------------------------------------------------#
	 #      NUMBER OF CHARS VERIFYING A GIVEN CONDITION      #
	#-------------------------------------------------------#

	def NumberOfCharsW(pcCondition)
		return len( This.CharsW(pcCondition) )

		#< @FunctionAlternativeForms

		def NumberOfCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def CountCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyCharWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		# Items-based naming as required for natural-coding

		def NumberOfItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def NumberOfItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemW(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemsWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		def HowManyItemWhere(pcCondition)
			return This.NumberOfCharsW(pcCondition)

		#>

	  #-----------------------#
	 #   STRING IS A CHAR?   #
	#-----------------------#

	def IsChar()
		if This.NumberOfChars() = 1
			return TRUE
		else
				
			return FALSE
		ok

		def IsAChar()
			return This.IsChar()

	def IsNullOrChar()
		return isNull(This.Content()) or This.IsChar()

		def IsCharOrNull()
			return This.IsNullOrChar()

		def IsEmptyOrChar()
			return This.IsNullOrChar()

		def IsCharOrEmpty()
			return This.IsNullOrChar()

	def IsAsciiChar()
		if This.Unicode() <= 255
			return TRUE
		else
			return FALSE
		ok

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		def IsAnAsciiChar()
			return This.IsAsciiChar()

	def IsCharName()
		return StzunicodeDataQ().ContainsCharName( This.Uppercased() )

		def IsACharName()
			return This.IsCharName()

	  #---------------------------#
	 #   STRING MADE OF CHARS?   #
	#---------------------------#

	def IsMadeOfChar(c)
		if ( NOT This.IsEmpty() ) and  StringIsChar(c)
			return This.IsMadeOf([ c ])
		else
			return FALSE
		ok

	def IsMadeOfSome(acSubstrings)
		oCopy = This.Copy()
		
		# TODO: Replace for/in with for --> better performance
		for cSubstr in acSubstrings
			if This.Contains(cSubStr)
				oCopy.RemoveAll(cSubStr)
			ok
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		return FALSE

		def IsMadeOfSomeOfThese(acSubstrings)
			return This.IsMadeOfSome(acSubstrings)

		def IsMadeOfSomeOfTheseSubstrings(acSubstrings)
			return This.IsMadeOfSome(acSubstrings)

	def IsMadeOfSomeOfTheseChars(acChars)
		if ListIsListOfChars(acChars)
			return This.IsMadeOfSome(acChars)
		else
			stzRaise("You must provide a list of chars!")
		ok

	   #------------------------------------------------#
	 #   STRING IS A CHAR IN A COMPUTABLE FORM ("c")   #
	#-------------------------------------------------#

	def IsCharInComputableForm()
		if This.IsChar() and This.IsInComputableForm()
			return TRUE
		else
			return FALSE
		ok

	def IsAsciiCharInString()
		if This.NumberOfChars() = 3 and
		   (This.IsBoundedBy("'", "'") or
		   This.IsBoundedBy('"', '"'))
			return StzStringQ(This[2]).IsAsciiChar()
		else
			return FALSE
		ok

	  #------------------#
	 #   UNIQUE CHARS   #
	#------------------#

	def UniqueCharsCS(pCaseSensitive)
		acResult = This.CharsQR(:stzListOfStrings).DuplicatesRemovedCS(pCaseSensitive)
		return acResult

		#< @FunctionFluentForms

		def UniqueCharsCSQ(pCaseSensitive)
			return This.UniqueCharsQRCS(:stzList, pCaseSensitive)

		def UniqueCharsQRCS(pcReturnTyp, pCaseSensitivee)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueCharsCS(pCaseSensitive) )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueCharsCS(pCaseSensitive) )

			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionALternativeForm

		def ToSetOfCharsCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)
	
			def ToSetOfCharsCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)
	
			def ToSetOfCharsCSQR(pcReturnType, pCaseSensitive)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)
	
		def CharsUCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsUCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsUCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)

		def CharsWithoutDuplicationCS(pCaseSensitive)
			return This.UniqueCharsCS(pCaseSensitive)

			def CharsWithoutDuplicationCSQ(pCaseSensitive)
				return This.UniqueCharsCSQ(pCaseSensitive)

			def CharsWithoutDuplicationCSQR(pCaseSensitive, pcReturnType)
				return This.UniqueCharsQRCS(pcReturnType, pCaseSensitive)

		#>

	  #-----------------------------#
	 #  REMOVING DUPLICATED CHARS  #
	#-----------------------------#

	def RemoveDuplicatedChars()
		cNewString = This.UniqueCharsQR(:stzListOfStrings).Concatenated()
		This.Update(cNewString)

		def RemoveDuplicatedCharsQ()
			This.RemoveDuplicatedChars()
			return This
	
	def DuplicatedCharsRemoved()
		cResult = This.Copy().RemoveDuplicatedCharsQ().Content()
		return cResult

	  #---------------------------------------#
	 #   GETTING CHAR AT A GIVEN POSITION    #
	#---------------------------------------#
	
	def NthChar(n)
		#< QtBased | Uses QString.mid() >

		if NOT isNumber(n)
			stzRaise("Incorrect param type! n should be a number.")
		ok

		cResult = ""
		nLen = This.NumberOfChars()

		if n = 0 or n > nLen
			return cResult
		ok

		if n < 0
			n = nLen + n + 1
		ok

		cResult = @oQString.mid(n-1, 1)
		return cResult

		#< @FunctionFluentForm
		
		def NthCharQ(n)
			return This.NthCharQR(n, :stzString)

		def NthCharQR(n, pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.NthChar(n) )
			on :stzChar
				return new stzChar( This.NthChar(n) )

			other
				stzRaise("Unsupported return type!")
			off

		#>
	
		#< @FunctionAlternativeForms

		def CharAt(n)
			return This.NthChar(n)

			def CharAtQR(n, pcReturnType)
				if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				return This.NthCharQR(n, pcReturnType)
	
			def CharAtQ(n)
				return This.CharAtQR(n, :stzString)

		def CharAtPosition(n)
			return This.NthChar(n)

			def CharAtPositionQR(n, pcReturnType)
				return This.CharAtQR(n, pcReturnType)

			def CharAtPositionQ(n)
				return This.CharAtPositionQR(n, :stzString)

		def CharN(n)
			return This.NthChar(n)

			def CharNQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharNQ(n)
				return This.CharAtQR(n, :stzString)

		def Char(n)
			return This.NthChar(n)

			def CharQR(n, pcReturnType)
				return CharAtQR(n, pcReturnType)
	
			def CharQ(n)
				return This.CharAtQR(n, :stzString)

		#>

	  #-------------------------------------------------#
	 #   NTH CHAR TO THE LAST (OR TO THE FIRST) CHAR   #
	#-------------------------------------------------#

	def NthToLast(n)
		return This.CharAtPosition( This.NumberOfChars() - n )

	def NthToFirst(n)
		return This.CharAtPosition(n + 1)

	  #--------------------------------#
	 #   CHARS AT A GIVEN POSITIONS   #
	#--------------------------------#
	
	def CharsAtPositions(panPositions)
		if NOT ( isList(panPositions) and Q(panPositions).IsListofNumbers() )
			stzRaise("Incorrect param! panPositions must be a list of numbers.")
		ok

		acResult = []

		# TODO: Replace for/in with for --> better performance
		for n in panPositions
			acResult + This.CharAt(n)
		next

		return acResult

		#< @FunctionFluentForm

		def CharsAtPositionsQ(panPosirtions)
			return This.CharsAtPositionsQR(panPositions, :stzList)

		def CharsAtPositionsQR(panPositions, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			on :stzListOfStrings
				return new stzListOfStrings( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			on :stzListOfChars
				return new stzListOfChars( This.CharsAtPositionsQR(panPositions, pcReturnType) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def CharsAtThesePositons(panPositions)
			return This.CharsAtPositions(panPositions)

			def CharsAtThesePositionsQ(panPositions)
				return This.CharsAtQR(panPositions, :stzList)

			def CharsAtThesePositionsQR(panPositions, pcReturnType)
				return This.CharsAtPositionsQR(panPositions, pcReturnType)

		def CharsAt(panPositions)
			return This.CharsAtPositions(panPositions)

			def CharsAtQ(panPositions)
				return This.CharsAtQR(panPositions, :stzList)

			def CharsAtQR(panPositions, pcReturnType)
				return This.CharsAtPositionsQR(panPositions, pcReturnType)

		#>

	  #---------------------------#
	 #   FIRST AND LAST CHARS    #
	#---------------------------#
		
	def FirstChar()
		return This[1]

		#< @FunctionFluentForm

		def FirstCharQ()
			return This.FirstCharQR(:stzString)

		def FirstCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.FirstChar() )
			on :stzChar
				return new stzChar( This.FirstChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def SecondChar()
		return This.Char(2)

		def SecondCharQ()
			return This.SecondCharQR(:stzString)

		def SecondCharQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNameSpace()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsAStzClassName() )
				StzRaise("Incorrect param type! pcReturnType must be a string containing a Softanza class name.")
			ok

			switch pcreturnType
			on :stzString
				return new stzString( This.SecondChar() )

			on :stzChar
				return new stzChar( This.SecondChar() )

			other
				StzRaise("Unsupported return type!")
			off

	def LastChar()
		return This[ This.NumberOfChars() ]

		#< @FunctionFluentForm

		def LastCharQ()
			return This.LastCharQR(:stzString)

		def LastCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LastChar() )
			on :stzChar
				return new stzChar( This.LastChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

		#< @FunctionAlternativeForms

		def _()
			return This.LastChar()

			def o_()
				return This.LastChar()
	
		def DernierCaractre()
			return This.LastChar()


		def ()
			return This.LastChar()

		#>

	  #---------------------------#
	 #   LEFT AND RIGHT CHARS    #
	#---------------------------#
		
	def LeftChar()
		if This.IsLeftToRight()
			return This.FirstChar()
		else
			return This.LastChar()
		ok

		#< @FunctionFluentForm

		def LeftCharQ()
			return This.LeftCharQR(:stzString)

		def LeftCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.LeftChar() )
			on :stzChar
				return new stzChar( This.LeftChar() )
			other
				stzRaise("Unsupported return type!")
			off

		#>

	def RightChar()
		if This.IsLeftToRight()
			return This.LastChar()
		else
			return This.FirstChar()
		ok

		#< @FunctionFluentForm

		def RightCharQ()
			return This.RightCharQR(:stzString)

		def RightCharQR(pcReturnType)
			if isList(pcReturnType) and StzListQ(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzString
				return new stzString( This.RightChar() )
			on :stzChar
				return new stzChar( This.RightChar() )
			other
				stzRaise("Unsupported return type!")
			off
	
		#>

	  #-----------------------#
	 #   NUMBER OF CHARS     #
	#-----------------------#

	/* TODO
	Reimplement these functions using QTextBoundaryFinder
	https://doc.qt.io/qt-5/qtextboundaryfinder.html#details
	*/

	def NumberOfCharsCS(pCaseSensitive)
		#< QtBased | Uses QString.count() >

		# Resolving pCaseSensitive

		if isList(pCaseSensitive) and Q(pCaseSensitive).IsCaseSensitiveNamedParam()
			pCaseSensitive = pCaseSensitive[2]
		ok

		if isString(pCaseSensitive)
			if Q(pCaseSensitive).IsOneOfThese([
				:CaseSensitive, :IsCaseSensitive , :CS, :IsCS ])

				pCaseSensitive = TRUE
			
			but Q(pCaseSensitive).IsOneOfThese([
				:CaseInSensitive, :NotCaseSensitive, :NotCS,
				:IsCaseInSensitive, :IsNotCaseSensitive, :IsNotCS ])

				pCaseSensitive = FALSE
			ok

		ok

		if NOT IsBoolean(pCaseSensitive)
			stzRaise("Error in param value! pCaseSensitive must be 0 or 1 (TRUE or FALSE).")
		ok

		# Doing the job

		if pCaseSensitive = TRUE
			return @oQString.count()

		else
			return len( This.UniqueChars() )
		ok

		#< @FunctionFluentForm

		def NumberOfCharsCSQ(pCaseSensitive)
			return new stzNumber(This.NumberOfCharsCS(pCaseSensitive))

		#>

		#< @FunctionAlternativeForms

		def SizeCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def SizeInCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def NumberOfItemsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def LengthCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def CountCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def HowManyCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		def HowManyCharCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def NuberOfCharsCS(pCaseSensitive)
			return This.NumberOfCharsCS(pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumberOfChars()
		return This.NumberOfCharsCS(:CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumberOfCharsQ()
			return new stzNumber(This.NumberOfChars())

		#>

		#< @FunctionAlternativeForms

		def Size()
			return This.NumberOfChars()

		def SizeInChars()
			return This.NumberOfChars()

		def LengthInChars()
			return This.NumberOfBytes()


		def NumberOfItems()
			return This.NumberOfChars()

		def Length()
			return This.NumberOfChars()

		def CountChars()
			return This.NumberOfChars()

		def HowManyChars()
			return This.NumberOfChars()

		def HowManyChar()
			return This.NumberOfChars()

		#>

		#< @FunctionMisspelledForm

		def NuberOfChars()
			return This.NumberOfChars()

		#>

	  #-----------------------#
	 #   NUMBER OF LETTERS   #
	#-----------------------#

	def NumberOfLetters()
		return len(This.OnlyLetters())
	
		#< @FunctionAlternativeForms

		def CountLetters()
			return This.NumberOfLetters()

		def HowManyLetters()
			return This.NumberOfLetters()

		def HowManyLetter()
			return This.NumberOfLetters()

		#>

	  #-----------------------#
	 #   NUMBER OF SPACES    #
	#-----------------------#

	def NumberOfSpaces()
		return len(This.FindAll(" "))

		#< @FunctionAlternativeForms

		def CountSpaces()
			return This.NumberOfSpaces()

		def HowManySpaces()
			return This.NumberOfSpaces()

		def HowManySpace()
			return This.NumberOfSpaces()

		#>

	  #---------------------------------------#
	 #   CHEKING IF THE STRING IS A LETTER   #
	#---------------------------------------#

	def IsLetter()
		if This.IsChar() and StzCharQ(This.Content()).IsLetter()
			return TRUE
		else
			return FALSE
		ok
		
		#< @FunctionAlternativeForms

		def IsALetter()
			return This.IsLetter()

		def ContainsJustALetter()
			return This.IsLetter()

		def ContainsOnlyALetter()
			return This.IsLetter()

		#>

		#< @FunctionNegativeForm

		def IsNotLetter()
			return NOT This.IsLetter()

		def IsNotALetter()
			return NOT This.IsLetter()

		#>

	  #----------------------------------------------------------#
	 #   CHEKING IF THE STRING IS A LETTER OF AN OTHER STRING   #
	#----------------------------------------------------------#

	def IsLetterOf(pcOtherStr)
		if This.IsLetter() and Q(pcOtherStr).ContainsLetter(This.Content())
			return TRUE
		else
			return FALSE
		ok

		def IsALetterOf(pcOtherStr)
			return This.IsLetterOf(pcOtherStr)

	  #-----------------------------------------------#
	 #   GETTING THE LIST OF LETTERS IN THE STRING   #
	#-----------------------------------------------#

	def Letters()
		aoChars = This.CharsQ().ToListOfStzStrings()
		nLen = len(acChars)
		aResult = []
		
		for i = 1 to nLen
			if aoChars[i].IsALetter()
				aResult + aoChars[i].Content()
			ok
		next

		return aResult

		def LettersQ()
			return This.LettersQR(:stzList)

		def LettersQR(pcReturnType)

			switch pcReturnType
			on :stzList
				return new stzList( This.Letters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.Letters() )

			on :stzListOfChars
				return new stzListOfChars( This.Letters() )
			off

	  #----------------------------------------------------------------------#
	 #   GETTING THE LIST OF LETTERS IN THE STRING  -- WITHOUT DUPLICATION  #
	#----------------------------------------------------------------------#

	def UniqueLetters()
		acResult = This.LettersQ().DuplicatesRemoved()
		return acResult

		#< @FunctionFluentForms

		def UniqueLettersQ()
			return This.UniqueLettersQR(:stzList)

		def UniqueLettersQR(pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.UniqueLetters() )

			on :stzListOfStrings
				return new stzListOfStrings( This.UniqueLetters() )

			on :stzListOfChars
				return new stzListOfChars( This.UniqueLetters() )
			off

		#>

		#< @FunctionAlternativeForms

		def LettersU()
			return This.UniqueLetters()

			def LettersUQ()
				return This.LettersUQR(:stzList)

			def LettersUQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
	
		def LettersWithoutDuplication()
			return This.UniqueLetters()

			def LettersWithoutDuplicationQ()
				return This.LettersWithoutDuplicationQR(:stzList)

			def LettersWithoutDuplicationQR(pcReturnType)
				return This.UniqueLettersQR(pcReturnType)
		#

	  #----------------------------------------------------------------------#
	 #    CHECKING IF THE STRING IS IN A COMPUTABLE FORM ("str" or 'str')   #
	#----------------------------------------------------------------------#

	def IsInComputableForm()
		if This.NumberOfChars() > 2 and
		   (This.IsBoundedBy("'", "'") or
		    This.IsBoundedBy('"', '"'))

			return TRUE
		else
			return FALSE
		ok
	
		def IsWellFormed()
			return This.IsInComputableForm()

	  #------------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN SUBSTRINGS   #
	#------------------------------------------------------------#

	def IsMadeOfCS(acSubStr, pCaseSensitive)
		IF NOT ( isList(acSubStr) and Q(acSubStr).IsListOfStrings() )
			StzRaise("Incorrect param type! acSubStr must be a list of strings.")
		ok

		oCopy = This.Copy()
		
		nLen = len(acSubStr)

		for i = 1 to nLen
			if NOT This.ContainsCS(acSubStr[i], pCaseSensitive)
				return FALSE
			ok

			oCopy.RemoveAllCS(cSubStr, pCaseSensitive)
		next

		if oCopy.IsEmpty()
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def IsMadeOfTheseCS(acSubStr, pCaseSensitive)
			return This.IsMadeOfCS(acSubStr, pCaseSensitive)

		def IsMadeOfTheseSubstringsCS(acSubStr, pCaseSensitive)
			This.IsMadeOfCS(acSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOf(acSubStr)
		return This.IsMadeOfCS(acSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def IsMadeOfThese(acSubStr)
			return This.IsMadeOf(acSubStr)

		def IsMadeOfTheseSubstrings(acSubStr)
			This.IsMadeOf(acSubStr)

		#>

	  #-------------------------------------------------------#
	 #   CHECKING IF THE STRING IS MADE OF THE GIVEN CHARS   #
	#-------------------------------------------------------#

	def IsMadeOfTheseCharsCS(acChars, pCaseSensitive)
		if ListIsListOfChars(acChars)
			return This.IsMadeOfCS(acChars, pCaseSensitive)
		else
			stzRaise("You must provide a list of chars!")
		ok

	#-- WITHOUT CASESENSITIVITY

	def IsMadeOfTheseChars(acChars)
		return This.IsMadeOfTheseCharsCS(acChars, :CaseSensitive = TRUE)

	  #---------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF LETTERS  #
	#---------------------------------------------#

	def IsMadeOfLetters()
		bResult = TRUE

		for i = 1 to This.NumberOfChars()
			if This.CharQ(i).IsNotALetter()
				bResult = FALSE
				exit
			ok
		next

		return bResult

	  #-----------------------------------------------#
	 #   CHEKCIKNG IF THE STRING IS MADE OF SPACES   #
	#-----------------------------------------------#
	
	def IsMadeOfSpaces()
		if This.NumberOfSpaces() = This.NumberOfChars()
			return TRUE
		else
			return FALSE
		ok

		def IsBlank()
			return This.IsMadeOfSpaces()

	  #-----------------#
	 #   MULTIPLY BY   #	TODO: reclassify it with other calculations
	#-----------------#

	def Multiply(paByValue)
		if isList(paByValue) and Q(paByValue).IsByNamedParam()
			paByValue = paByValue[2]
		ok

		This.MultiplyBy(paByValue)

	def MultiplyBy(pValue)
		cResult = NULL

		if ring_type(pValue) = "NUMBER"
			cResult = This.RepeatedNTimes(pValue)
		
		but ring_type(pValue) = "STRING"

			if pValue = NULL { return NULL }

			cResult = NULL
			cTemp = NULL

			for i = 1 to This.NumberOfChars()
				cTemp = @oQString.mid(i-1,1) + pValue
				cResult += cTemp
			next
		
		but ring_type(pValue) = "LIST"
			aValue = pValue // just for expressivity
			cResult = ""
			cTemp = ""
				
			for i = 1 to This.NumberOfChars()
				for v = 1 to len(aValue)
					cTemp = @oQString.mid(i-1,1) + aValue[v]
					cResult += cTemp 
				next
										
				if i != NumberOfChars() // avoiding adding space at the end
					cResult += " "
				ok
			next
		ok

		This.Update( cResult )

		#< @FunctionFluentForm

		def MultiplyByQ(pValue)
			This.MultiplyBy(pValue)
			return This

		#>

	  #========================================#
	 #     BOXING THE STRING AND ITS CHARS    #
	#========================================#
	
	def Box() # Undersatnd it as a verb action on the string (boxing the string)

		return This.BoxXT([])

		#< @FunctionFluentForm

		def BoxQ()
			return new stzString( This.Box() )
		#>

		def Boxed()
			return This.BoxQ().Content()

	def BoxDashed()
		return This.BoxXT([ :Line = :Dashed ])

		#< @FunctionFluentForm

		def BoxDashedQ()
			return new stzString( This.BoxDashed() )
		#>

		def BoxedDashed()
			return This.BoxDashedQ().Content()

	def BoxRound()
		return This.BoxXT([ :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundQ()
			return new stzString( This.BoxRound() )
		#>

		def BoxedRound()
			return This.BoxRoundQ().Content()

	def BoxRoundDashed()
		return This.BoxXT([ :Line = :Dashed, :AllCorners = :Round ])

		#< @FunctionFluentForm

		def BoxRoundDashedQ()
			return new stzString( This.BoxRoundDashed() )
		#>

		def BoxedRoundDashed()
			return This.BoxRoundDashedQ().Content()

	def BoxDashedRound()
		return This.BoxRoundDashed()

		#< @FunctionFluentForm

		def BoxDashedRoundQ()
			return new stzString( This.BoxDashedRound() )
		#>

		def BoxedDashedRound()
			return This.BoxDashedRoundQ().Content()

	def BoxEachChar()
		return This.BoxXT([ :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharQ()
			return new stzString( This.BoxEachChar() )
		#>

		def EachCharBoxed()
			return This.BoxEachCharQ().Content()

	def BoxEachCharRound()
		return This.BoxXT( [ :AllCorners = :Round, :EachChar = TRUE ])

		#< @FunctionFluentForm

		def BoxEachCharRoundQ()
			return new stzString( This.BoxEachCharRound() )
		#>

		def EachCharboxedRound()
			return This.BoxEachCharRoundQ().Content()

	def BoxEachCharXT(paBoxOptions)
		if StzHashListQ(paBoxOptions).ContainsKey( :EachChar )
			paBoxOptions = StzHashListQ(paBoxOptions).UpdateValueByKeyQ( :EachChar, TRUE ).Content()
		else
			paBoxOptions = StzHashListQ(paBoxOptions).AddPairQ( :EachChar = TRUE ).Content()
		ok

		return This.BoxedXT(paBoxOptions)

		#< @FunctionFluentForm

		def BoxEachCharXTQ(paBoxOptions)
			return new stzString( This.BoxedEachCharXT(paBoxOptions) )

		#>

		def EachCharBoxedXT(paBoxOptions)
			return This.BoxEachCharXTQ(paBoxOptions).Content()

	def BoxXT(paBoxOptions)

		/*
		Example:

		? StzStringQ("TEXT1").BoxXT([

			:Line = :Thin,	# or :Dashed
		
			:AllCorners = :Round, # can also be :Rectangualr
			# :Corners = [ :Round, :Rectangular, :Round, :Rectangular ],
		
			:TextAdjustedTo = :Center # or :Left or :Right or :Justified

		]).Content()

		--> Gives:
		
		     TEXT1      
		

		The list of possible options, as you find inforced in
		stzList.IsTextBoxedOptionsNamedParam(), are:

			aListOfBoxOptions = [
				# General options
				:Line,
				:AllCorners,
				:Corners,
				:Width,
				:TextAdjustedTo,

				# Options speciefic to list of chars and words
				:EachChar,
				:EachWord,
				:Hilighted,
				:HilightedIf,
				:Numbered
			]

		*/

		if StzListQ(paBoxOptions).IsTextBoxedOptionsNamedParam()

			# Reading the type of line (thin or dashed)

			cLine = :Thin # By default

			if paBoxOptions[ :Line ] = :Dashed
				cLine = :Dashed
			ok

			# Reading the type of corners (rectangualr or round)

			cAllCorners = :Rectangular # By default

			if paBoxOptions[ :AllCorners ] = :Round
				cAllCorners = :Round
			ok

			aCorners = []
			if cAllCorners = :Rectangular
				 # By default
				aCorners = [ :Rectangular, :Rectangular, :Rectangular, :Rectangular ]

			but cAllCorners = :Round
				aCorners = [ :Round, :Round, :Round, :Round ]

			ok

			if len(paBoxOptions[:Corners]) = 4 and
			   StzListQ( paBoxOptions[:Corners] ).IsMadeOfSome([ :Rectangular, :Round ])
	
				aCorners = paBoxOptions[:Corners]

			ok

			# If the boxing happens at the char level, delegate it
			# to the stzListOfChars class

			if paBoxOptions[ :EachChar ] = TRUE

				return StzListOfCharsQ( This.String() ).BoxedXT(paBoxOptions)
			ok

			# If the boxing happens at the word level, delegate it
			# to the stzListOfStrings class

			if paBoxOptions[ :EachWord ] = TRUE
				return This.ToListOfStringsQ().Boxed(paBoxOptions)
			ok

			# Reading the width of the box in number of chars

			nWidth = This.NumberOfChars() + 2 # By default

			if isNumber(paBoxOptions[:Width]) and
			   paBoxOptions[:Width] > This.NumberOfChars() + 2

				nWidth = paBoxOptions[:Width]
			ok

			# Reading the text adjustment option

			cTextAdjustedTo = :Center # By default

			oString = new stzString( paBoxOptions[ :TextAdjustedTo ] )
			if oString.IsOneOfThese([ :Left, :Center, :Right, :Justified ])

				cTextAdjustedTo = paBoxOptions[ :TextAdjustedTo ]
			ok
 
			# Composing the box

			cVTrait  = ""

			cHTrait  = ""

			if cLine = :Dashed
				cHTrait = ""
				cVTrait = ""
			ok
			
			
			cCorner1 = ""
			cCorner2 = ""
			cCorner3 = ""
			cCorner4 = ""

			if  aCorners[1] = :Round
				cCorner1 = ""
			ok

			if aCorners[2] = :Round
				cCorner2 = ""
			ok

			if aCorners[3] = :Round
				cCorner3 = ""
			ok

			if aCorners[4] = :Round
				cCorner4 = ""
			ok

			cUpLine = cCorner1 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner2 

			
			cMidLine = cVTrait + " " +
				   This.AlignXTQ(nWidth - 2, " ", cTextAdjustedTo).Content() +
				   " " +
				   cVTrait

			cDownLine = cCorner4 +
				  StzStringQ(cHTrait).RepeatedNTimes(nWidth) +
				  cCorner3 

			return cUpLine + NL + cMidLine + NL + cDownLine

		but isList(paBoxOptions) and len(paBoxOptions) = 0
			# Do nothing, takes default options for boxing

		else
			stzRaise(stzStringError(:CanNotBoxTheString))
		ok

		#< @FunctionFluentForm

		def BoxedXTQ(paBoxOptions)
			return new stzString( This.BoxXT(paBoxOptions) )

		#>

		def BoxedXT(paBoxOptions)
			return This.BoxXT(paBoxOptions)

	  #=================================================#
	 #   STRING EXISTENCE AS AN ITEM IN A GIVEN LIST   #
	#=================================================#

	def ExistsInListCS(paList, pCaseSensitive)

		if NOT isList(paList)
			stzRaise("Incorrect param! paList must be a list.")
		ok

		bResult = FALSE
		nLen = len(paList)

		for i = 1 to nLen
			item = paList[i]
			if isString(item) and Q(item).IsEqualToCS( This.String(), pCaseSensitive )
				bResult = TRUE
				exit
			ok
		next

		return bResult

		def ExistsAsItemInListCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheseCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

		def IsOneOfTheCS(paList, pCaseSensitive)
			return This.ExistsInListCS(paList, pCaseSensitive)

	#--

	def ExistsInList(paList)
		return This.ExistsInListCS(paList, :CaseSensitive = TRUE)

		def ExistsAsItemInList(paList)
			return This.ExistsInList(paList)

		def IsOneOfThese(paList)
			return This.ExistsInList(paList)

		def IsOneOf(paList)
			return This.ExistsInList(paList)

		def IsOneOfThe(paList)
			return This.ExistsInList(paList)

	  #====================================================#
	 #  CHECHKING IF THE STRING IS EQUAL TO VAL1 OR VAL2  #
	#====================================================#
	// TODO: Add same function to other classes

	def IsEitherCS(pcStr1, pcStr2, pCaseSensitive)
		if isList(pcStr2) and Q(pcStr2).IsOrNamedParam()
			pcStr2 = pcStr2[2]
		ok

		return This.IsOneOfTheseCS([ pcStr1, pcStr2], pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def IsEither(pcStr1, pcStr2)
		return This.IsEitherCS(pcStr1, pcStr2, :CaseSensitive = TRUE)

	  #=============================================#
	 #  MOVING CHAR AT POSITION N1 TO POSITION N2  #
	#=============================================#
	# TODO: Should be generalized to move hole substrings not only chars

	def Move(n1, n2)

		# Checking params correctness

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedParams([
			:From, :FromPosition,
			:At, :AtPosition,
			:Char, :CharAt, :CharAtPosition,
			:FromCharAt, :FromCharAtPosition,
			:CharFrom, :CharFromPosition
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedParams([
				:To, :ToChar, :ToPosition, :ToPositionOfChar,
				:ToCharAt, :ToCharAtPosition ])

			n2 = n2[2]
		ok

		if isString(n1) and
		   Q(n1).IsOneOfThese([ :First, :FirstPosition, :FirstChar ])
				    
			n1 = 1
		ok

		if isString(n2) and
		   Q(n1).IsOneOfThese([ :Last, :LastPosition, :LastChar ])

			n2 = This.NumberOfItems()
		ok

		if NOT BothAreNumbers(n1, n2)
			stzRaise("Incorrect param type! n1 and n2 must be numbers.")
		ok

		# Doing the job
		
		if n1 > n2
		# . . . 2 . . 1 . .
		#       ^     |
		#       |_____|

			cTempChar = This[n1]
			This.RemoveCharAtPosition(n1)
			This.InsertBefore(n2, cTempChar)

		but n1 < n2
		# . . . 1 . . 2 . .
		#       |     ^
		#       |_____|

			cTempChar = This[n1]

			if n2 = This.NumberOfItems()
				This.AddChar(cTempChar)
			else
				This.InSertAfter(n2, cTempChar)
			ok

			This.RemoveCharAt(n1)
		ok

		#< @FunctionAlternativeForm

		def MoveChar(n1, n2)
			This.Move(n1, n2)

		#>

	  #=========================================#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def Swap(n1, n2)
		if BothAreStrings(n1, n2)
			This.SwapSubStrings(n1, n2)
			return
		ok

		if isList(n1) and
		   Q(n1).IsOneOfTheseNamedPArams([
			:Between, :BetweenPosition, :BetweenPositions,
			:BetweenChar, :BetweenChars,
			:BetweenCharAt, :BetweenCharAtPosition, :BetweenCharAtPositions,
			:Position, :Positions, :CharAt, :CharAtPosition, :CharAtPositions,
			:CharsAt, :CharsAtPosition, :CharAtPositions
		   ])

			n1 = n1[2]
		ok

		if isList(n2) and
		   Q(n2).IsOneOfTheseNamedPArams([
			:And, :AndPosition, :AndCharAt, :AndCharAtPosition, :AndChar ])

			n2 = n2[2]
		ok

		copy = This[n2]
		This.ReplaceCharAtPosition(n2, :By = This[n1])
		This.ReplaceCharAtPosition(n1, :By = copy)

		#< @FunctionFluentForm

		def SwapQ(n1, n2)
			This.Swap(n1, n2)
			return This

		#>

		#< @FunctionAlternativeForms

		def SwapBetween(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenQ(n1, n2)
				This.SwapBetween(n1, n2)
				return This

		def SwapBetweenPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapBetweenPositionsQ(n1, n2)
				This.SwapBetweenPositions(n1, n2)
				return This

		def SwapItems(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition, :AtPositions ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([ :And, :AndPosition ])
				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapItemsQ(n1, n2)
				This.SwapItems(n1, n2)
				return This

		def SwapChar(n1, n2)
			if isList(n1) and
			   Q(n1).IsOneOfTheseNamedParams([ :At, :AtPosition ])
				n1 = n1[2]
			ok
	
			if isList(n2) and
			   Q(n2).IsOneOfTheseNamedParams([
				:And, :AndPosition, :AndCharAt, :AndCharAtPosition ])

				n2 = n2[2]
			ok
	
			This.Swap(n1, n2)

			def SwapCharQ(n1, n2)
				This.SwapChar(n1, n2)
				return This

		def SwapChars(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsQ(n1, n2)
				This.SwapChars(n1, n2)
				return This

		def SwapCharsAtPositions(n1, n2)
			This.Swap(n1, n2)

			def SwapCharsAtPositionsQ(n1, n2)
				This.SwapCharsAtPositions(n1, n2)
				return This

		#>

	  #-----------------------------------------#
	 #  SWAPPING CHARS AT TWO GIVEN POSITIONS  #
	#=========================================#

	def SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		/* EXAMPLE

		o1 = new stzString("TWO, ONE, THREE!")
		o1.SwapSubStrings("TWO", "ONE")

		? o1.Content()
		#--> ONE, TWO, THREE!

		*/

		if isList(pcSubStr2) and Q(pcSubStr2).IsOneOfThese([ :And, :With, :By ])
			pcSubStr2 = pcSubStr2[2]
		ok

		if NOT This.ContainsBothCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			StzRaisr("Incorrect param types! Both pcSubStr1 and pcSubStr2 must be strings.")
		ok

		# NOTE: if the string contains more then one occurrence form a substring,
		# then only the first occurence is considered

		aSectionSubStr1 = This.FindAsSectionsCS(pcSubStr1, pCaseSensitive)[1]
		aSectionSubStr2 = This.FindAsSectionsCS(pcSubStr2, pCaseSensitive)[1]

		This.ReplaceSection(aSectionSubStr1[1], aSectionSubStr1[2], pcSubStr2)
		This.ReplaceSection(aSectionSubStr2[1], aSectionSubStr2[2], pcSubStr1)

		def SwapSubStringsCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			This.SwapSubStringsCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def SwapSubStrings(pcSubStr1, pcSubStr2)
		This.SwapSubStringsCS(pcSubStr1, pcSubStr2, :CaseSensitive = TRUE)

		def SwapSubStringsQ(pcSubStr1, pcSubStr2)
			This.SwapSubStrings(pcSubStr1, pcSubStr2)
			return This

	  #==================================#
	 #   REVERSING THE ORDER OF CHARS   #
	#==================================#

	def ReverseCharsOrder()
		cInversed = ""
		nLen = This.NumberOfChars()
		acReversed = []

		for i = nLen to 1 step -1
			cInversed += This.@oQString.mid(i-1, 1)
		next

		This.Update( cInversed )

		#< @FunctionFluentForm

		def ReverseCharsOrderQ()
			This.ReverseCharsOrder()
			return This
	
		#>

		#< @FunctionAlternativeForm

		def Reverse() # To stay consistent with Ring that has reverse() function
			This.ReversecharsOrder()

			def ReverseQ()
				This.Reverse()
				return This

		def ReverseChars()
			This.ReversecharsOrder()

			def ReverseCharsQ()
				This.ReverseChars()
				return This

		def ReverseOrder()
			This.ReversecharsOrder()

			def ReverseOrderQ()
				This.ReverseOrder()
				return This

		#>

	def CharsOrderReversed()
		cResult = This.Copy().ReverseCharsOrderQ().Content()
		return cResult


		#< @FunctionAlternativeForm

		def Reversed()
			return This.CharsOrderReversed()

		def CharsReversed()
			return This.CharsOrderReversed()

		def OrderReversed()
			return This.CharsOrderReversed()

		#>

	  #-----------------------------------------------------------#
	 #   INVERTING CHARS OF THE STRING (IF POSSIBLE IN UNICODE)  #
	#-----------------------------------------------------------#

	# Inverting (or turning) chars and strings
	# NOTE: In the meantime, Softanza uses Invert()
	# and Turn() as alternatives, but this should
	# change in the future to cope with their exact
	# meaning in Unicode!

	# NOTE: This is different from REVERSE() that Softanza
	# uses conforming to its Ring meaning (reversing the order
	# of the chars). See examples below to see how...

	def Invert()
		/*
		Example:
		? StzStringQ("LIFE").Turned()
		#--> I
		*/

		# NOTE: Applies to latin script only

		if NOT This.ToStzText().ScriptIs(:Latin)
			return This.String()
		ok

		cResult = ""

		for i = 1 to This.NumberOfChars()
			cResult += StzCharQ( This.NthChar(i) ).Inverted()
		next

		This.Update( cResult )

		#< @FunctionFluentForm

		def InvertQ()
			This.Invert()
			return This

		def InvertChars()
			This.Invert()

			def InvertCharsQ()
				This.InvertChars()
				return This
		#>

		#< @FunctionAlternativeForm

		def Turn()
			This.Invert()

			def TurnQ()
				This.Turn()
				return This

		def TurnChars()
			This.Invert()

			def TurnCharsQ()
				This.TurnChars()
				return This

		#>

	def Inverted()
		return This.Copy().InvertQ().Content()

		#< @FunctionAlternativeForms

		def CharsInverted()
			return This.Inverted()

		def Turned()
			return This.Inverted()

		def CharsTurned()
			return This.Inverted()

		#>

	  #-------------------------------------------------------------#
	 #  CHECKING IF THE STRING IS MADE OF INVERTED (TURNED) CHARS  #
	#-------------------------------------------------------------#

	def IsInverted()
		bResult = TRUE

		for c in This.String()
			if NOT StzCharQ(c).IsInverted()
				bResult = FALSE
				exit
			ok
		next

		return bResult

		#< @FunctionAlternativeForms

		def CharsAreInverted()
			return This.IsInverted()

		def IsTurned()
			return This.IsInverted()

		def CharsAreturned()
			return This.IsInverted()

		#>

	  #========================#
	 #   HASHING THE STRING   #
	#========================#
	
	# Currently we use the native hashing functions of Ring StdLib
	# TODO: other algortithms can be added through RingQt

	def Hash(pcHashingAlgo)
		if isList(pcHashingAlgo) and Q(pcHashingAlgo).IsWithOrUsingOrByNamedParam()
			pcHashingAlgo = pcHashingAlgo[2]
		ok

		if NOT isString(pcHashingAlgo)
			StzRaise("Incorrect param type! pcHashingAlgo must be a string.")
		ok

		if NOT Q(pcHashingAlgo).IsOneOfThese([ :MD5, :SHA1, :SHA256, :SHA512, :SHA384, :SHA224 ])
			StzRaise("Unsupported hashing algorithm! Allowed values are :MD5, :SHA1, :SHA256, :SHA512, :SHA384 and :SHA224.")
		ok

		cHashed = ""

		switch pcHashingAlgo

		on :MD5
			cHashed = md5( This.String() )

		on :SHA1
			cHashed = sha1( This.String() )

		on :SHA256
			cHashed = sha256( This.String() )

		on :SHA512
			cHashed = sha512( This.String() )

		on :SHA384
			cHashed = sha384( This.String() )

		on :SHA224
			cHashed = sha224( This.String() )

		other
			stzRaise("syntax error or unsupported hashing algorithm!")
		off

		This.Update( cHashed )

		#< @FunctionFluidVersion

		def HashQ(pcHashingAlgo)
			return new stzString( This.Hash(pcHashingAlgo) )

		#>

		#< @FunctionAlternativeForms

		def HashWithAlgo(pcHashingAlgo)
			return This.Hash(pcHashingAlgo)

			def HashWithAlgoQ(pcHashingAlgo)
				return new stzString( This.HashWithAlgo(pcHashingAlgo) )
		#>

	def HashWithMD5()
		This.Hash(:MD5)

		def HashWithMD5Q()
			This.HashWithMD5()
			return This

	def HashWithSHA1()
		This.Hash(:SHA1)

		def HashWithSHA1Q()
			This.HashWithSHA1()
			return This

	def HashWithSHA256()
		This.Hash(:SHA256)

		def HashWithSHA256Q()
			This.HashWithSHA256()
			return This

	def HashWithSHA384()
		This.Hash(:SHA384)

		def HashWithSHA384Q()
			This.HashWithSHA384()
			return This

	def HashWithSHA224()
		This.Hash(:SHA224)

		def HashWithSHA224Q()
			This.HashWithSHA224()
			return This

	  #------------------------------------------#
	 #   ENCRYPTING AND DECRYPTING THE STRING   #
	#------------------------------------------#
	
	# Encrypts the string using the blowfish algorithm:
	#--> returns what's called a cipher in a binary string

	#--> TODO: - what the cIV param means?
	# 	    - check: key must be between 4 and 56 bytes long 

	def EncryptWithBlowfish(cSecretKey, cIV)
		cEncrypted = encrypt( This.String(), cSecretKey, cIV)
		This.Update( cEncrypted )

		#< @FunctionAlternativeForms

		def EncryptWithBlowfishQ(cSecretKey, cIV)
			return new stzListOfBytes( This.EncryptWithBlowfish(cSecretKey, cIV) )

		#>

	# Updates the string from a cipher encrypted with the blowfish algorithm
	#--> cCypher should be in binary form (list of bytes)
	def FromDecryptedWithBlowfish(cCypher, cSecret, cIV)
		This.Update( decrypt(cCypher, cSecret, cIV) )

		#< @FunctionAlternativeForms

		def FromBlowfishCipher(cCypher, cSecret, cIV)
			This.FromDecryptedWithBlowfish(cCypher, cSecret, cIV)

		#>

	  #==============================#
	 #   GETTING TEXT FROM A URL    #
	#==============================#

	def UpdateFromURL(cURL)
		This.Update( download(cURL) )

		def UpdateFromURLQ(cURL)
			This.UpdateFromURLL(cURL)
			return This

		def FromURL(cURL)
			This.UpdateFromURL(cURL)

			def FromURLQ(cURL)
				This.FromURL(cURL)
				return This

	def UpdatedFromURL(cURL)
		cResult = This.Copy().UpdateFromURLQ(cURL).Content()
		return cResult

	  #====================================================#
	 #     WALKING THE STRING AND RETURNING SOMETHING     #
	#====================================================#
	// TODO: use stzWalker?

	def WalkXT(paOptions)

		if NOT ( isList(paOptions) and Q(paOptions).IsHashList() )

			stzRaise("Incorrect param! paOptions must be a hashlist.")
		ok

		if NOT ( len(paOptions) = 0 or

			  StzHashListQ(paOptions).
			  KeysQR(:stzListOfStrings).IsMadeOfSomeCS([
				:From, :FromPosition, :To, :ToPosition, :Step, :Return
			  ], :CS = FALSE) )

			stzRaise("Incorrect value!")
		ok

		oKeys = StzHashListQ(paOptions).KeysQR(:stzListOfStrings)

		if oKeys.ContainsBothCS(:From, :FromPosition, :CS = FALSE)
			stzRaise("Incorrect value! paOptions must not contain both :From and :FromPosition keys.")
		ok

		if oKeys.ContainsBothCS(:To, :ToPosition, :CS = FALSE)
			stzRaise("Incorrect value! paOptions must not contain both :To and :ToPosition keys.")
		ok

		if oKeys.ContainsCS(:From, :CS = FALSE)
			n = StzHashListQ(paOptions).FindKey(:From)
			paOptions[n][1] = :FromPosition
		ok

		if oKeys.ContainsCS(:To, :CS = FALSE)
			n = StzHashListQ(paOptions).FindKey(:To)
			paOptions[n][1] = :ToPosition
		ok

		pnFromPosition = 1
		if paOptions[ :FromPosition ] != NULL
			pnFromPosition = paOptions[ :FromPosition ]
		ok

		pnToPosition = This.NumberOfChars()
		if paOptions[ :ToPosition ] != NULL
			pnToPosition = paOptions[ :ToPosition ]
		ok

		if isString(pnFromPosition) and
		   Q(pnFromPosition).IsOneOfTheseCS([ :First, :FirstChar ], :CS = FALSE)
	
			pnFromPosition = 1

		ok

		if isString(pnToPosition) and
		   Q(pnToPosition).IsOneOfTheseCS([ :Last, :LastChar ], :CS = FALSE)

				pnFromPosition = This.NumberOfChars()
		ok

		pnStep = 1
		if paOptions[ :Step ] != NULL
			pnstep = paOptions[ :Step ]
		ok

		pcReturn = :WalkedPositions
		if paOptions[ :Return ] != NULL
			pcReturn = paOptions[ :Return ]
		ok

		# Doing the job

		anPositions = []
		acChars = []

		for i = pnFromPosition to pnToPosition step pnStep
			anPositions + i
			acChars + This.Char(i)
		next

		aResult = []


		if pcReturn = :WalkedPositions
			aResult = anPositions

		but pcReturn = :WalkedChars
			aResult = acChars
		ok

		return aResult

	def Walk( pnFromPosition, pnToPosition, pnStep, pcReturn )
		return This.WalkXT([ pnFromPosition, pnToPosition, pnStep, pcReturn ])

	  #--------------------------------------------#
	 #   WALKING STARTING FROM N UNTIL CHAR IS    # TODO: Redo with stzWalker
	#--------------------------------------------#

	def WalkBackwardW( paStartingAt, pcCondition )
		/*
		str = "Ring Programming Languge"
		StzStringQ(str).WalkBackwardW( :StartingAt = 12, :Until = '{ @char = " " }' )

		--> Returns 5
		*/

		cResult = ""
		bStopWalking = FALSE
		nCurrentPosition = paStartingAt[2] + 1

		while NOT bStopWalking

			nCurrentPosition--
			if nCurrentPosition = 1
				exit
			ok

			@char = This[ nCurrentPosition ]
			@i = nCurrentPosition

			cCondition = StzStringQ(pcCondition[2]).TrimQ().
					RemoveTheseBoundsQ("{","}").Content()

			cCode = "if " + cCondition + NL +
				TAB + "exit" + NL +
			"ok"

			eval(cCode)
		end

		return nCurrentPosition

	def WalkUntil(pcCondition)
		return This.WalkForeward(:StartingAt = 1, :Until = pcCondition)

	def WalkForewardW( paStartingAt, pcCondition )
		/*
		str = "Ring Programming Languge"
		StzStringQ(str).WalkForewardW( :StartingAt = 6, :UntilBefore = '{ @char = "r" }' )

		--> Returns 9
		*/

		cResult = ""
		bStopWalking = FALSE
		nCurrentPosition = paStartingAt[2] + 1

		while NOT bStopWalking
			nCurrentPosition++
			if nCurrentPosition = This.NumberOfChars()
				exit
			ok

			@char = This[ nCurrentPosition ]
			@i = nCurrentPosition

			cCondition = StzStringQ(pcCondition[2]).
				     TrimQ().RemoveTheseBoundsQ("{", "}").Content()

			cCode = "if " + cCondition + NL +
				TAB + "exit" + NL +
			"ok"

			eval(cCode)			
		end

		if nCurrentPosition = This.NumberOfChars()
			nResult = 0
		else
			nResult = nCurrentPosition-1
		ok

		return nResult

	  #=================================#
	 #  REPEATING THE STRING N TIMES   #
	#=================================#

	def RepeatNTimes(n)
		/* NOTE

		This method exists already in the parent stzObject.
		Here we make it specific to strings.

		In fact, Q("Hi!").RepeatNTimes(3) when applied to
		the string "Hi!" will update it to become "Hi!Hi!Hi!".

		In all other types (stzList, stzNumber, and stzObject)
		Q(5).RepeatNTimes(3) will produce the list [5, 5, 5],
		and Q(1:3).RepeatNTimes(3) will produce the list
		[ 1:3, 1:3, 1:3 ].

		You may ask why we opted for a different behavior for
		strings compared to other types?

		Well, because I think it's more obvious to update the
		string when we ask to repeat it, and have a string as a
		result not a list!

		If you want to avoid any confusion due to this choice,
		use RproduceIn() instead, and specify explicitly what
		you hant to have, like this:

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InString)
		#--> "Hi!Hi:Hi!

		? Q("Hi!").ReproducedXT( :NTimes = 3, :InList)
		"--> [ "Hi!", "Hi!", "Hi!" ]

		*/

		cResult = ""
		for i = 1 to n
			cResult += This.Content()
		next
		This.Update( cResult )

		#< @FunctionFluentForms

		def RepeatNTimesQ(n)
			This.RepeatNTimes(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def Repeat(n)
			This.RepeatNTimes(n)

			def RepeatQ(n)
				This.Repeat(n)
				return This

		#>


	# RETURNING THE OUTPUT DATA

	def RepeatedNTimes(n)
		return This.Copy().RepeatNTimesQ(n).Content()

		def Repeated(n)
			return This.RepeatedNTimes(n)

	  #====================================================#
	 #     COMPRESSING THE STRING WITH A BINARY SCHEMA    #
	#====================================================#

	// Example : ABCDEFGH > 10011011 => ADEGH
	def CompressUsingBinary(cBinary)

		oBinary = new stzString(cBinary)
		if NOT oBinary.IsMadeOf(["0", "1"])
			stzRaise(stzStringError(:CanNotCompressStringUsingBinary))
		ok

		cCompressed = ""
		nLenBinary = len(cBinary)
		nLen = This.NumberOfChars()

		for i = 1 to nLenBinary
			if cBinary[i] = "1" and i <= nLen					
				cCompressed += This.Char(i)
			ok
		next
			
		if nLen > nLenBinary
			for i = NLenBinary + 1 to nLen
				cCompressed += This.CHar(i) 
			next
		ok

		This.Update( cCompressed )

		#< @FunctionFluentForm

		def CompressUsingBinaryQ(cBinary)
			This.CompressUsingBinary(cBinary)
			return This

		#>

	  #=================================#
	 #    CHECKING A LIST IN STRING    #
	#=================================#

	def IsListInString()
		/* EXAMPLES
	
		o1 = new stzString('[ "A","B", "C", "D" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "A":"D" ')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString('[ "", "", "" ]')
		? o1.IsListInString() #--> TRUE
		
		o1 = new stzString(' "":"": ')
		? o1.IsListInString() #--> TRUE
		*/

		oCopy = This.RemoveSpacesQ().RemoveTheseBoundsQ( "{", "}" ).

		# A list can not be written with less then 2 chars

		if oCopy.NumberOfChars() < 2
			return FALSE
		ok

		bResult = FALSE

		# Case 1 : The list is in normal [_,_,_] form

		if oCopy.IsBoundedBy([ "[","]" ]) and
			oCopy.Contains(",")

			cCode = "aTempList = " + oCopy.Content()
			eval(cCode)

			bResult = isList(aTempList)

		else

		# Case 2 : The list is in short _:_ form

			if oCopy.ContainsOneOccurrence(":")

				# the : separator in _:_ can not be at the
				# beginning or the end of the list in string

				n = oCopy.FindFirst(":")
				if NOT ( n > 1 and n < oCopy.NumberOfChars() )

					bResult = FALSE

				ok

				# The list is in short form, let's analyze it
				# and tranform it to a normal syntax
	
				aListMembers = QStringListToList( oCopy.QStringObject().split( ":", 0, 0 ) )
				# NOTE: could be written { aListMembers = oCopy.Split( :Using = ":" ) } atfer
				# terminating Split() funtion in Softanza.

				cMember1 = aListMembers[1]
				cMember2 = aListMembers[2]

				cCode = "pMember1 = " + cMember1

				eval(cCode)
	
				cCode = "pMember2 = " + cMember2
				eval(cCode)
	
				cNormalSyntax = "[ "
	
				if ( isString(pMember1) and StringIsChar(pMember1) ) and
				   ( isString(pMember2) and StringIsChar(pMember2) )
					
					n1 = CharUnicode(pMember1)
					n2 = CharUnicode(pMember2)
		
					if n1 <= n2
						for n = n1 to n2
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2
						for n = n1 to n2 step -1
							cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
							if n > n2
								cNormalSyntax += ", "
							ok
						next
					ok
		
					cNormalSyntax += " ]"
	
				but isNumber(pMember1) and isNumber(pMember2)

					n1 = pMember1
					n2 = pMember2
		
					if n1 <= n2

						for n = n1 to n2
							cNormalSyntax += (""+ n)
							if n < n2
								cNormalSyntax += ", "
							ok
						next
		
					but n1 > n2

						for n = n1 to n2 stzp -1
							cNormalSyntax += (""+ n)
							if n > n2
								cNormalSyntax += ", "
							ok
						next
		
					ok
		
				ok

				if Q(cNormalSyntax).LastChar() != "]"
					cNormalSyntax += " ]"
				ok

				cCode = "aTempList = " + cNormalSyntax

				eval(cCode)

				bResult = isList(aTempList)

			ok  
		ok

		return bResult

	def IsListInNormalForm()
		if NOT This.IsListInString()
			return FALSE
		ok

		if This.TrimQ().IsBoundedBy([ "[","]" ])
			return TRUE
		else
			return FALSE
		ok

	def IsListInShortForm()
		if This.IsListInString() and
		  ( NOT This.IsListInNormalForm() )

			return TRUE
		else
			return FALSE
		ok

	  #--------------------------------------------#
	 #    CHECKING A CONTIGUOUS LIST IN STRING    #
	#--------------------------------------------#

	def IsContiguousListInString()

		cCode = "aTempList = " + This.ToListInNormalForm()
		eval(cCode)
		bResult = StzListQ(aTempList).IsContiguous()

		return bResult

		def IsContinuousListInString()
			return This.IsContiguousListInString()

	def IsContiguousListInNormalForm()
	
		if This.IsContiguousListInString() and
		   This.IsListInNormalForm()
		  
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInNormalForm()
			return This.IsContiguousListInNormalForm()

	def IsContiguousListInShortForm()

		if This.IsContiguousListInString() and
		   This.IsListInShortForm()
		   
			return TRUE
		else
			return FALSE
		ok

		def IsContinuousListInShortForm()
			return This.IsContiguousListInShortForm()

	  #----------------------------------------------------------------#
	 #   CPNVERTING CONTINUOUS LISTS BETWEEN NORMAL AND SHORT FORMS   #
	#----------------------------------------------------------------#

	def ToListInShortForm()
	
		if NOT This.IsContiguousListInString()
			stzRaise([
				:Where = "stzString > ToListInShortForm()",
				:What  = "Can't convert the list in string to short form!",
				:Why   = "The list in string is not contiguous list."
			])
		ok

		cResult = ""

		if This.IsListInShortForm()
			cResult  =  This.Copy().
					RemoveSpacesQ().
					ReplaceQ(":", " : ").
					Content()

		but This.IsListInNormalForm()

			cCode = "aTempList = " + This.String()
			eval(cCode)

			if StzListQ(aTempList).IsContiguous()

				This.TrimQ().RemoveTheseBoundsQ( "[","]" )
				acMembers = QStringObject().split(",", 0, 0)
				acMembers = QStringListToList(acMembers)
				acMembers = StzListQ(acMembers).FirstAndLastItems()

				/*
				TODO : replace with this when Split() is finished.

				acMembers = This.TrimQ().
						RemoveTheeBoundsQ("[","]").
						SplitQ(",").
						FirstAndLastItems()
				*/

						
				cMember1 = StzStringQ(acMembers[1]).Simplified()
				cMember2 = StzStringQ(acMembers[len(acMembers)]).Simplified()

				cResult = cMember1 + ":" + cMember2

			else
				cResult = This.Simplified()
			ok
		ok

		return cResult

		def ToListInShortFormQ()
			return new stzString( This.ToListInShortForm() )

		def ToListInStringInShortForm()
			return This.ToListInShortForm()

			def ToListInStringInShortFormQ()
				return new stzString( This.ToListInStringInShortForm() )

	def ToListInNormalForm()

		If NOT This.IsListInString()
			stzRaise([
				:Where = "stzString > ToListInNormalForm()",
				:What  = "Can't convert the string to short form list!",
				:Why   = "The string is not a list in string."
			])
		ok

		if This.IsListInNormalForm()
			cResult = This.Simplified()

		but This.IsListInShortForm()

			# The list is in short form, let's analyze it
			# and tranform it to a normal syntax

			aListMembers = QStringListToList( This.QStringObject().split( ":", 0, 0 ) )
			# NOTE: could be written { aListMembers = This.Split( :Using = ":" ) } atfer
			# terminating Split() funtion in Softanza.
					
			cMember1 = aListMembers[1]
			cMember2 = aListMembers[2]

			cCode = "pMember1 = " + cMember1
			eval(cCode)
		
			cCode = "pMember2 = " + cMember2
			eval(cCode)
	
			cNormalSyntax = "[ "
	
			if ( isString(pMember1) and StringIsChar(pMember1) ) and
			   ( isString(pMember2) and StringIsChar(pMember2) )
						
				n1 = CharUnicode(pMember1)
				n2 = CharUnicode(pMember2)
		
				if n1 <= n2
					for n = n1 to n2
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2
					for n = n1 to n2 step -1
						cNormalSyntax += '"' + StzCharQ(n).Content() + '"'
						if n > n2
							cNormalSyntax += ", "
						ok
					next
				ok
		
				cNormalSyntax += " ]"
		
			but isNumber(pMember1) and isNumber(pMember2)

				n1 = pMember1
				n2 = pMember2
		
				if n1 <= n2

					for n = n1 to n2
						cNormalSyntax += (""+ n)
						if n < n2
							cNormalSyntax += ", "
						ok
					next
		
				but n1 > n2

					for n = n1 to n2 stzp -1
						cNormalSyntax += (""+ n)
						if n > n2
							cNormalSyntax += ", "
						ok
					next
		
				ok
		
				cNormalSyntax += " ]"
			ok

			cResult = cNormalSyntax

		ok  

		return cResult

		def ToListInNormalFormQ()
			return new stzString( This.ToListInNormalForm() )

		def ToListInStringInNormalForm()
			return This.ToListInNormalForm()

			def ToListInStringInNormalFormQ()
				return new stzString( This.ToListInStringInNormalForm() )

	def ToListInString()
		return This.ToListInNormalForm()

		def ToListInStringQ()
			return new stzString( This.ToListInString() )

	def ToListInStringSF()
		return This.ToListInShortForm()

		def ToListInStringSFQ()
			return new stzString( This.ToListInStringSF() )

	def ToList()
		/*
		NOTE: Currently, it works only for a case like this:
		Q("#1 : #3").ToList() and gives [ "#1", "#2", "#3" ]

		but not for this:
		Q("#12 : #23") --> more then 1 digit

		TODO: Generalise it!
		*/

		This.TrimQ().RemoveTheseBounds("{", "}")

		# Case where we have a normal list syntax

		if This.TrimQ().IsBoundedBy([ "[", "]" ])
			cCode = "aResult = " + This.Content()
			eval(cCode)
			return aResult
		ok

		# Case where we have a continuous list syntax:
		#  ? StzStringQ(' "Thing 1" : "Thing 3" ').ToList()

		cPart = NULL

		cPart1 = NULL
		cLastChar1 = NULL

		cPart2 = NULL
		cLastChar2 = NULL

		oThisWS = This.ReplaceManyQ([": ", " :"], " : ").SimplifyQ()
		
		if oThisWS.NumberOfOccurrence(":") = 1 and oThisWS.MiddleChar() = ":"

			aListMembers = QStringListToList( QStringObject().split(":", 0, 0) )
			oMember1 = StzStringQ(aListMembers[1]).TrimQ()
			oMember2 = StzStringQ(aListMembers[2]).TrimQ()

			cMember1 = oMember1.Content()
			cMember2 = oMember2.Content()

			if BothAreNumbersInStrings(cMember1, cMember2)
				cLastChar1 = cMember1
				cLastChar2 = cMember2

			but BothAreCharsInComputableForm(cMember1, cMember2)
				cLastChar1 = cMember1
				cLastChar2 = cMember2

			but BothAreStringsInComputableForm(cMember1, cMember2)

				c1 = '"'
				c2 = "'"

				oMember1.RemoveManyQ([c1, c2])
				oMember2.RemoveManyQ([c1, c2])

				cLastChar1 = oMember1.LastChar()
				cLastChar2 = oMember2.LastChar()
	
				nLenMember1 = oMember1.NumberOfChars()
				
				if nLenMember1 > 1
					cPart1 = oMember1.Section(1, nLenMember1 - 1)
				ok
	
				nLenMember2 = oMember2.NumberOfChars()
	
				if nLenMember2 > 1
					cPart2 = oMember2.Section(1, nLenMember2 - 1)
				ok

				if ( cPart1 = NULL     or cPart2 = NULL ) and
				   ( cLastChar1 = NULL or cLastChar2 = NULL )

					stzRaise("Syntax error! parts must not be null.")
				ok

				if cPart1 != cPart2
					stzRaise("Syntax error! The two parts must be the same.")
				ok
	
				cPart = cPart1
			else

				stzRaise("Syntax error! Can't transoform the string into list.")
			ok

		else

			stzRaise("Syntax error! Can't transoform the string into list.")

		ok
		
		# Composing the contiguous list for cLastChar1 to cLastChar2
	
		oString = StzStringQ( cLastChar1 + " : " + cLastChar2 )

		cCode = "aList = " + oString.ToListInNormalForm()
		eval(cCode)
	
		# Adding the other parts
	
		if cPart != NULL
			for item in aList
				item = cPart + item
			next
		ok

		return aList

		def ToListQ()
			return new stzList( This.ToList() )
		
  	  #==========================================================#
	 #   CHECKING IF ALL THE STRINGS VERIFY A GIVEN CONDITION   #
	#==========================================================#

	def CheckW(pcCondition)
		if isList(pcCondition) and Q(pcCondition).IsWithNamedParam()
			pcCondition = pcCondition[2]
		ok

		pcCondition = StzCCodeQ(pcCondition).Transpiled()
		return This.CharsQ().CheckW(pcCondition)

		#< @FunctionAlternativeForms

		def Check(pcCondition)
			return This.CheckW(pcCondition)

		def Verify(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringVerify(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringItemVerifyW(pcCondition)
			return This.CheckW(pcCondition)

		def EachStringItemVerify(pcCondition)
			return This.CheckW(pcCondition)

		#>

	  #-------------------------------------------------------------------#
	 #   CHECKING IF STRINGS AT GIVEN POSITIONS VERIFY A GIVEN CONDITION   #
	#-------------------------------------------------------------------#

	def CheckOnW(panPositions, pcCondition)

		return This.CharsQ().CheckOnW(panPositions, pcCondition)

		#< @FunctionAlternativeForms

		def VerifyOnW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOn(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyOn(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnPositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifiyOnPositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnThesePositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyThesePositionsW(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def CheckOnPositions(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)

		def VerifyOnPositions(panPositions, pcCondition)
			return This.CheckOnW(panPositions, pcCondition)
		#>

	  #------------------------------------------------------------------#
	 #   CHECKING IF STRINGS AT GIVEN SECTIONS VERIFY A GIVEN CONDITION   #
	#------------------------------------------------------------------#

	def CheckOnSectionsW(paSections, pcCondition)
		return This.CharsQ().CheckOnSectionsW(paSections, pcCondition)

		#< @FunctionAlternativeForm

		def VerifyOnSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSectionsW(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def CheckOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		def VerifyOnTheseSections(paSections, pcCondition)
			return This.CheckOnSectionsW(paSections, pcCondition)

		#>

	  #=========================================#
	 #   YIELDING INFORMATION FROM EACH CHAR   #
	#=========================================#

	def Yield(pcCode)
		return This.CharsQ().YieldFrom( 1:This.NumberOfChars(), pcCode )

		#< @FunctionFluentForm

		def YieldQ(pcCode)
			return This.YieldQR(pcCode, :stzList)
	
		def YieldQR(pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Yield(pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.Yield(pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.Yield(pcCode) )

			on :stzHashList
				return new stzHashList( This.Yield(pcCode) )
		
		other
				stzRaise("Unsupported return type!")
		off

		#>

		#< @FunctionAlternativeForms

		def YieldFromEachChar(pcCode)
			return This.Yield(pcCode)

			def YieldFromEachCharQ(pcCode)
				return This.YieldFromEachCharQR(pcCode, :stzList)
		
			def YieldFromEachCharQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromEachChar(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromEachChar(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromEachChar(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromEachChar(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def Harvest(pcCode)
			return This.Yield(pcCode)

			def HervestQ(pcCode)
				return This.YieldFromEachCharQR(pcCode, :stzList)
		
			def HarvestQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.Harvest(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.Harvest(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.Harvest(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.Harvest(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def HarvestFromEachChar(pcCode)
			return This.Yield(pcCode)

			def HarvestFromEachCharQ(pcCode)
				return This.HarvestFromEachCharQR(pcCode, :stzList)
		
			def HarvestFromEachCharQR(pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromEachChar(pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromEachChar(pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromEachChar(pcCode) )
	
				on :stzHashList
					return new stzHashList( This.HarvestFromEachChar(pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off
		#>

	  #--------------------------------------------------------#
	 #   YIELDING INFORMATION FROM CHARS AT GIVEN POSITIONS   #
	#--------------------------------------------------------#

	def YieldFrom(panPositions, pcCode)
		return This.CharsQ().YieldFrom(panPositions, pcCode)

		#< @FunctionFluentForm

		def YieldFromQ(paPositions, pcCode)
			return This.YieldFromQR(paPositions, pcCode, :stzList)
	
		def YieldFromQR(paPositions, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
				pcReturnType = pcReturnType[2]
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFrom(paPositions, pcCode) )
	
			on :stzListOfStrings
				return new stzListOfStrings( This.YieldFrom(paPositions, pcCode) )
				
			on :stzListOfNumbers
				return new stzListOfNumbers( This.YieldFrom(paPositions, pcCode) )
		
			other
				stzRaise("Unsupported return type!")
			off

		#>

		#< @FunctionAlternativeForms

		def YieldFromPositions(panPositions, pcCode)
			return This.YieldFrom(panPositions, pcCode)

			def YieldFromPositionsQ(paPositions, pcCode)
				return This.YieldFromPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def YieldFromCharsAt(panPositions, pcCode)
			return This.YieldFrom(panPositions, pcCode)

			def YieldFromCharsAtQ(paPositions, pcCode)
				return This.YieldFromCharsAtQR(paPositions, pcCode, :stzList)
		
			def YieldFromCharsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromCharsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromCharsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromCharsAt(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def YieldFromCharsAtPositions(panPositions, pcCode)
			return This.YieldOn(panPositions, pcCode)

			def YieldFromCharsAtPositionsQ(paPositions, pcCode)
				return This.YieldFromCharsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def YieldFromCharsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldFromCharsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldFromCharsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldFromCharsAtPositions(paPositions, pcCode) )
	
				on :stzHashList
					return new stzHashList( This.YieldFromCharsAtPositions(paPositions, pcCode) )
			
			other
					stzRaise("Unsupported return type!")
			off

		def HarvestFromPositions(panPositions, pcCode)
			return This.HarvestFrom(panPositions, pcCode)

			def HarvestFromPositionsQ(paPositions, pcCode)
				return This.HarvestFromPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def HarvestFromCharsAt(panPositions, pcCode)
			return This.HarvestFrom(panPositions, pcCode)

			def HarvestFromCharsAtQ(paPositions, pcCode)
				return This.HarvestFromCharsAtQR(paPositions, pcCode, :stzList)
		
			def HarvestFromCharsAtQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromCharsAt(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromCharsAt(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromCharsAt(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off

		def HarvestFromCharsAtPositions(panPositions, pcCode)
			return This.HarvestOn(panPositions, pcCode)

			def HarvestFromCharsAtPositionsQ(paPositions, pcCode)
				return This.HarvestFromCharsAtPositionsQR(paPositions, pcCode, :stzList)
		
			def HarvestFromCharsAtPositionsQR(paPositions, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.HarvestFromCharsAtPositions(paPositions, pcCode) )
	
				other
					stzRaise("Unsupported return type!")
				off
		#>

	  #------------------------------------------------------#
	 #   YIELDING INFORMATION ON CHARS IN GIVEN SECTIONS    #
	#------------------------------------------------------#

	def YieldFromSections(paSections, pcCode)
		return This.CharsQ().YieldFromSections(paSections, pcCode)

		#< @FunctionFluentForm

		def YieldFromSectionsQ(paSections, pcCode)
			return new stzList( This.YieldFromSections(paSections, pcCode) )

		def YieldSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsQ(paSections, pcCode)
				return This.HarvestFromSections(paSections, pcCode, :stzList)

			def HarvestFromSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSections(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
	
		def HarvestSections(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsQ(paSections, pcCode)
				return This.HarvestSections(paSections, pcCode, :stzList)

			def HarvestSectionsQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSections(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSections(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
		#>

	def YieldFromSectionsOneByOne(paSections, pcCode)

		if NOT ( isList(paSections) and Q(paSections).IsListOfPairsOfNumbers() )

			stzRaise("Incorrect param! paSections must be a list of pairs of numbers.")
		ok

		aResult = []

		anSectionsExpanded = []
		for aSection in paSections
			anSectionsExpanded + Q(aSection).ExpandedIfPairOfNumbers()
		next

		for anPositions in anSectionsExpanded
			aResult + This.YieldFromPositions(anPositions, pcCode)
		next

		return aResult

		#< @FunctionFluentForm

		def YieldFromSectionsOneByOneQ(paSections, pcCode)
			return This.YieldFromSectionsOneByOneQR(paSections, pcCode, :stzList)

		def YieldFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				stzRaise("Incorrect param! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			on :stzListOfLists
				return new stzListOfLists( This.YieldFromSectionsOneByOneQ(paSections, pcCode) )

			other
				stzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForms

		def HarvestFromSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestFromSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestFromSectionsOneByOne(paSections, pcCode, :stzList)

			def HarvestFromSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestFromSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestFromSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off
				
		def HarvestSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def HarvestSectionsOneByOneQ(paSections, pcCode)
				return This.HarvestSectionsOneByOne(paSections, pcCode, :stzList)

			def HarvestSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off

		def YieldSectionsOneByOne(paSections, pcCode)
			return This.YieldFromSections(paSections, pcCode)

			def YieldSectionsOneByOneQ(paSections, pcCode)
				return This.YieldSectionsOneByOne(paSections, pcCode, :stzList)

			def YieldSectionsOneByOneQR(paSections, pcCode, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsReturnedTypeNamedParam()
					pcReturnType = pcReturnType[2]
				ok
	
				if NOT isString(pcReturnType)
					stzRaise("Incorrect param! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.YieldSectionsOneByOne(paSections, pcCode) )

				on :stzListOfLists
					return new stzListOfLists( This.YieldSectionsOneByOne(paSections, pcCode) )
	
				other
					stzRaise("Unsupported param type!")
				off

		#>

	  #----------------------------------------------------------------#
	 #   YIELDING INFORMATION ON ITEMS VERIFYiNG A GIVEN CONDITION    #
	#----------------------------------------------------------------#

	def YieldW(pcCode, pcCondition)

		if isList(pcCondition) and Q(pcCondition).IsWhereNamedParam()
			pcCondition = pcCondition[2]
		ok

		if NOT isString(pcCondition)
			StzRaise("Incorrect param type! pcCondition must be a string.")
		ok

		oCode = new stzString(pcCode)
		if oCode.ContainsCS("@substring", :CS = FALSE)
			aTempList = This.SubStrings()

		else
			aTempList = This.Chars()
		ok

		pcCode = Q(pcCode).ReplaceCSQ("@char", "This[@i]", :CS=FALSE).Content()
		pcCondition = Q(pcCondition).ReplaceCSQ("@char", "This[@i]", :CS=FALSE).Content()

		acResult = Q(aTempList).YieldW(pcCode, pcCondition)
		return acResult

		#< @FunctionFluentForm

		def YieldWQ(pcCode, pcCondition)
				return This.YieldWQR(paPositions, pcCode, :stzList)
		
			def YieldWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok
	
				switch pcReturnType
				on :stzList
					return new stzList( This.YieldW(pcCode, pcCondition) )
		
				on :stzListOfStrings
					return new stzListOfStrings( This.YieldW(pcCode, pcCondition) )
					
				on :stzListOfNumbers
					return new stzListOfNumbers( This.YieldW(pcCode, pcCondition) )
	
				on :stzHashList
					return new stzHashList( This.YieldW(pcCode, pcCondition) )
			
			other
					stzRaise("Unsupported return type!")
			off

		#>

		#> @FunctionAlternativeForm

		def HarvestW(pcCode, pcCondition)
			return This.YieldW(pcCode, pcCondition)

			def HervestWQ(pcCode, pcCondition)
				return This.HarvestWQR(pcCode, pcCondition, :stzList)

			def HervestWQR(pcCode, pcCondition, pcReturnType)
				if isList(pcReturnType) and Q(pcReturnType).IsOneOfTheseNamedParams([ :ReturnedAs, :ReturnAs ])
					pcReturnType = pcReturnType[2]
				ok

				if NOT isString(pcReturnType)
					stzRaise("IncorrectType! pcReturnType must be a string.")
				ok

				switch pcReturnType
				on :stzList
					return new stzList( This.HarvestW(pcCode, pcCondition) )

				on :stzListOfLists
					return new stzListOfLists( This.HarvestW(pcCode, pcCondition) )

				other
					stzRaise("Unsupported return type!")
				off

		#>

	  #=======================================#
	 #   PERFORMING AN ACTION ON EACH CHAR   #
	#=======================================#

	def Perform(pcCode)
		# Must begin with '@char ='

		This.UpdateWith(
			This.CharsQ().
			PerformQ(pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformQ(pcCode)
			This.Perform(pcCode)
			return This

	  #----------------------------------------------------#
	 #   PERFORMING ACTIONS ON CHARS IN GIVEN POSITIONS   #
	#----------------------------------------------------#

	def PerformOn(panPositions, pcCode)

		This.UpdateWith(
			This.CharsQ().
			PerformOnQ(panPositions, pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformOnQ(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)
			return This

		def PerformOnPositions(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)

			def PerformOnPositionsQ(panPositions, pcCode)
				This.PerformOnPositions(panPositions, pcCode)
				return This

		def PerformOnThesePositions(panPositions, pcCode)
			This.PerformOn(panPositions, pcCode)

			def PerformOnThesePositionsQ(panPositions, pcCode)
				This.PerformOnThesePositions(panPositions, pcCode)
				return This

	  #------------------------------------------------------#
	 #   PERFORMING AN ACTION ON CHARS IN GIVEN SECTIONS    #
	#------------------------------------------------------#

	def PerformOnSections(paSections, pcCode)

		This.UpdateWith(
			This.CharsQ().
			PerformOnSectionsQ(paSections, pcCode).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def PerformOnSectionsQ(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)
			return This

		def PerformOnTheseSections(paSections, pcCode)
			This.PerformOnSections(paSections, pcCode)

			def PerformOnTheseSectionsQ(paSections, pcCode)
				This.PerformOnTheseSections(paSections, pcCode)
				return This

	  #---------------------------------------------------------------#
	 #   PERFORMING AN ACTION ON CHARS VERIFYING A GIVEN CONDITION   #
	#---------------------------------------------------------------#

	def PerformW(pcAction, pcCondition)

		This.UpdateWith(
			This.CharsQ().
			PerformWQ(pcAction, pcCondition).
			ToStzListOfStrings().
			Concatenated()
		)

		#--

		def DoW(pcAction, pcCondition) # TODO: Generalize in other classes
			This.PerformW(pcAction, pcCondition)

		def PerformWQ(paParams)
			This.PerformW(paParams)
			return This

			def DoWQ(paParams)
				This.PerformWQ(paParams)

	  #============================#
	 #  OPERATORS OVERLOADING     #
	#============================#

	# TODO: Operators should carry same semantics in all classes...

	def operator(pOp,pValue)

		// string access : str[n]
		// string search : str[substr]

		if pOp = "[]"
			
			if isString(pValue)
				if pValue = :First or pValue = :FirsChar
					pValue = 1

				but pValue = :Last or pValue = :LastChar
					pValue = This.NumberOfChars()
				ok
			ok

			if isNumber(pValue)

				return This.NthChar(pValue)
							
			but isString(pValue)
				if StzStringQ(pValue).TrimQ().IsBoundedBy(["{","}"])
					pcCondition = StzStringQ(pValue).TrimQ().BoundsRemoved(["{","}"])
					anResult = []

					@char = ""
					nLen = This.NumberOfChars()

					for @i = 1 to nLen
						@char = This.Char(@i)
						cCode = 'bOk = ( ' + pcCondition + ' )'

						eval(cCode)
						if bOk
							anResult + @i
						ok
					next

					return anResult
				else
					return This.FindAll(pValue)
				ok	
			ok
				// Add an item at the beginning of the list
		but pOp = "<<"
			This.Prepend(1)

		// Add an item at the end of the list
		but pOp = ">>"
			This.Append(value)

		// compare equality : oString = str

		but pOp = "="
			return This.IsEqualTo(pValue)

		// oString < str

		but pOp = "<"
			return This.IsSmallerThan(pValue)
		
		// compare : oString > str

		but pOp = ">"
			return This.IsLargerThan(pValue)
	
		// add : string + string | string + ListOfStrings

		but pOp = "+"
			if ring_type(pValue) = "STRING"
				This.Append(pValue)
				return This
		
			but StzListQ(pValue).IsListOfStrings()
				This.InsertSubstrings(pValue)
				return This	
			ok

		// Multiply: string * n | string * string | string * list
	
		but pOp = "*"
			This.MultiplyBy(pValue)
			return This

		// Split: String / n  | String / str	| String / list

		but pOp = "/"

			if isString(pValue)
				if Q(pValue).IsBoundedBy([ "{", "}" ])

					acSplitted = This.SplitW(pValue)

				else
					acSplitted = This.Split(pValue)
				ok

				return acSplitted

			but isNumber(pValue)
				return This.SplitToNParts(pValue)

			but isList(pValue) and Q(pValue).IsListOfNumbers()
				acSplitted = This.SplitAtPositions(pValue)
				return acSplitted

			but isList(pValue) and Q(pValue).IsPairOfStrings() and
			    pValue[1] = :where and Q(pValue[2]).IsBoundedBy([ "{" , "}" ])

				acSplitted = This.SplitW(pValue[2])
				return acSplitted
			
			but isList(pValue) and Q(pValue).IsListOfSrtrings() # NOTE this is misspelled!
				/* EXAMPLE
				? @@( Q("RingRubyJava") / [ "Qute", "Nice", "Good" ] )
				#--> [ [ "Qute", "Ring" ], [ "Nice", "Ruby" ], [ "Good", "Java" ] ]	
				*/

				nLen = len(pValue)
				acSplitted = This.SplitToNParts(nLen)
				aResult = Association([ pValue, acSplitted ])
				return aResult

			but isList(pValue) and Q(pValue).IsHashList()

				oHashList = new stzHashList(pValue)

				# All the values except the last one must be numbers

				aValuesExceptLast = oHashList.ValuesQ().LastItemRemoved()

				if NOT Q(aValuesExceptLast).IsListOfNumbers()
					stzRaise("Incorrect values! All the values except the last, must be numbers.")
				ok

				# The last value can be a number or a string equal to :Remaining or :RemainingChars

				if NOT 	( isNumber(oHashList.LastValue()) or

					  ( isString(oHashList.LastValue()) and
					    Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ])
					  )
					)

					stzRaise("Incorrect value! The last value mus tbe a number or a string (:Remaining or :RemainingChars).")
				ok

				# If the last value is :Remaining or :RemainingChars, the its replace by the n remaining chars

				if isString(oHashList.LastValue()) and
				   Q(oHashList.LastValue()).IsOneOfThese([ :Remaining, :RemainingChars ])

					
					n = 0
					for i = 1 to len(aValuesExceptLast)
						n += aValuesExceptLast[i]
					next

					nRemainingChars = This.NumberOfChars() - n

					pValue[ len(pValue) ][2] = nRemainingChars
				ok

				# The sum of shares must be equal to the number of chars
				
				if NOT StzHashListQ(pValue).ValuesQR(:stzListOfNumbers).Sum() = This.NumberOfChars()
					stzRaise("Incorrect values! The sum of numbers must be equal to the number of chars!")
				ok

				# Making the share of the string based on the values provided

				aResult = []
				n = 1
				for aPair in pValue
					
					cShare = This.Range(n, aPair[2])
					n += aPair[2]

					aResult + [ aPair[1], cShare  ]
				next

			ok

			return aResult
					
		// String % n : returns the rest of letters after dividing String / n

		but pOp = "%"
			cResult = NULL

			if ring_type(pValue) = "NUMBER"	
				aParts = []
		
				nParts = ceil( This.NumberOfChars() / pValue )
				for i=1 to This.NumberOfChars() step nParts
					cTemp = @oQString.mid(i-1, nParts)
					aParts + cTemp	
				next
		
				if len(aParts) < pValue
					for i = len(aParts) to pValue-1
						aParts + "_"
					next
				ok
		
				if aParts[ len(aParts) ] != "_"
					return aParts[ len(aParts) ]
				ok
			ok

			return cResult
		
		// string - string | string - .25 | string - 3
		but pOp = "-"
			cResult = NULL
						
			if isString(pValue)
				This.RemoveAllQ(pValue)
				return This
			ok
		
			if isNumber(pValue)
				if pValue < This.NumberOfChars()
					if pValue > 0 and pValue < 1 // str - 0.5
						// Eats a portion of the string (half: 0.5, quarter0.25,...)
						n = floor( This.NumberOfChars() * pValue)
						cResult = This.Section( 1, This.NumberOfChars() - n ) // @oQString.mid(0,nLenStr-n)
					else
						cResult = This.Section(1, This.NumberOfChars() - pValue )
					ok		
				ok

				This.Update( cResult )
				return This
				# TODO/NOTE: In stzList, the "-" operator returns This.Content()
				#--> Hormonize the behaviour of all the operators in all classes!
			ok

			if StzListQ(pValue).IsListOfStrings()
				for item in pValue
					This.RemoveAll(item)
				next
				return This
			ok

			if StzListQ(pValue).IsListOfLists() and len(pValue) = 1
				/*
				Example:

				o1 = new stzString("XRingorialand")
				o1 - [[ :FirstCharIf, :EqualTo, :X ]]

				Gives -> "Ringorialand"

				NB: We use the two brackets here to differenciate
				the syntax with:

					 o1 - [ "X", "oria", "land" ] --> "Ring"

				which means : remove this ist of substrings from
				the main string
				*/

				aListOfConditions = [
					:EqualTo, :LesserThan, :GreaterThan,
					:LesserThanOrEqual, :GreaterThanOrEqual,
					:DifferentThan ]

				cFirstOrLast = pValue[1][1]
		 		cCondition = pValue[1][2]
				value = pValue[1][3]

				oCondition = new stzString(cCondition)

				if NOT ( len(pValue[1]) = 3 AND
				   (cFirstOrLast = :FirstCharIf or cFirstOrLast = :LastCharIf) AND
				   oCondition.ExistsInList(aListOfConditions) AND
				   isString(value) )

					stzRaise(stzStringError(:UnsupportedExpressionInOverloadedMinusOperator))
				ok
					
				if cFirstOrLast = :FirstCharIf

					if cCondition = :EqualTo
						if Q(pValue).IsNumberOrString()
							if This.FirstChar() = pValue
								This.RemoveFirstChar()
								return This
							ok
						ok

						if StzListQ(pValue).IsListOfStrings()
							oList = pValue
							if oList.IsEqualTo(cFirstOrLast)
								This.RemoveMany(pValue)
								return This
							ok
						ok

					but cCondition = :LesserThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :LesserOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					
					but cCondition = :DifferentThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					ok

				but cFirstOrLast = :LastCharIf

					if cCondition = :EqualTo
						if StringIsChar(pValue) and This.LastChar() = pValue
							This.RemoveNthChar(This.NumberOfChars())
							return This
						ok

						if ListIsListOfChars(pValue)
							oList = pValue
							if value.IsEqualTo(cFirstOrLast)
								This.RemoveMany(pValue)
								return This
							ok
							
						ok

					but cCondition = :LesserThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :LesserOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)

					but cCondition = :GreaterOrEqualThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					
					but cCondition = :DifferentThan
						stzRaise(:UnsupportedFeatureInThisVersion)
					ok

				ok

			ok
		ok // --- End of operator overloading section


	  #=====================================================#
	 #  METHODS USED FOR CAMPATIBILITY WITH EXTERNAL CODE  #
	#=====================================================#

	def join(pacItems) # Python
		/* EXAMPLE

		In Python: ' + '.join([ "a", "b", "c" ])
		#--> a + b + c

		# In Ring, with Softanza:

		? Q(' + ').join([ "a", "b", "c" ])
		#--> a + b + c

		*/

		if NOT ( isList(pacItems) and Q(pacItems).IsListOfStrings() )
			StzRaise("Incorrect param type! pacItems must be a list of strings.")
		ok

		cResult = QR(pacItems, :stzListOfStrings).ConcatenatedUsing(This.String())
		return cResult

	  #==========================================#
	 #   METHODS USED FOR NEAR-NATURAL-CODING   #
	#==========================================#

	def IsAlmostAFunctionCall()
		# Why almost? Because it doesn't analyse the correctness of the params
		# which we should do in the future, but this is sufficient for our
		# actual needs in stzChainOfTruth and other classes of natural-coding

		# PS: if you you don't like sutch a precison, use the alternative name
		# IsFunctionCall() instead.

		if This.NumberOfOccurrence("(") = 1 and
		   This.NumberOfOccurrence(")") = 1 and
		   This.FindFirst("(") > 1 and
		   This.FindFirst("(") < This.FindFirst(")") and
		   This.LastChar() = ")" // and # TODO: complete this and remove "Almost" from the function name!
		   //This.SectionQ(1,  This.FindFirst("(") - 1).ContainsOnly(:CompterCodeChars)
		
			return TRUE
		else
			return FALSE
		ok

		#< FunctionAlternativeForms >

		def IsFunctionCall()
			return This.IsAlmostAFunctionCall()
		#>

	def IsAMethodOfThisObject(pObject)
		return This.String().ExistsIn( classes(pObject) )

		def IsMethodOfObject(pObject)
			return IsAMethodOfThisObject(pObject)

	def IsAnAttributeOfThisObject(pObject)
		return This.String().ExistsIn( attributes(pObject) )

		def IsAttributeOfObject(pObject)
			return IsAnAttributeOfThisObject(pObject)		 

	#-----------------

	def IsStzString()
		return TRUE

	def StzType()
		return :stzString

	def IsANumber()
		return FALSE

		def IsNotANumber()
			return TRUE

	def IsAString()
		return TRUE

		def IsNotAString()
			return FALSE

	def IsAList()
		return FALSE

		def IsNotAList()
			return TRUE

	def IsAnObject()
		return TRUE

		def IsNotAnObject()
			return FALSE

	  #=====================================================#
	 #  CHECKING IF THE STRING STARTS WITH A GIVEN NUMBER  #
	#=====================================================#

	def StartsWithNumber(n)
		
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).RemoveSpacesQ().
					 RemoveQ("_").
					 ThisFirstCharRemoved("+")
			ok
		ok

		oStrCopyWS = This.Copy().RemoveSpacesQ()
		cLeadingNumber = Q(oStrCopyWS.LeadingNumber()).ThisFirstCharRemoved("+")

		if  cLeadingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithLeadingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsStartingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsLeadingNumber(n)
			return This.StartsWithNumber(n)

		def HasLeadingNumber(n)
			return This.StartsWithNumber(n)

		def HasStartingNumber(n)
			return This.StartsWithNumber(n)

		#>
		
	  #-----------------------------------------------#
	 #  CHECKING IF THE STRING STARTS WITH A NUMBER  #
	#-----------------------------------------------#

	def StartsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.StartsWithANumber()
		#--> TRUE
		*/

		oStrCopyWS = This.Copy().RemoveSpacesQ()

		if  oStrCopyWS.FirstCharQ().IsANumberInString() or

		    ( oStrCopyWS.NumberOfChars() > 1 and
		      oStrCopyWS.FirstCharQ().IsEither("+", :Or = "-") and
		      oStrCopyWS.SecondCharQ().IsANumberInString() )

			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def StartsWithALeadingNumber()
			return This.StartsWithANumber()

		def ContainsAStartingNumber()
			return This.StartsWithANumber()

		def ContainsALeadingNumber()
			return This.StartsWithANumber()

		def HasALeadingNumber()
			return This.StartsWithANumber()

		def HasAStartingNumber()
			return This.StartsWithANumber()

		#>

	  #-----------------------------------------------------#
	 #  GETTING THE LEADING NUMBER (IF ANY) IN THE STRING  #
	#-----------------------------------------------------#

	def StartingNumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		o1.StartingNumber()
		#--> 23
		*/

		if NOT This.HasALeadingNumber()
			return ""
		ok

		cResult = ""
		bContinue = TRUE
		i = 0
		nLen = This.NumberOfChars()

		while bContinue
			i++
			if i > nLen
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "_", "." ]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).
			  RemoveSpacesQ().
			  RemoveThisFirstCharQ("+").
			  ThisLastCharRemoved(".")

		return cResult

		#< @FunctionAlternativeForm

		def LeadingNumber()
			return This.StartingNumber()

		#>
	
  	  #===================================================#
	 #  CHECKING IF THE STRING ENDS WITH A GIVEN NUMBER  #
	#===================================================#

	def EndsWithNumber(n)
		if isString(n)
			if n = ""
				return FALSE

			else
				n = Q(n).ThisFirstCharRemoved("+")
			ok
		ok

		cTrailingNumber = Q(This.TrailingNumber()).ThisFirstCharRemoved("+")

		if  cTrailingNumber = ""+ n
			return TRUE
		else
			return FALSE
		ok

		#< @FunctionAlternativeForms

		def EndsWithTrailingNumber(n)
			return This.EndsWithNumber(n)

		def EndsWithFinalNumber(n)
			return This.EndsWithNumber(n)

		def ContainsTrailingNumber(n)
			return This.StartsWithNumber(n)

		def ContainsFinalNumber(n)
			return This.StartsWithNumber(n)

		def ContainsEndingNumber(n)
			return This.StartsWithNumber(n)

		#>
		
	  #---------------------------------------------#
	 #  CHECKING IF THE STRING ENDS WITH A NUMBER  #
	#---------------------------------------------#

	def EndsWithANumber()
		/* EXAMPLE
		o1 = new stzString("23 rounds")
		? o1.EndsWithNumber()
		#--> TRUE
		*/

		nResult = This.LastCharQ().IsANumberInString()
		return nResult

		#< @FunctionAlternativeForms

		def EndsWithATrailingNumber()
			return This.EndsWithNumber()

		def EndsWithAFinalNumber()
			return This.EndsWithNumber()

		def ContainsATrailingNumber()
			return This.EndsWithNumber()

		def ContainsAFinalNumber()
			return This.EndsWithNumber()

		def ContainsAnEndingNumber()
			return This.EndsWithNumber()

		#>

	  #------------------------------------------------------#
	 #  GETTING THE TRAILING NUMBER (IF ANY) IN THE STRING  #
	#------------------------------------------------------#

	def TrailingNumber()
		/* EXAMPLE
		o1 = new stzString("Age: 48")
		o1.TrailingNumber()
		#--> 48
		*/

		cResult = ""
		bContinue = TRUE
		i = This.NumberOfChars() + 1

		while bContinue
			i--
			if i = 0
				bContinue = FALSE

			else
				cCurrentChar = This.Char(i)

				if NOT ( Q(cCurrentChar).IsANumberInString() or
					 Q(cCurrentChar).IsOneOfThese([ "+", "-", "."]) )

					bContinue = FALSE

				else
					cResult += cCurrentChar

				ok

			ok
		end

		cResult = Q(cResult).ReverseCharsQ().ThisLastCharRemoved(".")
		return cResult

		#< @FunctionAlternativeForm

		def FinalNumber()
			return This.StartingNumber()

		def EndingNumber()
			return This.StartingNumber()

		#>

	  #==============================================================#
	 #  GETTING ALL THE (DECIMAL) NUMBERS THAT EXIST IN THE STRING  #
	#==============================================================#
 
	def Numbers()
		/* EXAMPLE

		o1 = new stzString("book: 12.34, watch: -56.30, glasses: 77.")
		? o1.Numbers()
		#--> [ "13.34", "-56.30",  "77" ]

		*/

		cTempStr = This.Content() + " "
		nLen = This.NumberOfChars() + 1

		cNumber = ""
		acResult = []
		bThereWasASign = FALSE

		for i = 1 to nLen
			c = Q(cTempStr).CharAt(i)

			if c = " " and bThereWasASign
				loop
			ok

			if StzCharQ(c).IsANumber() or
			   (c = "+" or c = "-" and cNumber = "") or
			   ((c = "." or c = "_") and cNumber != "" and StzCharQ(Q(cNumber).LastChar()).IsANumber())
		
				cNumber += c

			but (NOT StzCharQ(c).IsANumber()) or i = nLen
		
				if cNumber != ""
		
					cNumber = Q(cNumber).
						  RemoveThisLastCharQ(".").
						  RemoveThisLastCharQ("_").
						  Content()
		
					cSign = ""
					if len(acResult) > 0
						if acResult[len(acResult)] = "+"
							cSign = "+"

						but acResult[len(acResult)] = "-"
							cSign = "-"
						ok
					ok

					if cSign != ""
						del(acResult, len(acResult))
						cNumber = cSign + cNumber
					ok

					if cNumber != "+" and cNumber != "-"
						acResult + cNumber
						cNumber = ""
					ok
				ok
			ok
		
		next
		
		return acResult

		def NumbersQ()
			return This.NumbersQR(:stzList)

		def NumbersQR(pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT isString(pcReturnType)
				StzRaise("Incorrect param type! pcReturnType must be a string.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.Numbers() )

			on :stzListOfStrings
				return new stzList( This.Numbers() )

			other
				StzRaise("Unsupported return type!")
			off

	  #--------------------------------------#
	 #  EXTRACTING NUMBERS FROM THE STRING  #
	#--------------------------------------#

	def ExtractNumbers()
		acNumbers = This.Numbers()
		This.RemoveMany(acNumbers)
		return acNumbers

	  #------------------------------------------------------------------#
	 #  GETTING THE NUMBER OF (DECIMAL) NUMBERS INCLUDED IN THE STRING  #
	#------------------------------------------------------------------#

	def NumberOfNumbers()
		return len( This.Numbers() )

		#< @FunctionAlternativeForms

		def CountNumbers()
			return This.NumberOfNumbers()

		def HowManyNumbers()
			return This.NumberOfNumbers()

		def HowManyNumber()
			return This.NumberOfNumbers()

		#>

	  #-------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR POSITIONS  #
	#-------------------------------------------------------------------------#

	def NumbersAndTheirPositions() # TODO: Check performance!
		aResult = Q(This.UniqueNumbers()).AssociatedWith( This.FindNumbers() )
		return aResult

		def NumbersZ()
			return This.NumbersAndTheirPositions()

	  #------------------------------------------------------------------------#
	 #  GETTING THE NUMBERS INCLUDED IN THE STRING ALONG WITH THEIR SECTIONS  #
	#------------------------------------------------------------------------#

	def NumbersAndTheirSections() # TODO: chek performance!
		aResult = []
		acNumbersU = This.UniqueNumbers()
		nLen = len(acNumbersU)

		for i = 1 to nLen
			aResult + [ acNumbersU[i], This.FindAsSections(acNumbersU[i]) ]
		next

		return aResult


		def NumbersZZ()
			return This.NumbersAndTheirSections()

	  #----------------------------------------------------#
	 #  GETTING THE LIST OF UNIQUE NUMBERS IN THE STRING  #
	#----------------------------------------------------#

	def UniqueNumbers()
		return This.NumbersQ().DuplicatesRemoved()

		#< @FunctionAlternativeForms

		def NumbersU()
			return This.UniqueNumbers()

		def NumbersWithoutDuplication()
			return This.UniqueNumbers()

		#>

	  #-------------------------------------------------------#
	 #  GETTTING THE NUMBER OF UNIQUE NUMBERS IN THE STRING  #
	#-------------------------------------------------------#

	def NumberOfUniqueNumbers()
		return len( This.UniqueNumbers() )

		#< @FunctionAlternativeForms

		def CountUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def NumberOfNumbersU()
			return This.NumberOfUniqueNumbers()

		def CountNumbersU()
			return This.NumberOfUniqueNumbers()

		#--

		def HowManyUniqueNumbers()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersU()
			return This.NumberOfUniqueNumbers()

		def HowManyUniqueNumber()
			return This.NumberOfUniqueNumbers()

		def HowManyNumberU()
			return This.NumberOfUniqueNumbers()

		#--

		def NumberOfNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		def HowManyNumbersWithoutDuplication()
			return This.NumberOfUniqueNumbers()

		#>

	  #----------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (POSITIONS RETURNED)  #
	#----------------------------------------------------------------#

	def FindNumbers()
		anResult = This.FindManyQ( This.UniqueNumbers() ).FlattenQ().Sorted()
		return anResult

	  #---------------------------------------------------------------#
	 #  FINDING (DECIMAL) NUMBERS IN THE STRING (SECTIONS RETURNED)  #
	#---------------------------------------------------------------#

	def FindNumbersAsSections()
		return This.FindManyAsSections( This.UniqueNumbers() )

		def FindNumbersSections()
			return This.FindNumbersAsSection()

		def FindAsSectionsOfNumbers()
			return This.FindNumbersAsSection()

	  #--------------------------------------------------------------#
	 #  GETTING THE NTH (DECIMAL) NUMBER THAT EXISTS IN THE DTRING  #
	#--------------------------------------------------------------#

	def NthNumber(n)
		if isString(n)
			if n = :First or n = :FirstNumber
				n = 1

			but n = :Last or n = :LastNumber
				n = len( This.Numbers() )
			ok
		ok

		return This.Numbers()[n]

	  #------------------------------------------------------#
	 #  GETTING THE FIRST NUMBER THAT EXISTS IN THE DTRING  #
	#------------------------------------------------------#

	def FirstNumber(n)
		return This.NthNumber(1)

	  #-----------------------------------------------------#
	 #  GETTING THE LAST NUMBER THAT EXISTS IN THE DTRING  #
	#-----------------------------------------------------#

	def LastNumber(n)
		return This.NthNumber(This.NumberOfNumbers())

	  #==========================================#
	 #  NUMBERS COMING AFTER A GIVEN SUBSTRING  #
	#==========================================#

	def NumbersComingAfterCS(pcSubStr, pCaseSensitive)
		/* EXAMPLE
		o1 = new stzString("This[@i-1] = This[@i+3]")
		? o1.NumbersComingAfter("@i")
		#--> [ "-1", "3" ]

		? o1.NumberComingAfter("@i+")
		#--> 3
		*/

		if NOT isString(pcSubStr)
			StzRaise("Incorrect param type! pcsubStr must be a string.")
		ok

		acSubStrings = This.SplitQ("@i").FirstItemRemoved()
		# Splitting takes as little as 0.01s

		nLen = len(acSubStrings)
	
		acResult = []
		for i = 1 to nLen
			acNumbers = Q(acSubStrings[i]).Numbers()
			nLen2 = len(acNumbers)

			for j = 1 to nLen2
				acResult + acNumbers[j]
			next j
		next i

		return acResult


		#< @FunctionFluentForm

		def NumbersComingAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, :stzList)

		def NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			if isList(pcReturnType) and Q(pcReturnType).IsReturnedAsNamedParam()
				pcReturnType = pcReturnType[2]
			ok

			if NOT ( isString(pcReturnType) and Q(pcReturnType).IsStzClassName() )
				stzRaise("Incorrect param type! pcReturnType must be a string containing a softanza class name.")
			ok

			switch pcReturnType
			on :stzList
				return new stzList( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			on :stzListOfNumbers
				return new stzListOfNumbers( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			on :stzListOfStrings
				return new stzListOfStrings( This.NumbersComingAfterCSXT(pcSubStr, pCaseSensitive) )

			other
				StzRaise("Unsupported param type!")
			off

		#>

		#< @FunctionAlternativeForm

		def NumbersAfterCS(pcSubStr, pCaseSensitive)
			return This.NumbersComingAfterCS(pcSubStr, pCaseSensivitive)

		def NumbersAfterCSQ(pcSubStr, pCaseSensitive)
			return This.NumbesrAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		def NumbersAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return NumbersComingAfterCSQR(pcSubStr, pCaseSensitive, pcReturnType)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NumbersComingAfter(pcSubStr)
		return This.NumbersComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionFluentForm

		def NumbersComingAfterQ(pcSubStr)
			return This.NumbersComingAfterQR(pcSubStr, :stzList)

		def NumbersComingAfterQR(pcSubStr, pcReturnType)
			return This.NumbersComingAfterCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)

		#>

		#< @FunctionAlternativeForm

		def NumbersAfter(pcSubStr)
			return This.NumbersComingAfter(pcSubStr)

		def NumbersAfterQ(pcSubStr)
			return This.NumbesrAfterQR(pcSubStr, pcReturnType)

		def NumbersAfterQR(pcSubStr, pcReturnType)
			return NumbersComingAfterQR(pcSubStr, pcReturnType)

		#>

	  #---------------------------------------------#
	 #  NTH NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#---------------------------------------------#

	def NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)
		# TODO: Re-implement it for better performance
		# No need to parse all the numbers and then get the nth

		return This.NumbersComingAfterCS(pcSubStr, pCaseSensitive)[n]

		#< @FunctionAlternativeForm

		def NthNumberAfterCS(n, pcSubStr, pCaseSensitive)
			return This.NthNumberComingAfterCS(n, pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY

	def NthNumberComingAfter(n, pcSubStr)
		return This.NthNumberComingAfterCS(n, pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def NthNumberAfter(n, pcSubStr)
			return This.NthNumberComingAfter(n, pcSubStr)

		#>

	  #-----------------------------------------------#
	 #  FIRST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#-----------------------------------------------#

	def FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(1, pcSubStr, pCaseSensitive)

		def NumbeComingAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def FirstNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.FirstNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def FirstNumberComingAfter(pcSubStr)
		return This.FirstNumberComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		def NumberComingAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#< @FunctionAlternativeForm

		def FirstNumberAfter(pcSubStr)
			return This.FirstNumberComingAfter(pcSubStr)

		#>

	  #----------------------------------------------#
	 #  LAST NUMBER COMING AFTER A GIVEN SUBSTRING  #
	#----------------------------------------------#

	def LastNumberComingAfterCS(pcSubStr, pCaseSensitive)
		return This.NthNumberComingAfterCS(:Last, pcSubStr, pCaseSensitive)

		#< @FunctionAlternativeForm

		def LastNumberAfterCS(pcSubStr, pCaseSensitive)
			return This.LastNumberComingAfterCS(pcSubStr, pCaseSensitive)

		#>

	#-- WITHOUT CASESENSITIVITY
	
	def LastNumberComingAfter(pcSubStr)
		return This.LastNumberComingAfterCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForm

		def LastNumberAfter(pcSubStr)
			return This.LastNumberComingAfter(pcSubStr)

		#>

	  #====================================#
	 #  BISECTING THE STRING INTO HALVES  #
	#====================================#

	#-- FIRST HALF

	def FirstHalf()

		nPos = floor(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult

	def FirstHalfAndPosition()
		aResult = [ This.FirstHalf(), 1 ]
		return aResult

		def FirstHalfAndItsPosition()
			return This.FirstHalfAndPosition()

	def FirstHalfAndSection()
		aResult = [ This.FirstHalf(), [1, floor(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSection()
			return This.FirstHalfAndSection()
		
	def FirstHalfXT()

		nPos = ceil(This.NumberOfChars() / 2)
		acResult = This.Section(1, nPos)

		return acResult
		
	def FirstHalfAndPositionXT()
		aResult = [ This.FirstHalfXT(), 1 ]
		return aResult

		def FirstHalfAndItsPositionXT()
			return This.FirstHalfAndPositionXT()

	def FirstHalfAndSectionXT()
		aResult = [ This.FirstHalfXT(), [1, ceil(This.NumberOfChars() / 2)] ]
		return aResult

		def FirstHalfAndItsSectionXT()
			return This.FirstHalfAndSectionXT()

	#-- SECOND HALF

	def SecondHalf()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPosition()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), nPos ]
		return aResult

		def SecondHalfAndItsPosition()
			return This.SecondHalfAndPosition()

	def SecondHalfAndSection()
		nLen = This.NumberOfChars()
		nPos = floor(nLen / 2) + 1
		aResult = [ This.SecondHalf(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSection()
			return This.SecondHalfAndSection()

	def SecondHalfXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		acResult = This.Section(nPos, nLen)

		return acResult

	def SecondHalfAndPositionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), nPos ]
		return aResult

		def SecondHalfAndItsPositionXT()
			return This.SecondHalfAndPositionXT()

	def SecondHalfAndSectionXT()
		nLen = This.NumberOfChars()
		nPos = ceil(nLen / 2) + 1
		aResult = [ This.SecondHalfXT(), [ nPos, nLen ] ]
		return aResult

		def SecondHalfAndItsSectionXT()
			return This.SecondHalfAndSectionXT()

	#-- THE TWO HALVES

	def Halves()
		acResult = []
		acResult + This.FirstHalf() + This.SecondHalf()

		return acResult

		def Bisect()
				return This.Halves()

	def HalvesXT()
		acResult = []
		acResult + This.FirstHalfXT() + This.SecondHalfXT()

		return acResult

		def BisectXT()
			return This.Halves()

	def HalvesAndPositions()
		aResult = [ This.FirstHalfAndPosition(), This.SecondHalfAndPosition() ]
		return aResult

		def HalvesAndTheirPositions()
			return This.HalvesAndPositions()

	def HalvesAndPositionsXT()
		aResult = [ This.FirstHalfAndPositionXT(), This.SecondHalfAndPositionXT() ]
		return aResult

		def HalvesAndTheirPositionsXT()
			return This.HalvesAndPositionsXT()

	def HalvesAndSections()
		aResult = [ This.FirstHalfAndSection(), This.SecondHalfAndSection() ]
		return aResult

		def HalvesAndTheirSections()
			return This.HalvesAndSections()

	def HalvesAndSectionsXT()
		aResult = [ This.FirstHalfAndSectionXT(), This.SecondHalfAndSectionXT() ]
		return aResult

		def HalvesAndTheirSectionsXT()
			return This.HalvesAndSectionsXT()

	  #==========================================#
	 #   STRINGIFY(), TOSTRING(), AND TOCODE()  #
	#==========================================#

	def Stringify()
		# Do nothing, the object is naturally stringified
		# becauses it is already a string

		def StringifiyQ()
			return new stzString( This.String() )

	def Stringified()
		return This.String()

	def ToString()
		return This.String()

		def ToStringQ()
			return new stzString( This.ToString() )
	
	def ToCode()
		cResult = ""

		cQuote = "'"
		cDoubleQuote = '"'

		if This.IsBoundedBy(cDoubleQuote)
			cResult = cQuote + This.String() + cQuote

		but This.IsBoundedBy(cQuote)
			cResult = cDoubleQuote + This.String() + cDoubleQuote

		else
			cResult = This.String()
		ok

		return cResult

		def ToCodeQ()
			return new stzString( This.ToCode() )

	  #-------------------------------------------------------------------------#
	 #  GETTING THE COMMON SUBSTRINGS BETWEEN THIS STRING AND AN OTHER STRING  #
	#-------------------------------------------------------------------------#

	def CommonSubStringsCS(pcOtherStr, pCaseSensitive)
		if isList(pcOtherStr) and Q(pcOtherStr).IsWithNamedParam()
			pcOtherStr = pcOtherStr[2]
		ok

		if NOT isString(pcOtherStr)
			StzRaise("Incorrect param type! pcOtherStr must be a string.")
		ok

		aTempList = [
			This.SubStringsCS(pCaseSensitive),
			Q(pcOtherStr).SubStringsCS(pCaseSensitive)
		]

		acResult = StzListOfListsQ(aTempList).CommonItemsCS(pCaseSensitive)
		
		return acResult

		def IntersectionCS(pcOtherStr, pCaseSensitive)
			return This.CommonSubStringsCS(pcOtherStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CommonSubStrings(pcOtherStr)
		return This.CommonSubStringsCS(pcOtherStr, :CaseSensitive = TRUE)

		def Intersection(pcOtherStr)
			return This.CommonSubStrings(pcOtherStr)

	  #======================#
	 #  SHOWING THE STRING  #
	#======================#

	def Show()
		? @@( This.Content() )

	def ShowShort()
		? @@( This.Shortened() )

		def ShowShortCopy()
			This.ShowShort()

	def ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		? @@( This.ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart) )

		def ShowShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShowShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)

	def ShowShortN(n)
		? @@( This.ShortenedN(n) )

	def ShowShortUsing(pcMiddlePart)
		? @@( This.ShortenedUsing(pcMiddlePart) )

	def ShowShortNUsing(n, pcMiddlePart)
		? @@( This.ShortenedNUsing(n, pcMiddlePart) )

	  #-------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING  #
	#===========================================#

	def ToShort()
		return This.ToShortXT(10, 3, " (...) ")

	  #-----------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING WITH N ITEMS FROM EACH SIDE  #
	#-----------------------------------------------------------------------#

	def ToShortN(n)
		return This.ToShortXT(10, n, " (...) ")

	  #---------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USiNG A GIVEN MIDDLE PART  #
	#---------------------------------------------------------------------#

	def ToShortUsing(pcMiddlePart)
		return This.ToShortXT(10, 3, pcMiddlePart)

	  #--------------------------------------------------------------------------------------------------#
	 #   GETTING A SHORTENED COPY OF THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#--------------------------------------------------------------------------------------------------#

	def ToShortNUsing(n, pcMiddlePart)
		return This.ToShortXT(10, n, pcMiddlePart)

	  #------------------------------------------------------#
	 #  GETTING A SHORTENED COPY OF THE STRING -- EXTENDED  #
	#------------------------------------------------------#

	def ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		# nMinStrSize : the minimum size to start shprtening
		# --> if the size of the string is less than this value,
		#     the string will not be shortened (returned as is)

		# pNumberOfCharsToShow: the number of chars to show from
		# both the beginning and end of the string
		# --> the other part of the string (coming in the middle)
		#     will be hide and replaced by pcMiddlePart

		/* EXAMPLES

		? Q("1234567890987654321").Shortened()
		#--> 123 ... 321
		
		? Q("1234567890987654321").ShortenedN(5)
		#--> 12345 ... 54321
		
		? Q("1234567890987654321").ShortenedXT(0, 3, " ... ")
		#--> 123 ... 321

		*/

		nLen = This.NumberOfItems()
		if nLen < nMinStrSize
			This.Show()
			return
		ok

		n1 = 0
		n2 = 0

		if isNumber(pNumberOfCharsToShow)
			n1 = pNumberOfCharsToShow
			n2 = pNumberOfCharsToShow

		but isList(p) and Q(pNumberOfCharsToShow).IsPairOfNumbers()
			n1 = pNumberOfCharsToShow[1]
			n2 = pNumberOfCharsToShow[2]

		else
			StzRaise("Incorrect param type! pNumberOfCharsToShow must be a number or pair of numbers.")

		ok

		if n1 = 0 or n2 = 0
			StzRaise("Incorrect value! The number of chars to show must be different of zero.")
		ok

		# Doing the job

		cPart1 = This.Section(1, n1)
		cPart2 = This.Section(nLen - n2 + 1, nLen)

		cResult = cPart1 + pcMiddlePart + cPart2

		return cResult

	  #-------------------------#
	 #  SHORTENING THE STRING  #
	#=========================#

	def Shorten()
		This.ShortenXT(10, 3, "...")

		def ShortenQ()
			This.Shorten()
			return This

	def Shortened()
		cResult = This.ToShortXT(10, 3, "...")
		return cResult

	  #---------------------------------------------------#
	 #  SHORTENING THE STRING TO N CHARS FROM EACH SIDE  #
	#---------------------------------------------------#

	def ShortenN(n)
		cShort = This.ShortenedXT(10, n, "...")
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNQ(n)
			This.ShortenN(n)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToN(n)
			This.ShortenN(n)

			def ShortenToNQ(n)
				This.ShortenToN(n)
				return This

		def ShortenToNChars(n)
			This.ShortenN(n)

			def ShortenToNICharsQ(n)
				This.ShortenToNChars(n)
				return This

		def ShortenToNCharsInEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsInEachSideQ(n)
				This.ShortenToNCharsInEachSide(n)
				return This

		def ShortenToNCharsFromEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsFromEachSideQ(n)
				This.ShortenToNCharsFromEachSide(n)
				return This

		def ShortenToNCharsAtEachSide(n)
			This.ShortenN(n)

			def ShortenToNCharsAtEachSideQ(n)
				This.ShortenToNCharsAtEachSide(n)
				return This

		#>

	def ShortenedN(n)
		cResult = This.Copy().ShortenNQ(n).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToN(n)
			return This.ShortenedN(n)

		def ShortenedToNChars(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsInEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNCharsFromEachSide(n)
			return This.ShortenedN(n)

		def ShortenedToNICharsAtEachSide(n)
			return This.ShortenedN(n)

		#>

	  #-----------------------------------------------------------------#
	 #  SHORTENING THE STRING USING THE GIVEN STRING AS A MIDDLE PART  #
	#-----------------------------------------------------------------#

	def ShortenUsing(pcMiddlePart)
		cShort = This.ShortenedXT(10, 3, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenUsingQ(pcMiddlePart)
			This.ShortenUsing(pcMiddlePart)
			return This

	def ShortenedUsing(pcMiddlePart)
		cResult = This.Copy().ShortenUsingQ(pcMiddlePart).Content()
		return cResult

	  #------------------------------------------------------------------------------#
	 #  SHORTENING THE STRING USING N CHARS FROM EACH SIDE AND THE GIVEN MIDDLE PART  #
	#------------------------------------------------------------------------------#

	def ShortenNUsing(n, pcMiddlePart)
		cShort = This.ToShortNUsing(n, pcMiddlePart)
		This.UpdateWith(cShort)

		#< @FunctionFluentForm

		def ShortenNUsingQ(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)
			return This

		#>

		#< @FunctionAlternativeForms

		def ShortenToNUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNUsingQ(n, pcMiddlePart)
				This.ShortenToNUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsInEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsInEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsFromEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsFromEachSideUsing(n, pcMiddlePart)
				return This

		def ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
			This.ShortenNUsing(n, pcMiddlePart)

			def ShortenToNCharsAtEachSideUsingQ(n, pcMiddlePart)
				This.ShortenToNCharsAtEachSideUsing(n, pcMiddlePart)
				return This

		#>

	def ShortenedNUsing(n, pcMiddlePart)
		cResult = This.Copy().ShortenNUsingQ(n, pcMiddlePart).Content()
		return cResult

		#< @FunctionAlternativeForms

		def ShortenedToNUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsInEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsFromEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		def ShortenedToNCharsAtEachSideUsing(n, pcMiddlePart)
			return This.ShortenedNUsing(n, pcMiddlePart)

		#>

	  #-----------------------------------#
	 #  SHORTENING THE STRING -- EXTENDED  #
	#-----------------------------------#

	def ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cShort = This.ToShortXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		This.UpdateWith(cShort)

		def ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			This.ShortenXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
			return This

	def ShortenedXT(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart)
		cResult = This.Copy().ShortenXTQ(nMinStrSize, pNumberOfCharsToShow, pcMiddlePart).Content()
		return cResult

	  #===========================================#
	 #  GETTING THE LIST OF WORDS IN THE STRING  #
	#===========================================#

	# NOTE: stzString has a limites understanding of what a word is.
	# In fact, it just a substring bounded by two spaces (or one space
	# if it is at the start or the end of the substring.

	# To get a more appealling meaning of Word(), use stzText instead.

	def WordsCS(pCaseSensitive)
		acResult = This.SplitCS(" ", pCaseSensitive)
		return acResult

		def WordsCSQ(pCaseSensitive)
			return WordsCSQR(pCaseSensitive, :stzList)

		def WordsCSQR(pCaseSensitive, pcReturnType)
			switch pcReturnType
			on :stzList
				return new stzList( This.WordsCS(pCaseSensitive) )
			on :stzListOfStrings
				return new stzListOfStrings( This.WordsCS(pCaseSensitive) )
			other
				StzRaise("Unsupported return type!")
			off

	#-- WITHOUT CASESENSITIVITY

	def Words()
		return This.WordsCS(:CaseSensitive = TRUE)

		def WordsQ()
			return This.WordsQR(:stzList)

		def WordsQR(pcReturnType)
			return This.WordsCSQR(:CaseSensitive = TRUE, pcReturnType)

	  #------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRING CORRESPONDS TO A WORD OF THE STRING  #
	#------------------------------------------------------------------------#

	def SubStringIsWordCS(pcSubStr, pCaseSensitive) # TODO: Check for performance!
		bResult = This.WordsCSQ(pCaseSensitive).ContainsCS(pcSubStr, pCaseSensitive)
		return bResult

		#< @FunctionAlternativeForm

		def SubStringIsAWordCS(pcSubStr, pCaseSensitive)
			return This.SubStringIsWordCS(pcSubStr, pCaseSensitive)

		#>

		#< @FunctionMisspelledForm

		def SubSgtringIsWordCS(pcSubStr, pCaseSensitive)
			return This.SubStringIsWord(pcSubStr, pCaseSensitive)

		# TODO: Generalise this misspelled form to all functions
		# containing SubString in their names

		#>

	#-- WITHOUT CASESENSITIVITY

	def SubStringIsWord(pcSubStr)
		return This.SubStringIsWordCS(pcSubStr, :CaseSensitive = TRUE)

		#< @FunctionAlternativeForms

		def SubStringIsAWord(pcSubStr)
			return SubStringIsWord(pcSubStr)

		#>

		#< @FunctionMisspelledForm

		def SubSgtringIsWord(pcSubStr)
			return This.SubStringIsWord(pcSubStr)

		#>

	  #-------------------------------------------------------------------------#
	 #  CHECKING IF THE GIVEN SUSBSTRINGS CORRESPOND TO A WORDS OF THE STRING  #
	#-------------------------------------------------------------------------#

	def SubStringsAreWordsCS(acSubStr, pCaseSensitive) # TODO: check for performance!

		if CheckParams() = TRUE
			if NOT (isList(acSubStr) and Q(acSubStr).IsLIstOfStrings())
				StzRaise("Incorrect param type! acSubStr must be a list pf strings.")
			ok
		ok

		bResult = TRUE

		nLen = len(acSubStr)
		for i = 1 to nLen
			if NOT This.SubStringIsWordCS(acSubStr[i], pCaseSensitive)
				bResult = FALSE
				exit
			ok

		next

		return bResult
		
		
	#-- WITHOUT CASESENSITIVITY

	def SubStringsAreWords(acSubStr)
		return This.SubStringsAreWordsCS(acSubStr, :CaseSensitive = TRUE)

	  #-----------------------------------#
	 #  FINDING THE WORDS IN THE STRING  #
	#===================================#

	def FindWordsCS(pCaseSensitive)

		acSplittedZ = This.SplitCSZ(" ", pCaseSensitive)
		anResult = QR(acSplittedZ, :stzListOfPairs).SecondItems()

		return anResult

		def PositionsOfWordsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

		def WordsPositionsCS(pCaseSensitive)
			return This.FindWordsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWords()
		return This.FindWordsCS(:CaseSensitive = TRUE)

		def PositionsOfWords()
			return This.FindWords()

		def WordsPositions()
			return This.FindWords()

	  #-----------------------------------------------------------------------------#
	 #  FINDING THE WORDS IN THE STRING AND RETURNING THEIR POSITIONS AS SECTIONS  #
	#-----------------------------------------------------------------------------#

	def FindWordsAsSectionsCS(pCaseSensitive)

		acSplittedZZ = This.SplitCSZZ(" ", pCaseSensitive)
		aResult = QR(acSplittedZZ, :stzListOfPairs).SecondItems()

		return aResult

		def SectionsOfWordsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

		def WordsSectionsCS(pCaseSensitive)
			return This.FindWordsAsSectionsCS(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindWordsAsSections()
		return This.FindWordsAsSectionsCS(:CaseSensitive = TRUE)

		def SectionsOfWords()
			return This.FindWordsAsSections()

		def WordsSections()
			return This.FindWordsAsSections()

	  #--------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR POSITIONS  #
	#--------------------------------------------------------------#

	def WordsCSZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirPositionsCS(pCaseSensitive)
			return This.WordsCSZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZ()
		return This.WordsCSZ(:CaseSensitive = TRUE)

		def WordsAndTheirPositions()
			return This.WordsZ()

	  #-------------------------------------------------------------#
	 #  GETTING THE WORDS IN THE STRING ALONG WITH THEIR SECTIONS  #
	#-------------------------------------------------------------#

	def WordsCSZZ(pCaseSensitive)

		aResult = Assoction([
			This.WordsCS(pCaseSensitive),
			This.FindWordsAsSectionsCS(pCaseSensitive)
		])

		return aResult

		def WordsAndTheirSectionsCS(pCaseSensitive)
			return This.WordsCSZZ(pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def WordsZZ()
		return This.WordsCSZZ(:CaseSensitive = TRUE)

		def WordsAndTheirSections()
			return This.WordsZZ()

	  #===========#
	 #   MISC.   #
	#===========#
		
	def HasSameTypeAs(p)
		return isString(p)

	def IsAnagramOfCS(pcOtherStr, pCaseSensitive)

		oTheseChars = This.CharsQR(:stzListOfStrings).RemoveduplicatesQ().SortInAscendingQ()

		cOtherChars = StzStringQ( pcOtherStr ).
				CharsQ().RemoveDuplicatesQ().
				SortInAscendingQ().Content()
	
		bResult = oTheseChars.IsEqualToCS( cOtherChars, pCaseSensitive )

		return bResult

	def IsAnagramOf(pcOtherStr)
		return This.IsAnagramOfCS(pcOtherStr, :CS = TRUE)

	def UpTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() < CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar)
				acResult + StzCharQ(n).Content()
			next
			return acResult
		ok

	def DownTo(pcChar)
		if This.IsChar() and ( isString(pcChar) and StzStringQ(pcChar).IsChar() ) and
		   This.Unicode() > CharUnicode(pcChar)

			acResult = []
			for n = This.Unicode() to CharUnicode(pcChar) step -1 
				acResult + StzCharQ(n).Content()
			next

			return acResult
		ok

	def FirstAndLastChars()
		aResult = [ This.FirstChar(), This.LastChar() ]
		return aResult

	def LastAndFirstChars()
		aResult = [ This.LastChar(), FirstChar() ]
		return aResult
		
	def Methods()
		return ring_methods(This)

	def Attributes()
		return ring_attributes(This)

	def ClassName()
		return "stzstring"

		def StzClassName()
			return This.ClassName()

		def StzClass()
			return This.ClassName()

	def IsLatinScript()
		return This.ToStzText().IsLatinScript()

		def IsLatin()
			return This.IsLatinScript()

	def IsArabicScript()
		return This.ToStzText().IsArabicScript()

		def IsArabic()
			return This.IsArabicScript()

	def IsText()
		return TRUE

	def ToStzCCode()
		return new stzCCode(This.String())

		def ToStzCCodeObject()
			return This.ToStzCCode()

		def ToStzCCodeQ()
			return This.ToStzCCode()
  
	#==
               
	def SubStringCS(pcSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsInOrInStringNamedParam()
			return This.SubStringInCS(pcSubStr[2], pCaseSensitive)
		ok

		if This.ContainsCS(pcSubStr, pCaseSensitive)
			return pcSubStr
		else
			return NULL
		ok

		def SubStringCSQ(pcSubStr, pCaseSensitive)
			if isList(pcSubStr) and Q(pcSubStr).IsInOrInStringNamedParam()
				return This.SubStringInCSQ(pcSubStr[2], pCaseSensitive)
			ok
	
			return new stzSubStringCS(pcSubStr, This.String(), pCaseSensitive)

	def SubString(pcSubStr)
		return This.SubStringCS(pcSubStr, :CaseSensitive = TRUE)

		def SubStringQ(pcSubStr)
			return This.SubStringCSQ(pcSubStr, :CaseSensitive = TRUE)

	#--

	def InCS(p, pCaseSensitive)
		if NOT (isString(p) or isList(p))
			StzRaise("Incorrect param type! p must be string or list.")
		ok

		if isString(p)
			return SubStringInCS(p, pCaseSensitive)

		but isList(p)
			return ItemInCS(p, pCaseSensitive)
		ok

		#< @FunctionFluentForm

		def InCSQ(p, pCaseSensitive)
			if NOT (isString(p) or isList(p))
				StzRaise("Incorrect param type! p must be string or list.")
			ok
	
			if isString(p)
				return SubStringInCSQ(p, pCaseSensitive)
	
			but isList(p)
				return ItemInCSQ(p, pCaseSensitive)
			ok

		#>

		#< @FunctionAlternativeForm

		def _In(p)
			return InCS(p, :CaseSensitive = TRUE)

			def InQ(p)
				return InCSQ(p, :CaseSensitive = TRUE)

		#>

	#--

	def SubStringInCS(pcStr, pCaseSensitive)
		if THis.ExistsInCS(pcStr, pCaseSensitive)
			return This.Content()
		else
			return NULL
		ok

		def SubStringInCSQ(pcStr, pCaseSensitive)
			return new stzSubStringCS(This.Content(), pcStr, pCaseSensitive)


	def SubStringIn(pcStr)
		return This.SubStringInCS(pcStr, :CaseSensitive = TRUE)

		def SubStringInQ(pcStr)
			return new stzSubString(This.Content(), pcStr)

	#--

	def ItemInCS(paList, pCaseSensitive)
		if NOT isList(paList)
			StzRaise("Incorrect param type! paList must be a list.")
		ok

		if This.ExistsInCS(paList, pCaseSensitive)
			return This.Content()
		else
			return NULL
		ok

		def ItemInCSQ(paList, pCaseSensitive)
			return new stzItemCS(This.Content(), paList, pCaseSensitive)

	def ItemIn(paList)	
		return This.ItemInCS(paList, :CaseSensitive = TRUE)
                                
                 ///////////////////////////////////////////////
                //                              ///////////////
      ///////////      ALTERNATIVE FORMS       /////////////
 ///////////////                              //
///////////////////////////////////////////////

	  #--------------------------#
	 #  ALTERNATIVES OF Find()  #
	#--------------------------#

	def FindAllOccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllOccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
						
		def FFindAllOccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)
	
	def FindAllCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindAllCSQ(pcSubStr, pCaseSensitive)
			return This.FindAllCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindAllCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindSubstringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindSubstringCSQ(pcSubStr, pCaseSensitive)
			return This.FindSubstringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindSubstringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def OccurrencesCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def OccurrencesCSQ(pcSubStr, pCaseSensitive)
			return This.OccurrencesCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def OccurrencesCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def PositionsOfSubStringCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def PositionsOfSubStringCSQ(pcSubStr, pCaseSensitive)
			return This.PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def PositionsOfSubStringCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	def FindPositionsCS(pcSubStr, pCaseSensitive)
		return This.FindCS(pcSubStr, pCaseSensitive)
	
		def FindPositionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindPositionsCSQR(pcSubStr, pCaseSensitive, :stzList)
					
		def FindPositionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindAll(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindAllQ(pcSubStr)
			return This.FindAllQR(pcSubStr, :stzList)
				
		def FindAllQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindSubStringQ(pcSubStr)
			return This.FindSubStringQR(pcSubStr, :stzList)
				
		def FindSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Occurrences(pcSubStr)
		return This.Find(pcSubStr)
	
		def OccurrencesQ(pcSubStr)
			return This.OccurrencesQR(pcSubStr, :stzList)
				
		def OccurrencesQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def Positions(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsQ(pcSubStr)
			return This.PositionsQR(pcSubStr, :stzList)
				
		def PositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)
	
	def PositionsOfSubString(pcSubStr)
		return This.Find(pcSubStr)
	
		def PositionsOfSubStringQ(pcSubStr)
			return This.PositionsOfSubStringQR(pcSubStr, :stzList)
				
		def PositionsOfSubStringQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindPositions(pcSubStr)
		return This.Find(pcSubStr)
	
		def FindPositionsQ(pcSubStr)
			return This.FindPositionsQR(pcSubStr, :stzList)
				
		def FindPositionsQR(pcSubStr, pcReturnType)
			return This.FindQR(pcSubStr, pcReturnType)

	def FindOccurrences(pcSubStr)
		if isList(pcSubStr) and
		   Q(pcSubStr).IsOneOfTheseNamedParams([ :Of, :OfSubString ])
			pcSubStr = pcSubStr[2]
		ok
	
		return This.Find(pcSubStr)
	
		def FindOccurrencesQ(pcSubStr)
			return This.FindOccurrencesQR(pcSubStr, :stzList)
				
		def FindOccurrencesQR(pcSubStr, pcReturnType)
			return This.FindAllQR(pcSubStr, pcReturnType)
	
	def FindAllOccurrences(pcSubStr)
		return This.FindOccurrences(pcSubStr)

	  #--------------------------------#
	 #  ALTERNATIVES OF SubStrings()  #
	#--------------------------------#

	def AllSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def AllPossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def AllPossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def AllPossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	def PossibleSubStringsCS(pCaseSitive)
		return This.SubStringsCS(pCaseSitive)

		def PossibleSubStringsCSQ(pCaseSitive)
			return This.SubStringsCSQ(pCaseSitive)

		def PossibleSubStringsCSQR(pCaseSitive, pcReturnType)
			return This.SubStringsCSQR(pCaseSitive, pcReturnType)

	#-- WITHOUT CASESENSITIVE

	def AllSubStrings()
		return This.SubStrings()

		def AllSubStringsQ()
			return This.SubStringsQ()

		def AllSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def AllPossibleSubStrings()
		return This.SubStrings()

		def AllPossibleSubStringsQ()
			return This.SubStringsQ()

		def AllPossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	def PossibleSubStrings()
		return This.SubStrings()

		def PossibleSubStringsQ()
			return This.SubStringsQ()

		def PossibleSubStringsQR(pcReturnType)
			return This.SubStringsQR(pcReturnType)

	  #----------------------------#
	 #  ALTERNATIVES OF Append()  #
	#----------------------------#

	def Add(pcOtherStr)
		This.Append(pcOtherStr)

		def AddQ(pcOtherStr)
			This.Add(pcOtherStr)
			return This

	def AddToEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddToEndQ(pcOtherStr)
			This.AddToEnd(pcOtherStr)
			return This

	def AddEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AddEndQ(pcOtherStr)
			This.AddEnd(pcOtherStr)
			return This

	#--

	def AppendEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendEndQ(pcOtherStr)
			This.AppendEnd(pcOtherStr)
			return This

	def AppendFromEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendFromEndQ(pcOtherStr)
			This.AppendFromEnd(pcOtherStr)
			return This

	def AppendAtEnd(pcOtherStr)
		This.Append(pcOtherStr)

		def AppendAtEndQ(pcOtherStr)
			This.AppendAtEnd(pcOtherStr)
			return This

	  #-------------------------------#
	 #   ALTERNATIVES OF Appended()  #
	#-------------------------------#

	def Added(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AddedToEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedFromEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	def AppendedAtEnd(pcOtherStr)
		return This.Appended(pcOtherStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Prepend()  #
	#----------------------------#

	def AddStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddStartQ(pcOtherStr)
			This.AddStart(pcOtherStr)
			return This

	def AddToStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddToStartQ(pcOtherStr)
			This.AddToStart(pcOtherStr)
			return This

	def AddAtStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddAtStartQ(pcOtherStr)
			This.AddAtStart(pcOtherStr)
			return This

	def AddFromStart(pcOtherStr)
		This.Prepend(pcOtherStr)

		def AddFromStartQ(pcOtherStr)
			This.AddFromStart(pcOtherStr)
			return This

	  #--------------------------------#
	 #   ALTERNATIVES OF Prepended()  #
	#--------------------------------#

	def AddedToStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedFromStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	def AppendedAtStart(pcOtherStr)
		return This.Prepended(pcOtherStr)

	  #------------------------------#
	 #  ALTERNATIVES OF FindMany()  #
	#------------------------------#

	def FindManySubStringsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindManySubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQ(pacSubStr, pCaseSensitive)
		
		def FindManySubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	def FindTheseSubStringsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCS(pacSubStr, pCaseSensitive)

		def FindTheseSubStringsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSQ(pacSubStr, pCaseSensitive)
		
		def FindTheseSubStringsCSQR(pacSubStr, pCaseSensitive, pcReturnType)
			return This.FindManyCSQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindManySubStrings(pacSubStr)
		return This.FindMany(pacSubStr)

		def FindManySubStringsQ(pacSubStr)
			return This.FindManyQ(pacSubStr)
		
		def FindManySubStringsQR(pacSubStr, pcReturnType)
			return This.FindManyQR(pacSubStr, pcReturnType)

	def FindTheseSubStrings(pacSubStr)
		return This.FindMany(pacSubStr)

		def FindTheseSubStringsQ(pacSubStr)
			return This.FindManyQ(pacSubStr)
		
		def FindTheseSubStringsQR(pacSubStr, pcReturnType)
			return This.FindManyQR(pacSubStr, pcReturnType)

	  #----------------------------------------#
	 #  ALTERNATIVES OF FindManyAsSections()  #
	#----------------------------------------#

	def FindTheseSubStringsAsSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyAsSectionsCS(pacSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindTheseSubStringsAsSections(pacSubStr)
		return This.FindManyAsSections(pacSubStr)

	  #---------------------------------------#
	 #  ALTERNATIVES OF FindAnySplittedBy()  #
	#---------------------------------------#

	def FindAnySeparatedByCS(pcSeparator, pCaseSensitive)
		return This.FindAnySplittedByCS(pcSeparator, pCaseSensitive)

		#< @FunctionFluentForms

		def FindAnySeparatedByCSQ(pcSeparator, pCaseSensitive)
			return This.FindAnySplittedByCSQR(pcSeparator, pCaseSensitive, :stzList)

		def FindAnySeparatedByCSQR(pcSeparator, pCaseSensitive, pcReturnType)
			return This.FindanySplittedByCSQR(pcSeparator, :CaseSensitive = TRUE, pcReturnType)				
	
		#>

	#-- WITHOUT CASESENSITIVITY

	def FindAnySeparatedBy(pcSeparator)
		return This.FindAnySplittedBy(pcSeparator)			

		#< @FunctionFluentForms

		def FindAnySeparatedByQ(pcSeparator)
			return This.FindAnySeparatedByQR(pcSeparator, :stzList)

		def FindAnySeparatedByQR(pcSeparator, pcReturnType)
			return This.FindAnySplittedByCSQR(pcSeparator, :CaseSensitive = TRUE, pcReturnType)				

		#>

	  #-------------------------------#
	 #  ALTERNATIVES OF FindManyZ()  #
	#-------------------------------#

	def TheseSubStringsAndTheirPositionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCSZ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirPositionsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSZQ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirPositionsCSQR(pacSubStr, pcReturnType)
			return This.FindManyCSZQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsAndTheirPositions(pacSubStr)
		return This.FindManyZ(pacSubStr)

		def TheseSubStringsAndTheirPositionsQ(pacSubStr)
			return This.FindManyZZQ(pacSubStr)

		def TheseSubStringsAndTheirPositionsQR(pacSubStr, pcReturnType)
			return This.FindManyZQR(pacSubStr, pcReturnType)

	  #--------------------------------#
	 #  ALTERNATIVES OF FindManyZZ()  #
	#--------------------------------#

	def TheseSubStringsAndTheirSectionsCS(pacSubStr, pCaseSensitive)
		return This.FindManyCSZZ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirSectionsCSQ(pacSubStr, pCaseSensitive)
			return This.FindManyCSZZQ(pacSubStr, pCaseSensitive)

		def TheseSubStringsAndTheirSectionsCSQR(pacSubStr, pcReturnType)
			return This.FindManyCSZZQR(pacSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def TheseSubStringsAndTheirSections(pacSubStr)
		return This.FindManyZZ(pacSubStr)

		def TheseSubStringsAndTheirSectionsQ(pacSubStr)
			return This.FindManyZZQ(pacSubStr)

		def TheseSubStringsAndTheirSectionsQR(pacSubStr, pcReturnType)
			return This.FindManyZZQR(pacSubStr, pcReturnType)

	  #------------------------------------#
	 #  ALTERNATIVES OF FindAsSections()  #
	#------------------------------------#

	def FindSubStringAsSectionsCS(pcSubStr, pCaseSensitive)
		return This.FindAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSubStringAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindAsSectionsCSQ(pcSubStr, pCaseSensitive)

		def FindSubStringAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringAsSections(pcSubStr)
		return This.FindAsSections(pcSubStr)

		def FindSubStringAsSectionsQ(pcSubStr)
			return This.FindAsSectionsQ(pcSubStr)

		def FindSubStringAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindAsSectionsQR(pcSubStr, pcReturnType)

	  #------------------------------#
	 #  ALTERNATIVES OF FindNext()  #
	#------------------------------#

	def FindNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)

	def FindNextSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def FindNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstNext(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstNext(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def NextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	def NextFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)

	def FirstNextOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindNext(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FindNextS(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def FindNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def PositionOfNextFirst(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
		
	def NextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)
	
	def NextFirstOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	def FirstNextOccurrence(pcSubStr, nStart)
		return This.FindNext(pcSubStr, nStart)

	  #----------------------------------#
	 #  ALTERNATIVES OF FindPrevious()  #
	#----------------------------------#

	def FindPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FindPreviousSCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def FindFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousFirstCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfFirstPreviousCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	def PreviousFirstOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)

	def FirstPreviousOccurrenceCS(pcSubStr, nStart, pCaseSensitive)
		return This.FindPreviousCS(pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FindPreviousS(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def FindFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfPreviousFirst(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PositionOfFirstPrevious(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)
	
	def PreviousFirstOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	def FirstPreviousOccurrence(pcSubStr, nStart)
		return This.FindPrevious(pcSubStr, nStart)

	  #-----------------------------#
	 #  ALTERNATIVES OF FindNth()  #
	#-----------------------------#

	def FindNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def PositionOfNthOccurrenceCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrencePositionCS(n, pcSubstr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def SubStringPositionByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def FindSubStringByOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	def NthOccurrenceCS(n, pcSubStr, pCaseSensitive)
		return This.FindNthCS(n, pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def PositionOfNthOccurrence(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrencePosition(n, pcSubstr)
		return This.FindNth(n, pcSubstr)

	def SubStringPositionByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def FindSubStringByOccurrence(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def Nth(n, pcSubStr)
		return This.FindNth(n, pcSubstr)

	def NthOccurrence(n, pcSubStr)
		return This.FindNthC(n, pcSubstr)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindNthNext()  #
	#---------------------------------#

	def FindNthNextOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNext( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNext(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNext(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrence( n, pcSubStr, nStart )
		return This.FindNthNext( n, pcSubStr, nStart )

	def FindNthNextOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def FindNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def FindNextNthS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def FindNthNextS(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def PositionOfNextNth(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)
		
	def NthNextOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	def NextNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthNext(n, pcSubStr, nStart)

	  #------------------------------------------#
	 #  ALTERNATIVES OF FindNthNextAsSection()  #
	#------------------------------------------#

	def FindNthNextOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthNextOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthNextAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindNextNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthNextAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNextNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthNextOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NextNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthNextAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthNextOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthNextAsSection( n, pcSubStr, nStart )

	def FindNthNextOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def FindNextNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def FindNthNextAsSectionS(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def PositionOfNextNthAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthNextAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)
	
	def NthNextOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	def NextNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthNextAsSection(n, pcSubStr, nStart)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindNthPrevious()  #
	#-------------------------------------#

	def FindNthPreviousOccurrenceCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindPreviousNthSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrence( n, pcSubStr, nStart )
		return This.FindNthPrevious( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def FindPreviousNthS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def FindNthPreviousS(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PositionOfPreviousNth(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def PositionOfNthPrevious(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)
	
	def NthPreviousOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	def PreviousNthOccurrence(n, pcSubStr, nStart)
		return This.FindNthPrevious(n, pcSubStr, nStart)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindNthPreviousAsSection()  #
	#----------------------------------------------#

	def FindNthPreviousOccurrenceAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindNthPreviousOccurrenceAsSectionSCS( n, pcSubStr, nStart, pCaseSensitive )
		return This.FindNthPreviousAsSectionCS( n, pcSubStr, nStart, pCaseSensitive )

	def FindPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)

	def FindPreviousNthAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def FindNthPreviousAsSectionSCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfPreviousNthAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PositionOfNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def NthPreviousOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	def PreviousNthOccurrenceAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
		return This.FindNthPreviousAsSectionCS(n, pcSubStr, nStart, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindNthPreviousOccurrenceAsSection( n, pcSubStr, nStart )
		return This.FindNthPreviousAsSection( n, pcSubStr, nStart )

	def FindNthPreviousOccurrenceAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def FindPreviousNthAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def FindNthPreviousAsSectionS(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfPreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PositionOfPreviousNthAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def PositionOfNthPreviousAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)
	
	def NthPreviousOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	def PreviousNthOccurrenceAsSection(n, pcSubStr, nStart)
		return This.FindNthPreviousAsSection(n, pcSubStr, nStart)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindAllNext()  #
	#---------------------------------#

	def FindAllNextSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)

	def FindNextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def NextPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindNextOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)

	def NextPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllNext(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllNextS(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def FindNextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	def NextOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def FindNextOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)
	
	def NextPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllNext(pcSubStr, pnStartingAt)

	  #-------------------------------------#
	 #  ALTERNATIVES OF FindAllPrevious()  #
	#-------------------------------------#

	def FindAllPreviousSCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def FindPreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousOccurrencesCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def PreviousPositionsCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	def FindPreviousOccurrencesOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)

	def PreviousPositionsOfSubStringCS(pcSubStr, pnStartingAt, pCaseSensitive)
		return This.FindAllPreviousCS(pcSubStr, pnStartingAt, pCaseSensitive)
	
	#-- WITHOUT CASESENSITIVITY

	def FindAllPreviousS(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def FindPreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	def PreviousOccurrences(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsC(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def FindPreviousOccurrencesOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)
	
	def PreviousPositionsOfSubString(pcSubStr, pnStartingAt)
		return This.FindAllPrevious(pcSubStr, pnStartingAt)

	  #---------------------------------#
	 #  ALTERNATIVES OF FindBetween()  #
	#---------------------------------#

	def FindThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisSubStringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)

	def FindSubstringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindSubstringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

		def FindSubstringBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

		def FindThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindThisBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, :stzList)

		def FindThisBetweenCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindBetweenCSQRQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	#--

	def FindThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def FindThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def FindSubstringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindSubstringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindSubstringBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.FindBetweenCS(pcSubStr, pacBounds, pacBounds, pCaseSensitive)
		ok

		return This.FindBetweenCS(pcSubStr, pacBounds, pCaseSensitive)

		def FindThisBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			return This.FindThisBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, :stzList)

		def FindThisBoundedByCSQR(pcSubStr, pacBounds, pCaseSensitive, pcReturnType)
			return This.FindThisSubStringBoundedByCSQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	#-- WITHOUT CASESENSITIVITY

	def FindThisSubStringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenQ(pcSubStr, pcBound1, pcBound2)

		def FindThisSubStringBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)

	def FindSubstringBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindSubstringBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubstringBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

		def FindSubstringBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBetween(pcSubStr, pcBound1, pcBound2)
		return This.FindBetween(pcSubStr, pcBound1, pcBound2)

		def FindThisBetweenQ(pcSubStr, pcBound1, pcBound2)
			return This.FindThisBetweenQR(pcSubStr, pcBound1, pcBound2, :stzList)

		def FindThisBetweenQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenCSQRQR(pcSubStr, pcBound1, pcBound2, :CaseSensitive = TRUE, pcReturnType)			

	#--

	def FindThisSubStringBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def FindThisSubStringBoundedByQ(pcSubStr, pacBounds)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindThisSubStringBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindSubStringBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def FindSubstringBoundedByQ(pcSubStr, pacBounds)
			return This.FindSubstringBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindSubstringBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	def FindThisBoundedBy(pcSubStr, pacBounds)
		if isString(pacBounds)
			return This.FindBetween(pcSubStr, pacBounds, pacBounds)
		ok

		return This.FindBetween(pcSubStr,  pacBounds[1], pacBounds[2])

		def FindThisBoundedByQ(pcSubStr, pacBounds)
			return This.FindThisBoundedByQR(pcSubStr, pacBounds, :stzList)

		def FindThisBoundedByQR(pcSubStr, pacBounds, pcReturnType)
			return This.FindThisSubStringBoundedByQR(pcSubStr, pacBounds, :CaseSensitive = TRUE, pcReturnType)			

	  #-------------------------------------------#
	 #  ALTERNATIVES OF FindBetweenAsSections()  #
	#-------------------------------------------#

	
	def FindThisBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindSubstringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindSubstringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

	def FindThisSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.FindSubstringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisSubStringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This.FindSubstringBetweenAsSectionsCSQ(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
		def FindThisSubStringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcBound2, pCaseSensitive, pcReturnType)
			return This.FindSubstringBetweenAsSectionsCSQR(pcSubStr, pcBound1, pcbound2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def FindThisBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindSubstringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
		def FindThisBetweenAsSectionsQ(pcSubStr, pcBound1, pcBound2)
			return This.FindSubstringBetweenAsSectionsQ(pcSubStr, pcBound1, pcbound2)
		
		def FindThisBetweenAsSectionsQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindSubstringBetweenAsSectionsQR(pcSubStr, pcBound1, pcbound2, pcReturnType)

	def FindThisSubStringBetweenAsSections(pcSubStr, pcBound1, pcBound2)
		return This.FindSubstringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

		def FindThisSubStringBetweenAsSectionsQ(pcSubStr, pcBound1, pcBound2)
			return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2)
	
		def FindThisSubStringBetweenAsSectionsQR(pcSubStr, pcBound1, pcBound2, pcReturnType)
			return This.FindBetweenCS(pcSubStr, pcBound1, pcBound2)

	  #-----------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceBetween()  #
	#-----------------------------------------------#

	def NumberOfOccurrencesBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def NumberOfSectionsBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def CountBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	def HaowManyBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfOccurrenceBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def NumberOfSectionsBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def CountBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	def HowManyBetween(pcSubStr, pcBound1, pcBound2)
		return This.NumberOfOccurrenceBetween(pcSubStr, pcBound1, pcBound2)

	  #------------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceXT()  #
	#------------------------------------------#

	def NumberOfOccurrencesCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrenceOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def NumberOfOccurrencesOfSubstringCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def CountCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	def HowManyCSXT(pcSubStr, pacBetween, pCaseSensitive)
		return This.NumberOfOccurrenceCSXT(pcSubStr, pacBetween, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NumberOfOccurrencesXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrenceOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def NumberOfOccurrencesOfSubstringXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def CountXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	def HowManyXT(pcSubStr, pacBetween)
		return This.NumberOfOccurrenceXT(pcSubStr, pacBetween)

	  #-----------------------------------------#
	 #  ALTERNATIVES OF NumberOfOccurrenceW()  #
	#-----------------------------------------#

	def CountW(pcCondition, pCaseSensitive)
		return This.NumberOfOccurrenceW(pcCondition, pCaseSensitive)

	def HowManyW(pcCondition, pCaseSensitive)
		return This.NumberOfOccurrenceW(pcCondition, pCaseSensitive)

	  #------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetween()  #
	#------------------------------------#

	def FindSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetween(pcBound1, pcBound2)
		return This.FindAnyBetween(pcBound1, pcBound2)

	def FindSubStringsBoundedBy(pcBound1, pcBound2)
		return This.FindBoundedByAsSections(pcBound1, pcBound2)

	  #--------------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetweenSections()  #
	#--------------------------------------------#

	def FindSubStringsBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBetweenAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByAsSectionsCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenAsSections(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSections(pcBound1, pcBound2)

	def FindSubStringsBoundedByAsSections(pcBound1, pcBound2)
		return This.FindAnyBoundedByAsSections(pcBound1, pcBound2)

	  #-------------------------------------------------------#
	 #  ALTERNATIVES OF FindNthSubStringBetweenAsSections()  #
	#-------------------------------------------------------#

	def FindNthBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindNthSubStringBoundedByAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindNthBoundedByAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthSubStringBetweenAsSectionsCS(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)
		
	def FindNthSubStringBoundedByAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)

	def FindNthBoundedByAsSections(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthSubStringBetweenAsSections(n, pcSubStr, pcBound1, pcbound2)

	  #---------------------------------------------------------#
	 #  ALTERNATIVES OF FindFirstSubStringBetweenAsSections()  #
	#---------------------------------------------------------#

	def FindFirstBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindFirstSubStringBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindFirstBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindFirstSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindFirstBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
	def FindFirstSubStringBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	def FindFirstBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindFirstSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	  #--------------------------------------------------------#
	 #  ALTERNATIVES OF FindLastSubStringBetweenAsSections()  #
	#--------------------------------------------------------#

	def FindLastBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindLastSubStringBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindLastBoundedByAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindLastSubStringBetweenAsSectionsCS(pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindLastBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)
		
	def FindLastSubStringBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	def FindLastBoundedByAsSections(pcSubStr, pcBound1, pcbound2)
		return This.FindLastSubStringBetweenAsSections(pcSubStr, pcBound1, pcbound2)

	  #---------------------------------------------#
	 #  ALTERNATIVES OF FindBetweenAsSectionsIB()  #
	#---------------------------------------------#

	def FindNthSubStringBetweenAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		
	def FindNthSubStringBoundedByAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	def FindNthBoundedByAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)
		return This.FindNthBetweenAsSectionsCSIB(n, pcSubStr, pcBound1, pcbound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindNthSubStringBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		
	def FindNthSubStringBoundedByAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)

	def FindNthBoundedByAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)
		return This.FindNthBetweenAsSectionsIB(n, pcSubStr, pcBound1, pcbound2)

	  #--------------------------------------#
	 #  ALTERNATIVES OF FindAnyBetweenIB()  #
	#--------------------------------------#

	def FindSubStringsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenIB(pcBound1, pcBound2)
		return This.FindAnyBetweenIB(pcBound1, pcBound2)

	def FindSubStringsBoundedByIB(pcBound1, pcBound2)
		return This.FindAnyBoundedByIB(pcBound1, pcBound2)

	  #--------------------------------------------------#
	 #  ALTERNATIVES OF FindAnyBoundedByAsSectionsIB()  #
	#--------------------------------------------------#

	def FindSubStringsBetweenAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.FindanyBetweenAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)

	def FindSubStringsBoundedByAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.FindAnyBoundedByAsSectionsCSIB(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def FindSubStringsBetweenAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBetweenAsSectionsIB(pcBound1, pcBound2)

	def FindSubStringsBoundedByAsSectionsIB(pcBound1, pcBound2)
		return This.FindAnyBoundedByAsSectionsIB(pcBound1, pcBound2)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF RemoveSubStringBetweenIB()  #
	#----------------------------------------------#

	def RemoveThisBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSubStringBetweenCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveSubStringBetweenCSIB(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisSubStringBetweenCSIBQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenCSIB(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSubStringBetweenCSIB(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveThisSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveThisSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveSubStringBetweenCSIB(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveSubStringBoundedByCSIBQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveSubStringBoundedByCSIB(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenIB(pcSubStr,pcBound1, pcBound2)

		def RemoveThisBetweenIBQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBetweenIB(pcSubStr, pcBound1, pcBound2)
		This.RemoveSubStringBetweenIB(pcSubStr,pcBound1, pcBound2)

		def RemoveThisSubStringBetweenIBQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetweenIB(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBoundedByIB(pcSubStr, pacBounds)
		This.RemoveSubStringBetweenIB(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveThisSubStringBoundedByIBQ(pcSubStr, pacBounds)
			This.RemoveThisSubStringBoundedByIB(pcSubStr, pacBounds)
			return This

	#--

	def RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
		This.RemoveSubStringBetweenIB(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveSubStringBoundedByIBQ(pcSubStr, pacBounds)
			This.RemoveSubStringBoundedByIB(pcSubStr, pacBounds)
			return This

	  #-----------------------------------#
	 #  ALTERNATIVES OF NthBetweenIBZ()  #
	#-----------------------------------#

	def NthSubStringBetweenCSIBZ(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCSIBZ(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIBZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZ(n, pcBound1, pcBound2)

	  #------------------------------------#
	 #  ALTERNATIVES OF NthBetweenIBZZ()  #
	#------------------------------------#

	def NthSubStringBetweenCSIBZZ(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCSIBZZ(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIBZZ(n, pcBound1, pcBound2)
		return This.NthBetweenIBZZ(n, pcBound1, pcBound2)

	  #----------------------------------#
	 #  ALTERNATIVES OF NthBetweenIB()  #
	#----------------------------------#
	
	def NthSubStringBetweenCSIB(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCSIB(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenIB(n, pcBound1, pcBound2)
		return This.NthBetweenIB(n, pcBound1, pcBound2)

	  #----------------------------------#
	 #  ALTERNATIVES OF NthBetweenZZ()  #
	#----------------------------------#

	def NthSubStringBetweenCSZZ(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCSZZ(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenZZ(n, pcBound1, pcBound2)
		return This.NthBetweenZZ(n, pcBound1, pcBound2)


	  #---------------------------------#
	 #  ALTERNATIVES OF NthBetweenZ()  #
	#---------------------------------#

	def NthSubStringBetweenCSZ(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCSZ(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetweenZ(n, pcBound1, pcBound2)
		return This.NthBetweenZ(n, pcBound1, pcBound2)

	  #--------------------------------#
	 #  ALTERNATIVES OF NthBetween()  #
	#--------------------------------#

	def NthSubStringBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)
		return This.NthBetweenCS(n, pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def NthSubStringBetween(n, pcBound1, pcBound2)
		return This.NthBetween(n, pcBound1, pcBound1)


	  #-------------------------------------------------#
	 #  ALTERNATIVES OF NumberOfSubStringsBoundedBy()  #
	#-------------------------------------------------#

	def CountSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def HowManySubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def HowManySubStringBoundedByCS(pacBounds, pCaseSensitive)
		return This.NumberOfSubStringsBoundedByCS(pacBounds, pCaseSensitive)

	def NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		return This.NumberOfSubStringsBoundedByCS(pacBounds[1], pacBounds[2], pCaseSensitive)

	def CountSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def HowManySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	def HowManySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def CountSubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	def HowManySubStringsBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	def HowManySubStringBoundedBy(pacBounds)
		return This.NumberOfSubStringsBoundedBy(pacBounds)

	#--

	def NumberOfSubStringsBetween(pcBound1, pcBound2)
		if isList(pcBound2) and Q(pcBound2).IsAndNamedParam()
			pcBound2 = pcBound2[2]
		ok

		return This.NumberOfSubStringsBoundedBy(pacBounds[1], pacBounds[2])

	def CountSubStringsBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetween(pcBound1, pcBound2)

	def HowManySubStringsBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2)

	def HowManySubStringBetween(pcBound1, pcBound2)
		return This.NumberOfSubStringsBetweenCS(pcBound1, pcBound2)

	  #----------------------------------------#
	 #  ALTERNATIVES OF SubstringsBetweenU()  #
	#----------------------------------------#

	def UniqueSubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def UniqueSubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def UniqueSubStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSubstringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SubStringsBoundedByWithoutDuplicationCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def SubStringsBoundedByWithoutDuplicationCSQ(pacBounds, pCaseSensitive)
			return This.UniqueSubStringsBoundedByCSQ(pacBounds, pCaseSensitive)

		def SubStringsBoundedByWithoutDuplicationCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.UniqueSubstringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def UniqueSectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def UniqueSectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def UniqueSectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def UniqueSectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SectionsWithoutDuplicationBetwenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsWithoutDuplicationBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)


		def SectionsWithoutDuplicationBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.UniqueSectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	#==

	def SubStringsBoundedByUCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive, :stzList)

		def SubStringsBoundedByUCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SubstringsBoundedByUCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#--

	def SectionsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenUCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenUCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(ppacBounds[1], pacBounds[2], pCaseSensitive)

		def USectionsBetweenUCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SectionsBoundedByUCS(pacBounds, pCaseSensitive)
		return This.SubstringsBetweenUCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SectionsBoundedByUCSQ(pacBounds, pCaseSensitive)
			return This.SubstringsBetweenUCSQ(pacBounds[1], pacBounds[2], pCaseSensitive)

		def SectionsBoundedByUCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubstringsBetweenUCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def UniqueSubStringsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

	#--

	def UniqueSubStringsBoundedBy(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2], :stzList)

		def UniqueSubStringsBoundedByQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def UniqueSubstringsBoundedByQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#--

	def UniqueSectionsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def UniqueSectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def UniqueSectionsBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsWithoutDuplicationBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsWithoutDuplicationBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def SectionsWithoutDuplicationBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def UniqueSectionsBoundedBy(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2])

		def UniqueSectionsBoundedByQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def UniqueSectionsBoundedByQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsWithoutDuplicationBoundedBy(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsWithoutDuplicationBoundedByQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def SectionsWithoutDuplicationBoundedByQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#==

	def SubStringsBoundedByU(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2], :stzList)

		def SubStringsBoundedByUQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def SubstringsBoundedByUQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	#--

	def SectionsBetweenU(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenU(pcSubStr1, pcSubStr2)

		def SectionsBetweenUQ(pcSubStr1, pcSubStr2)
			return This.SubstringsBetweenUQ(ppacBounds[1], pacBounds[2])

		def USectionsBetweenUQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SectionsBoundedByU(pacBounds)
		return This.SubstringsBetweenU(pacBounds[1], pacBounds[2])

		def SectionsBoundedByUQ(pacBounds)
			return This.SubstringsBetweenUQ(pacBounds[1], pacBounds[2])

		def SectionsBoundedByUQR(pacBounds, pcReturnType)
			return This.SubstringsBetweenUQR(pacBounds[1], pacBounds[2], pcReturnType)

	  #-------------------------------#
	 #  ALTERNATIVES OF BetweenIB()  #
	#-------------------------------#

	def AnyBetweenCSIB(p1, p2, pCaseSensitive)
		return This.BetweenCSIB(p1, p2, pCaseSensitive)

		def AnyBetweenCSIBQ(p1, p2, pCaseSensitive)
			return This.BetweenCSIBQ(p1, p2, pCaseSensitive)

		def AnyBetweenCSIBQR(p1, p2, pCaseSensitive, pcReturnType)
			return This.BetweenCSIBQR(p1, p2, pCaseSensitive, pcReturnType)

	def BoundedByCSIB(pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.BetweenCSIB(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			return This.BetweenCSIB(pacBounds[1], pacBounds[2], pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or a pair of strings.")
		ok

		def BoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.BoundedByCSIBQR(pacBounds, pCaseSensitive, :stzList)
	
		def BoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.BetweenCSIBQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)
	
	def AnyBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.BetweenCSIB(pacBounds[1], pacBounds[2], pCaseSensitive)
	
		def AnyBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.AnyBoundedByCSIBQR(pacBounds, pCaseSensitive, :stzList)
	
		def AnyBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.BetweenCSIBQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetweenIB(p1, p2)
		return This.BetweenIB(p1, p2)

		def AnyBetweenIBQ(p1, p2)
			return This.BetweenIBQ(p1, p2)

		def AnyBetweenIBQR(p1, p2, pcReturnType)
			return This.BetweenIBQR(p1, p2, pcReturnType)

	def BoundedByIB(pacBounds)
		return This.BoundedByCSIB(pacBounds, :CaseSensitive = TRUE)
	
		def BoundedByIBQ(pacBounds)
			return This.BoundedByIBQR(pacBounds, :stzList)
	
		def BoundedByIBQR(pacBounds, pcReturnType)
			return This.BetweenIBQR(pacBounds[1], pacBounds[2], pcReturnType)
	
	def AnyBoundedByIB(pacBounds, pCaseSensitive)
		return This.BoundedByIB(pacBounds)
	
		def AnyBoundedByIBQ(pacBounds)
			return This.AnyBoundedByIBQR(pacBounds, :stzList)
	
		def AnyBoundedByIBQR(pacBounds, pcReturnType)
			return This.BetweenCSIBQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	  #------------------------------------------#
	 #  ALTERNATIVES OF SubStrtingsBetweenIB()  #
	#------------------------------------------#

	def AnySubStringBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	#--

	def AnySubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	def SectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SubstringsBoundedByCS(pacBounds, pCaseSensitive)

		def SectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def AnySectionBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionBoundedByCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionsBoundedByCS(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCS(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		if isString(pacBounds)
			return This.SubStringsBetweenCSIB(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			return This.SubStringsBetweenCSIB(pacBounds[1], pacBounds[2], pCaseSensitive)
		ok

		def SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBQR(pacBounds, pCaseSensitive, :stzList)

		def SubStringsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSIBQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#--

	def AnySubStringBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySubStringBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)

		def AnySubStringBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySubStringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubStringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySubStringsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySubStringsBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.SubStringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSIBQ(pacBounds, pCaseSensitive)

		def AnySubStringsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SubstringsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)

		def SectionsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	def SectionsBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.SubstringsBoundedByCSIB(pacBounds, pCaseSensitive)

		def SectionsBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SubStringsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

	#--

	def AnySectionBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSIBQ(pacBounds, pCaseSensitive)

		def AnySectionBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)

	#--

	def AnySectionsBetweenCSIB(pcSubStr1, pcSubStr2, pCaseSensitive)
		return This.SectionsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SectionsBetweenCSIBQ(pcSubStr1, pcSubStr2, pCaseSensitive)

		def AnySectionsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
			return This.SectionsBetweenCSIBQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def AnySectionsBoundedByCSIB(pacBounds, pCaseSensitive)
		return This.SectionsBoundedByCSIB(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSIBQ(pacBounds, pCaseSensitive)
			return This.SectionsBoundedByCSQ(pacBounds, pCaseSensitive)

		def AnySectionsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SectionsBoundedByCSIBQR(pacBounds, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnySubStringBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def SubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByCSIB(pacBounds, :CaseSensitive = TRUE)
		
		def SubStringsBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQR(pacBounds, :stzList)

		def SubStringsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByCSIBQR(pacBounds, :CaseSensitive = TRUE, pcReturnType)

	def AnySubStringBoundedByIB(pacBounds)
		return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQ(pacBounds)

		def AnySubStringBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByIBQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubStringsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringsBoundedByIB(pacBounds)
		return This.SubStringsBoundedByIB(pacBounds)

		def AnySubStringsBoundedByIBQ(pacBounds)
			return This.SubStringsBoundedByIBQ(pacBounds)

		def AnySubStringsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByIBQR(pacBounds,  pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SubstringsBetweenIB(pcSubStr1, pcSubStr2)

		def SectionsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

	def SectionsBoundedByIB(pacBounds)
		return This.SubstringsBoundedByIB(pacBounds)

		def SectionsBoundedByIBQ(pacBounds)
			return This.SubStringsBetweenIBQ(pcSubStr1, pcSubStr2)

	#--

	def AnySectionBetweenIB(pcSubStr1, pcSubStr2)
		return This.SectionsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySectionBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySectionBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionBoundedByIB(pacBounds)
		return This.SectionsBoundedByIB(pacBounds)

		def AnySectionBoundedByIBQ(pacBounds)
			return This.SectionsBoundedByIBQ(pacBounds)

		def AnySectionBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByIBQR(pacBounds,  pcReturnType)

	#--

	def AnySectionsBetweenIB(pcSubStr1, pcSubStr2)
		return This.SectionsBetweenIB(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenIBQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenIBQ(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenIBQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionsBoundedByIB(pacBounds)
		return This.SectionsBoundedByIB(pacBounds)

		def AnySectionsBoundedByIBQ(pacBounds)
			return This.SectionsBoundedByIBQ(pacBounds)

		def AnySectionsBoundedByIBQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySubStringBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringBoundedBy(pacBounds)
		return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQ(pacBounds)

		def AnySubStringBoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySubStringsBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SubStringsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySubStringsBoundedBy(pacBounds)
		return This.SubStringsBoundedBy(pacBounds)

		def AnySubStringsBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQ(pacBounds)

		def AnySubStringsBoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBoundedByQR(pacBounds,  pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def SectionsBetween(pcSubStr1, pcSubStr2)
		return This.SubstringsBetween(pcSubStr1, pcSubStr2)

		def SectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

	def SectionsBoundedBy(pacBounds)
		return This.SubstringsBoundedBy(pacBounds)

		def SectionsBoundedByQ(pacBounds)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

	#--

	def AnySectionBetween(pcSubStr1, pcSubStr2)
		return This.SectionsBetween(pcSubStr1, pcSubStr2)

		def AnySectionBetweenQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySectionBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionBoundedBy(pacBounds)
		return This.SectionsBoundedBy(pacBounds)

		def AnySectionBoundedByQ(pacBounds)
			return This.SectionsBoundedByQ(pacBounds)

		def AnySectionBoundedByQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	#--

	def AnySectionsBetween(pcSubStr1, pcSubStr2)
		return This.SectionsBetween(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenQ(pcSubStr1, pcSubStr2)
			return This.SectionsBetweenQ(pcSubStr1, pcSubStr2)

		def AnySectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)
			return This.SectionsBetweenQR(pcSubStr1, pcSubStr2,  pcReturnType)

	def AnySectionsBoundedBy(pacBounds)
		return This.SectionsBoundedBy(pacBounds)

		def AnySectionsBoundedByQ(pacBounds)
			return This.SectionsBoundedByQ(pacBounds)

		def AnySectionsBoundedByQR(pacBounds,  pcReturnType)
			return This.SectionsBoundedByQR(pacBounds,  pcReturnType)

	  #---------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetween()  #
	#---------------------------------------#

	def AnyBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)
			return This.SubStringsBetweenCS(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnyBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)
				return This.SubStringsBetweenCSQ(pcSubStr1, pcSubStr2, pCaseSensitive)

			def AnyBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)
				return This.SubStringsBetweenCSQR(pcSubStr1, pcSubStr2, pCaseSensitive, pcReturnType)

	def BoundedByCS(pacBounds, pCaseSensitive)
		acResult = []

		if isString(pacBounds)
			acResult = This.SubStringsBetweenCS(pacBounds, pacBounds, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			acResult = This.SubStringsBetweenCS(pacBounds[1], pacBounds[2], pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
		ok

		return acResult

		def BoundedByCSQ(pacBounds, pCaseSensitive)
			return This.BoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def BoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def AnyBoundedByCS(pacBounds, pCaseSensitive)
		return This.BoundedByCS(pacBounds, pCaseSensitive)

		def AnyBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.AnyBoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def AnyBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	def SubStringsBoundedByCS(pacBounds, pCaseSensitive)
		return This.BoundedByCS(pacBounds, pCaseSensitive)

		def subStringsBoundedByCSQ(pacBounds, pCaseSensitive)
			return This.SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, :stzList)
	
		def SubStringsBoundedByCSQR(pacBounds, pCaseSensitive, pcReturnType)
			return This.SubStringsBetweenCSQR(pacBounds[1], pacBounds[2], pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetween(pcSubStr1, pcSubStr2)
		return This.SubStringsBetween(pcSubStr1, pcSubStr2)

		def AnyBetweenQ(pcSubStr1, pcSubStr2)
			return This.SubStringsBetweenQ(pcSubStr1, pcSubStr2)

		def AnyBetweenQR(pcSubStr1, pcSubStr2, pcReturnType)
			return This.SubStringsBetweenCQR(pcSubStr1, pcSubStr2, pcReturnType)

	def BoundedBy(pacBounds)
		return This.SubStringsBoundedByCS(pacBounds, :CaseSensitive = TRUE)

		def BoundedByQ(pacBounds)
			return This.BoundedByQR(pacBounds, :stzList)

		def BoundedByQR(pacBounds,  pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2],  pcReturnType)

	def AnyBoundedBy(pacBounds)
		return This.BoundedBy(pacBounds)

		def AnyBoundedByQ(pacBounds)
			return This.AnyBoundedByQR(pacBounds, :stzList)
	
		def AnyBoundedByQR(pacBounds, pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2], pcReturnType)

	def SubStringsBoundedBy(pacBounds)
		return This.BoundedBy(pacBounds)

		def subStringsBoundedByQ(pacBounds)
			return This.SubStringsBoundedByQR(pacBounds, :stzList)
	
		def SubStringsBoundedByQR(pacBounds, pcReturnType)
			return This.SubStringsBetweenQR(pacBounds[1], pacBounds[2], pcReturnType)

	  #----------------------------------------------#
	 #  ALTERNATIVES OF FindSplittedByAsSections()  #
	#----------------------------------------------#

	def FindSeparatedByAsSectionsCS(pcSubStr, pCaseSensitive)
		return This.FindSplittedByAsSectionsCS(pcSubStr, pCaseSensitive)

		def FindSeparatedByAsSectionsCSQ(pcSubStr, pCaseSensitive)
			return This.FindSeparatedByAsSectionsCSQR(pcSubStr, pCaseSensitive, :stzList)

		def FindSeparatedByAsSectionsCSQR(pcSubStr, pCaseSensitive, pcReturnType)
			return This.FindSplittedByAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)				

	#-- WITHOUT CASESENSITIVITY

	def FindSeparatedByAsSections(pcSubStr)
		return This.FindSplittedByAsSectionsCS(pcSubStr, :CaseSensitive = TRUE)

		def FindSeparatedByAsSectionsQ(pcSubStr)
			return This.FindSeparatedByAsSectionsQR(pcSubStr, :stzList)

		def FindSeparatedByAsSectionsQR(pcSubStr, pcReturnType)
			return This.FindSplittedByAsSectionsCSQR(pcSubStr, :CaseSensitive = TRUE, pcReturnType)				

	  #------------------------------------#
	 #  ALTERNATIVES OF AnyDeepBetween()  #
	#------------------------------------#
	# TODO: Add BoundedBy alternatives!

	def DeepSubStringsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSubStringBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSubStringsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionssBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSectionBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectiongBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSectionsBetweenCS(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCS(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

	def AnyDeepSubStringBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSubStringsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

	def AnyDeepSectionBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSectiongBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSectionBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSectionsBetween(pcChar1, pcChar2)
		return This.AnyDeepBetween(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenQ(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenQR(pcChar1, pcChar2, pcReturnType)

	  #-------------------------------------#
	 # ALTERNATIVES OF AnyDeepBetweenIB()  #
	#-------------------------------------#

	def DeepSubStringsBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSubStringBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSubStringsBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSubStringsBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

	def AnyDeepSectionBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectiongBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	def AnyDeepSectionsBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)
		return This.AnyDeepBetweenCSIB(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)
			return This.AnyDeepBetweenCSIBQ(pcChar1, pcChar2, pCaseSensitive)

		def AnyDeepSectionsBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)
			return This.AnyDeepBetweenCSIBQR(pcChar1, pcChar2, pCaseSensitive, pcReturnType)

	#-- WITHOUT CASESENSITIVITY

	def DeepSubStringsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

	def AnyDeepSubStringBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSubStringBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSubStringsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSubStringsBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	#-- Allowing the use of "SECTION" along with "SUBSTRING"

	def DeepSectionsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

	def AnyDeepSectionBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSectiongBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSectionBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	def AnyDeepSectionsBetweenIB(pcChar1, pcChar2)
		return This.AnyDeepBetweenIB(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenIBQ(pcChar1, pcChar2)
			return This.AnyDeepBetweenIBQ(pcChar1, pcChar2)

		def AnyDeepSectionsBetweenIBQR(pcChar1, pcChar2, pcReturnType)
			return This.AnyDeepBetweenIBQR(pcChar1, pcChar2, pcReturnType)

	  #---------------------------------------#
	 #  ALTERNATIVES OF RemoveSubStringAt()  #
	#---------------------------------------#

	def RemoveAtCS(n, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		def RemoveAtCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveAtCS(n, pcSubStr, pCaseSensitive)
			return This

	def RemoveAtPositionCS(n, pcSubStr, pCaseSensitive)
		This.RemoveSubStringAtCS(n, pcSubStr, pCaseSensitive)

		def RemoveAtPositionCSQ(n, pcSubStr, pCaseSensitive)
			This.RemoveAtPositionCS(n, pcSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAt(n, pcSubStr)
		This.RemoveSubStringAtPosition(n, pcSubStr)

		def RemoveAtQ(n, pcSubStr)
			This.RemoveAt(n, pcSubStr)
			return This

	def RemoveAtPosition(n, pcSubStr)
		This.RemoveSubStringAtPosition(n, pcSubStr)

		def RemoveAtPositionQ(n, pcSubStr)
			This.RemoveAtPosition(n, pcSubStr)
			return This

	  #----------------------------------#
	 #  ALTERNATIVES OF ContainsSome()  #
	#----------------------------------#

	def ContainsOneOrMoreOccurrencesCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsOneOrMoreOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsSomeOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	 def ContainsOneOrMoreOfTheseSubStringsCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsSomeOfTheseSubStringsCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	def ContainsOneOrMoreSubStringOfCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	def ContainsOneOrMoreSubStringOfTheseCS(paSubStr, pCaseSensitive)
		return This.ContainsSomeCS(paSubStr, pCaseSensitive)

	#--

	def ContainsManyOccurrencesCS(pcSubstr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)
				
	def ContainsSomeOccurrencesCS(pcSubstr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)
				
	def ContainsMoreThenOneCS(pcSubStr, pCaseSensitive)
		return This.ContainsSomeCS(pcSubstr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def ContainsOneOrMoreOccurrences(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsOneOrMoreOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsSomeOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	 def ContainsOneOrMoreOfTheseSubStrings(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsSomeOfTheseSubStrings(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	def ContainsOneOrMoreSubStringOf(paSubStr)
		return This.ContainsSome(paSubStr)

	def ContainsOneOrMporeSubStringOfThese(paSubStr)
		return This.ContainsSome(paSubStr)

	#--

	def ContainsManyOccurrences(pcSubstr)
		return This.ContainsSome(pcSubstr)
		
	def ContainsSomeOccurrences(pcSubstr)
		return This.ContainsSome(pcSubstr)
				
	def ContainsMoreThenOne(pcSubStr)
		return This.ContainsSome(pcSubstr)
	
	  #--------------------------------------#
	 #  ALTERNATIVES OF RemoveAnyBetween()  #
	#--------------------------------------#

	def RemoveSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveAnyBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnyBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnyBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBoundedByCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBoundedByCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBoundedByCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCS(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBetweenCSQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBetweenCS(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSectionsBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveBetweenByCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveSectionsBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveSectionsBoundedByCS(paBounds, pCaseSensitive)
			return This

	def RemoveAnySectionBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveAnyBetweenCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveAnySectionBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveAnySectionBoundedByCS(paBounds, pCaseSensitive)
			return This

	def RemoveAnySectionsBoundedByCS(paBounds, pCaseSensitive)
		This.RemoveBetweenByCS(paBounds[1], paBounds[2], pCaseSensitive)

		def RemoveAnySectionsBoundedByCSQ(paBounds, pCaseSensitive)
			This.RemoveAnySectionsBoundedByCS(paBounds, pCaseSensitive)
			return This
	
	#-- WTHOUT CASESENSITIVITY

	def RemoveSubStringsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveSubStringsBetweenQ(pcBound1, pcBound2)
			This.RemoveSubStringsBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySubStringBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySubStringsBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBetween(pcBound1, pcBound2)
			return This

	#--

	def RemoveAnyBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnyBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnyBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveSubStringsBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveSubStringsBoundedByQ(pcBound1, pcBound2)
			This.RemoveSubStringsBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnySubStringBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBoundedBy(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBoundedBy(pcBound1, pcBound2)
		This.RemoveBoundedBy(pcBound1, pcBound2)

		def RemoveAnySubStringsBoundedByQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBoundedBy(pcBound1, pcBound2)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveSectionsBetweenQ(pcBound1, pcBound2)
			This.RemoveSectionsBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySectionBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySectionBetween(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBetween(pcBound1, pcBound2)
		This.RemoveAnyBetween(pcBound1, pcBound2)

		def RemoveAnySectionsBetweenQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBetween(pcBound1, pcBound2)
			return This

	#--

	def RemoveSectionsBoundedBy(paBounds)
		This.RemoveBetweenBy(paBounds[1], paBounds[2])

		def RemoveSectionsBoundedByQ(paBounds)
			This.RemoveSectionsBoundedBy(paBounds)
			return This

	def RemoveAnySectionBoundedBy(paBounds)
		This.RemoveAnyBetween(paBounds[1], paBounds[2])

		def RemoveAnySectionBoundedByQ(paBounds)
			This.RemoveAnySectionBoundedBy(paBounds)
			return This

	def RemoveAnySectionsBoundedBy(paBounds)
		This.RemoveBetweenBy(paBounds[1], paBounds[2])

		def RemoveAnySectionsBoundedByQ(paBounds)
			This.RemoveAnySectionsBoundedBy(paBounds)
			return This

	  #---------------------------------------#
	 #  ALTERNATIVES OF AnyBetweenRemoved()  #
	#---------------------------------------#

	def SubStringsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def AnyBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def SubStringsBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def AnySubStringBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	def AnySubStringsBoundedByRemovedCS(paBounds, pCaseSensitive)
		return This.AnyBetweenRemovedCS(paBounds[1], paBounds[2], pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#--

	def SectionsBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBoundedByRemovedCS(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCS(pcBound1, pcBound2, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def SubStringsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySubStringBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySubStringsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	#--

	def AnyBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def SubStringsBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def AnySubStringBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	def AnySubStringsBoundedByRemoved(paBounds)
		return This.AnyBetweenRemoved(paBounds[1], paBounds[2])

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionsBetweenRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	#--

	def SectionsBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	def AnySectionsBoundedByRemoved(pcBound1, pcBound2)
		return This.AnyBetweenRemoved(pcBound1, pcBound2)

	  #-----------------------------------#
	 #  ALTERNATIVES OF RemoveBetween()  #
	#-----------------------------------#

	def RemoveThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveThisBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveThisSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pCaseSensitive)

		def RemoveSubStringBoundedByCSQ(pcSubStr, pacBounds, pCaseSensitive)
			This.RemoveSubStringBoundedByCS(pcSubStr, pacBounds, pCaseSensitive)
			return This

	#--

	def RemoveThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
		This.RemoveBetweenCS(pcSubStr,pcBound1, pcBound2, pCaseSensitive)

		def RemoveThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveThisBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveThisBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveThisBetween(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveThisSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveThisSubStringBoundedByQ(pcSubStr, pacBounds)
			This.RemoveThisSubStringBoundedBy(pcSubStr, pacBounds)
			return This

	#--

	def RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This

	def RemoveSubStringBoundedBy(pcSubStr, pacBounds)
		This.RemoveBetween(pcSubStr, pacBounds[1], pacBounds[2])

		def RemoveSubStringBoundedByQ(pcSubStr, pacBounds)
			This.RemoveSubStringBoundedBy(pcSubStr, pacBounds)
			return This

	#--

	def RemoveThisSubStringBetween(pcSubStr, pcBound1, pcBound2)
		This.RemoveBetween(pcSubStr,pcBound1, pcBound2)

		def RemoveThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2)
			This.RemoveSubStringBetween(pcSubStr, pcBound1, pcBound2)
			return This

	  #--------------------------------------#
	 #  ALTERNATIVES OF RemoveAnyBetween()  #
	#--------------------------------------#

	def RemoveSubStringsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSubStringsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSubStringsBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSubStringsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySubStringsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySubStringsBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySubStringsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBetweenCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	#--

	def RemoveSectionsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveSectionsBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveSectionsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	def RemoveAnySectionsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
		This.RemoveAnyBetweenCSIB(pcBound1, pcBound2, pCaseSensitive)

		def RemoveAnySectionsBoundedByCSIBQ(pcBound1, pcBound2, pCaseSensitive)
			This.RemoveAnySectionsBoundedByCSIB(pcBound1, pcBound2, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveSubStringsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSubStringsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveSubStringsBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBetweenIB(pcBound1, pcBound2)
			return This

	#--

	def RemoveSubStringsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSubStringsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveSubStringsBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySubStringsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySubStringsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySubStringsBoundedByIB(pcBound1, pcBound2)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def RemoveSectionsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSectionsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveSectionsBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionBetweenIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBetweenIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionsBetweenIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBetweenIB(pcBound1, pcBound2)
			return This

	#--

	def RemoveSectionsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveSectionsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveSectionsBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionBoundedByIB(pcBound1, pcBound2)
			return This

	def RemoveAnySectionsBoundedByIB(pcBound1, pcBound2)
		This.RemoveAnyBetweenIB(pcBound1, pcBound2)

		def RemoveAnySectionsBoundedByIBQ(pcBound1, pcBound2)
			This.RemoveAnySectionsBoundedByIB(pcBound1, pcBound2)
			return This

	  #-----------------------------------------#
	 #  ALTERNATIVES OF AnyBetweenRemovedIB()  #
	#-----------------------------------------#

	def SubStringsBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	#--

	def AnyBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def SubStringsBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySubStringsBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	#--

	def SectionsBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	def AnySectionsBoundedByRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)
		return This.AnyBetweenRemovedCSIB(pcBound1, pcBound2, pCaseSensitive)

	  #-----------------------------#
	 #  ALTERNATIVES OF Replace()  #
	#-----------------------------#

	def ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

		def ReplaceAllOccurrencesCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
		This.ReplaceCS(pcSubStr, pcNewSubStr, pCaseSensitive)

			def ReplaceAllOccurrencesOfSubstringCSQ(pcSubStr, pcNewSubStr, pCaseSensitive)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr, pCaseSensitive)
			return This		

	#-- WIHTOUT CASESENSITIVITY

	def ReplaceAll(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllQ(pcSubStr, pcNewSubStr)
			This.ReplaceAll(pcSubStr, pcNewSubStr)
			return This

	def ReplaceSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceSubstring(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
		if isList(pcSubStr) and Q(pcSubStr).IsOfNamedParam()
			pcSubStr = pcSubStr[2]
		ok

		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrences(pcSubStr, pcNewSubStr)
			return This

	def ReplaceAllOccurrencesOfSubstring(pcSubStr, pcNewSubStr)
		This.Replace(pcSubStr, pcNewSubStr)

		def ReplaceAllOccurrencesOfSubstringQ(pcSubStr, pcNewSubStr)
			This.ReplaceAllOccurrencesOfSubstringCS(pcSubStr, pcNewSubStr)
			return This		

	  #------------------------------------#
	 #  ALTERNATIVES OF ReplaceBetween()  #
	#------------------------------------#

	def ReplaceThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def ReplaceThisSubStringBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisSubStringBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

	def ReplaceThisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
		This.ReplaceBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)

		def ReplaceThisBetweenCSQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			This.ReplacethisBetweenCS(pcSubStr, pcBound1, pcBound2, pcNewSubstr, pCaseSensitive)
			return This

	#--

	def ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubStr, pCaseSensitive)
		return This.ReplaceThisSubStringBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr, pCaseSensitive)

		def ReplaceThisSubStringBoundedByCSQ(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisSubStringBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This

	def ReplaceThisBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
		This.ReplaceThisSubStringBetweenCS(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr, pCaseSensitive)

		def ReplaceThisBoundedByCSQ(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			This.ReplaceThisBoundedByCS(pcSubStr, pacBounds, pcNewSubstr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceThisSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def ReplaceThisSubStringBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplaceThisSubStringBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

	def ReplaceThisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
		This.ReplaceBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)

		def ReplaceThisBetweenQ(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			This.ReplacethisBetween(pcSubStr, pcBound1, pcBound2, pcNewSubstr)
			return This

	#--

	def ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubStr)
		return This.ReplaceThisSubStringBetween(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr)

		def ReplaceThisSubStringBoundedByQ(pcSubStr, pacBounds, pcNewSubstr)
			This.ReplaceThisSubStringBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
			return This

	def ReplaceThisBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
		This.ReplaceThisSubStringBetween(pcSubStr, pacBounds[1], pacBounds[2], pcNewSubstr)

		def ReplaceThisBoundedByQ(pcSubStr, pacBounds, pcNewSubstr)
			This.ReplaceThisBoundedBy(pcSubStr, pacBounds, pcNewSubstr)
			return This

	  #---------------------------------------#
	 #  ALTERNATIVES OF ReplaceAnyBetween()  #
	#---------------------------------------#

	def ReplaceSubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		if isString(pacBounds)
			This.ReplaceAnyBetweenCS(pacBounds, pacBounds, pcNewSubStr, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsListOfPairs()
			This.ReplaceAnyBetweenCS(pacBounds[1], pacBounds[2], pcNewSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or pair of strings.")
		ok

		def ReplaceAnyBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceSubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBoundedByCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBoundedByCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBetweenCSQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBetweenCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceSectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(ppacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBoundedByCSQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBoundedByCS(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)
		return This.ReplaceAnyBoundedByCS(pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

	def ReplaceSubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBoundedByQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBoundedBy(pcBound1, pcBound2, pcNewSubStr)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBetween(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetween(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBetweenQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBetween(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceSectionsBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceSectionsBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceSectionsBoundedBy(pacBounds, pcNewSubStr)
			return This

	def ReplaceAnySectionBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceAnySectionBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySectionBoundedBy(pacBounds, pcNewSubStr)
			return This

	def ReplaceAnySectionsBoundedBy(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedBy(pacBounds, pcNewSubStr)

		def ReplaceAnySectionsBoundedByQ(pacBounds, pcNewSubStr)
			This.ReplaceAnySectionsBoundedBy(pacBounds, pcNewSubStr)
			return This

	  #-----------------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetweenReplaced()  #
	#-----------------------------------------------#

	def AnyBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def AnyBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SectionsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBoundedByReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCS(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AnyBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SubStringsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnyBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SectionsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBoundedByReplaced(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplaced(pcBound1, pcBound2, pcNewSubStr)

	  #----------------------------#
	 #  ALTERNATIVES OF Remove()  #
	#----------------------------#

	def RemoveAllCS(pSubStr, pCaseSensitive)
		This.RemoveCS(pSubStr, pCaseSensitive)

		def RemoveAllCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllCS(pSubStr, pCaseSensitive)
			return This

	def RemoveSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveSubstringCS(pSubStr, pCaseSensitive)
			return This

	def RemoveAllOccurrencesOfSubstringCS(pcSubStr, pCaseSensitive)
		This.RemoveCS(pcSubStr, pCaseSensitive)

		def RemoveAllOccurrencesOfSubstringCSQ(pSubStr, pCaseSensitive)
			This.RemoveAllOccurrencesOfSubstringCS(pSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def RemoveAll(pSubStr)
		This.Remove(pSubStr)

		def RemoveAllQ(pSubStr)
			This.RemoveAll(pSubStr)
			return This

	def RemoveSubstring(pcSubStr, pCaseSensitive)
		This.Remove(pcSubStr)

		def RemoveSubstringQ(pSubStr)
			This.RemoveSubstring(pSubStr)
			return This

	def RemoveAllOccurrencesOfSubstring(pcSubStr)
		This.Remove(pcSubStr)

		def RemoveAllOccurrencesOfSubstringQ(pSubStr)
			This.RemoveAllOccurrencesOfSubstring(pSubStr)
			return This

	  #-------------------------------------------#
	 #  ALTERNATIVES OF ReplaceAnyBetweenCSIB()  #
	#-------------------------------------------#

	def ReplaceSubStringsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		if isString(pacBounds)
			This.ReplaceAnyBetweenCSIB(pacBounds, pacBounds, pcNewSubStr, pCaseSensitive)

		but isList(pacBounds) and Q(pacBounds).IsPairOfStrings()
			This.ReplaceAnyBetweenCSIB(pacBounds[1], pacBounds[2], pcNewSubStr, pCaseSensitive)

		else
			StzRaise("Incorrect param type! pacBounds must be a string or apair of strings.")
		ok

	def ReplaceSubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSubStringsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySubStringsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySubStringsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBetweenCSIBQ(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBetweenCSIB(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
			return This

	#--

	def ReplaceSectionsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceSectionsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceSectionsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	def ReplaceAnySectionsBoundedByCSIB(ppacBounds, pcNewSubStr, pCaseSensitive)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)

		def ReplaceAnySectionsBoundedByCSIBQ(pacBounds, pcNewSubStr, pCaseSensitive)
			This.ReplaceAnySectionsBoundedByCSIB(pacBounds, pcNewSubStr, pCaseSensitive)
			return This

	#-- WITHOUT CASESENSITIVITY

	def ReplaceSubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceAnyBoundedByIB(pacBounds, pcNewSubStr)
		This.ReplaceAnyBoundedByCSIB(pacBounds, pcNewSubStr, :CaseSensitive = TRUE)

	def ReplaceSubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSubStringsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySubStringsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySubStringsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def ReplaceSectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBetweenIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBetweenIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBetweenIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	#--

	def ReplaceSectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceanyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceSectionsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceSectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	def ReplaceAnySectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
		This.ReplaceAnyBoundedByIB(pcBound1, pcBound2, pcNewSubStr)

		def ReplaceAnySectionsBoundedByIBQ(pcBound1, pcBound2, pcNewSubStr)
			This.ReplaceAnySectionsBoundedByIB(pcBound1, pcBound2, pcNewSubStr)
			return This

	  #-------------------------------------------------#
	 #  ALTERNATIVES OF SubStringsBetweenReplacedXT()  #
	#-------------------------------------------------#

	def AnySubStringBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SubStringsBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySubStringsBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SubStringsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#--

	def SectionsBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	def AnySectionsBoundedByReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)
		return This.SectionsBetweenReplacedCSXT(pcBound1, pcBound2, pcNewSubStr, pCaseSensitive)

	#-- WITHOUT CASESENSITIVITY

	def AnySubStringBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SubStringsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySubStringsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SubStringsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#-- Allowing the use of "SECTION" instead of "SUBSTRING"

	def AnySectionBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	#--

	def SectionsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

	def AnySectionsBoundedByReplacedXT(pcBound1, pcBound2, pcNewSubStr)
		return This.SectionsBetweenReplacedXT(pcBound1, pcBound2, pcNewSubStr)

